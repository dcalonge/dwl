diff '--color=auto' -urN dwl/config.def.h mis_repos/dwl/config.def.h
--- dwl/config.def.h	2024-08-06 20:03:27.000000000 +0200
+++ mis_repos/dwl/config.def.h	2024-10-01 23:08:38.139644179 +0200
@@ -1,176 +1,199 @@
-/* Taken from https://github.com/djpohly/dwl/issues/466 */
 #define COLOR(hex)    { ((hex >> 24) & 0xFF) / 255.0f, \
                         ((hex >> 16) & 0xFF) / 255.0f, \
                         ((hex >> 8) & 0xFF) / 255.0f, \
                         (hex & 0xFF) / 255.0f }
-/* appearance */
-static const int sloppyfocus               = 1;  /* focus follows mouse */
-static const int bypass_surface_visibility = 0;  /* 1 means idle inhibitors will disable idle tracking even if it's surface isn't visible  */
-static const unsigned int borderpx         = 1;  /* border pixel of windows */
-static const float rootcolor[]             = COLOR(0x222222ff);
-static const float bordercolor[]           = COLOR(0x444444ff);
-static const float focuscolor[]            = COLOR(0x005577ff);
-static const float urgentcolor[]           = COLOR(0xff0000ff);
-/* This conforms to the xdg-protocol. Set the alpha to zero to restore the old behavior */
-static const float fullscreen_bg[]         = {0.1f, 0.1f, 0.1f, 1.0f}; /* You can also use glsl colors */
-
-/* tagging - TAGCOUNT must be no greater than 31 */
-#define TAGCOUNT (9)
-
-/* logging */
-static int log_level = WLR_ERROR;
-
-/* NOTE: ALWAYS keep a rule declared even if you don't use rules (e.g leave at least one example) */
-static const Rule rules[] = {
-	/* app_id             title       tags mask     isfloating   monitor */
-	/* examples: */
-	{ "Gimp_EXAMPLE",     NULL,       0,            1,           -1 }, /* Start on currently visible tags floating, not tiled */
-	{ "firefox_EXAMPLE",  NULL,       1 << 8,       0,           -1 }, /* Start on ONLY tag "9" */
-};
+/* Appearance */
+    static const int sloppyfocus               = 1;  /* focus follows mouse */
+    static const int bypass_surface_visibility = 0;  /* 1 means idle inhibitors will disable idle tracking even if it's surface isn't visible  */
+    static const int smartgaps                 = 0;  /* 1 means no outer gap when there is only one window */
+    static int gaps                            = 1;  /* 1 means gaps between windows are added */
+    static const unsigned int gappx            = 8; /* gap pixel between windows */
+    static const unsigned int borderpx         = 2;  /* border pixel of windows */
+    static const int user_bh		           = 24; /* 0 means that dwl will calculate barheight, >= 1 means dwl will use user_bh as the bar height. */
+    static const int showbar                   = 1; /* 0 means no bar */
+    static const int topbar                    = 1; /* 0 means bottom bar */
+    static const char *fonts[]                 = {"JetbrainsMono Nerd Font:size=11:antialias=true:hinting=true",
+                                                    "JoyPixels Regular:size=10:antialias=true:autohint=true"};
+    static const float rootcolor[]             = COLOR(0x000000ff);
+
+    /* This conforms to the xdg-protocol. Set the alpha to zero to restore the old behavior */
+    static const float fullscreen_bg[]         = {0.1f, 0.1f, 0.1f, 1.0f}; /* You can also use glsl colors */
+    static uint32_t colors[][3]                = {
+    	/*               fg          bg          border    */
+    	[SchemeNorm] = { 0x93a1a1ff, 0x000000ff, 0x444444ff },
+    	[SchemeSel]  = { 0xeeeeeeff, 0x000000ff, 0x93a1a1ff },
+    	[SchemeUrg]  = { 0,          0,          0x770000ff },
+    };
+
+    /* Tagging - TAGCOUNT must be no greater than 31 */
+    static char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
+
+/* Logging */
+    static int log_level = WLR_ERROR;
+
+/* Rules */
+    static const Rule rules[] = {
+    	/* app_id             title           tags mask     isfloating   monitor */
+        { NULL,              "Open File",     0,            1,           -1 },
+        { NULL,              "Open Folder",   0,            1,           -1 },
+        { "mpv",               NULL,           0,            1,           -1 },
+        { "imv",               NULL,           0,            1,           -1 },
+    };
 
 /* layout(s) */
-static const Layout layouts[] = {
-	/* symbol     arrange function */
-	{ "[]=",      tile },
-	{ "><>",      NULL },    /* no layout function means floating behavior */
-	{ "[M]",      monocle },
-};
+    static const Layout layouts[] = {
+    	{ "[]=",      tile },
+    	{ "><>",      NULL },    /* no layout function means floating behavior */
+    	{ "[M]",      monocle },
+    };
 
 /* monitors */
-/* (x=-1, y=-1) is reserved as an "autoconfigure" monitor position indicator
- * WARNING: negative values other than (-1, -1) cause problems with Xwayland clients
- * https://gitlab.freedesktop.org/xorg/xserver/-/issues/899
-*/
-/* NOTE: ALWAYS add a fallback rule, even if you are completely sure it won't be used */
-static const MonitorRule monrules[] = {
-	/* name       mfact  nmaster scale layout       rotate/reflect                x    y */
-	/* example of a HiDPI laptop monitor:
-	{ "eDP-1",    0.5f,  1,      2,    &layouts[0], WL_OUTPUT_TRANSFORM_NORMAL,   -1,  -1 },
-	*/
-	/* defaults */
-	{ NULL,       0.55f, 1,      1,    &layouts[0], WL_OUTPUT_TRANSFORM_NORMAL,   -1,  -1 },
-};
+    static const MonitorRule monrules[] = {
+    	/* name       mfact  nmaster scale layout       rotate/reflect                x    y */
+    	{ NULL,       0.55f, 1,      1,    &layouts[0], WL_OUTPUT_TRANSFORM_NORMAL,   -1,  -1 },
+    };
 
 /* keyboard */
-static const struct xkb_rule_names xkb_rules = {
-	/* can specify fields: rules, model, layout, variant, options */
-	/* example:
-	.options = "ctrl:nocaps",
-	*/
-	.options = NULL,
-};
+    static const struct xkb_rule_names xkb_rules = {
+        .options = NULL,
+        .layout = "es",
+    };
 
-static const int repeat_rate = 25;
-static const int repeat_delay = 600;
+    static const int repeat_rate = 25;
+    static const int repeat_delay = 600;
 
 /* Trackpad */
-static const int tap_to_click = 1;
-static const int tap_and_drag = 1;
-static const int drag_lock = 1;
-static const int natural_scrolling = 0;
-static const int disable_while_typing = 1;
-static const int left_handed = 0;
-static const int middle_button_emulation = 0;
-/* You can choose between:
-LIBINPUT_CONFIG_SCROLL_NO_SCROLL
-LIBINPUT_CONFIG_SCROLL_2FG
-LIBINPUT_CONFIG_SCROLL_EDGE
-LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN
-*/
-static const enum libinput_config_scroll_method scroll_method = LIBINPUT_CONFIG_SCROLL_2FG;
-
-/* You can choose between:
-LIBINPUT_CONFIG_CLICK_METHOD_NONE
-LIBINPUT_CONFIG_CLICK_METHOD_BUTTON_AREAS
-LIBINPUT_CONFIG_CLICK_METHOD_CLICKFINGER
-*/
-static const enum libinput_config_click_method click_method = LIBINPUT_CONFIG_CLICK_METHOD_BUTTON_AREAS;
-
-/* You can choose between:
-LIBINPUT_CONFIG_SEND_EVENTS_ENABLED
-LIBINPUT_CONFIG_SEND_EVENTS_DISABLED
-LIBINPUT_CONFIG_SEND_EVENTS_DISABLED_ON_EXTERNAL_MOUSE
-*/
-static const uint32_t send_events_mode = LIBINPUT_CONFIG_SEND_EVENTS_ENABLED;
-
-/* You can choose between:
-LIBINPUT_CONFIG_ACCEL_PROFILE_FLAT
-LIBINPUT_CONFIG_ACCEL_PROFILE_ADAPTIVE
-*/
-static const enum libinput_config_accel_profile accel_profile = LIBINPUT_CONFIG_ACCEL_PROFILE_ADAPTIVE;
-static const double accel_speed = 0.0;
-
-/* You can choose between:
-LIBINPUT_CONFIG_TAP_MAP_LRM -- 1/2/3 finger tap maps to left/right/middle
-LIBINPUT_CONFIG_TAP_MAP_LMR -- 1/2/3 finger tap maps to left/middle/right
-*/
-static const enum libinput_config_tap_button_map button_map = LIBINPUT_CONFIG_TAP_MAP_LRM;
-
-/* If you want to use the windows key for MODKEY, use WLR_MODIFIER_LOGO */
-#define MODKEY WLR_MODIFIER_ALT
-
-#define TAGKEYS(KEY,SKEY,TAG) \
-	{ MODKEY,                    KEY,            view,            {.ui = 1 << TAG} }, \
-	{ MODKEY|WLR_MODIFIER_CTRL,  KEY,            toggleview,      {.ui = 1 << TAG} }, \
-	{ MODKEY|WLR_MODIFIER_SHIFT, SKEY,           tag,             {.ui = 1 << TAG} }, \
-	{ MODKEY|WLR_MODIFIER_CTRL|WLR_MODIFIER_SHIFT,SKEY,toggletag, {.ui = 1 << TAG} }
-
-/* helper for spawning shell commands in the pre dwm-5.0 fashion */
-#define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
-
-/* commands */
-static const char *termcmd[] = { "foot", NULL };
-static const char *menucmd[] = { "wmenu-run", NULL };
-
-static const Key keys[] = {
-	/* Note that Shift changes certain key codes: c -> C, 2 -> at, etc. */
-	/* modifier                  key                 function        argument */
-	{ MODKEY,                    XKB_KEY_p,          spawn,          {.v = menucmd} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_Return,     spawn,          {.v = termcmd} },
-	{ MODKEY,                    XKB_KEY_j,          focusstack,     {.i = +1} },
-	{ MODKEY,                    XKB_KEY_k,          focusstack,     {.i = -1} },
-	{ MODKEY,                    XKB_KEY_i,          incnmaster,     {.i = +1} },
-	{ MODKEY,                    XKB_KEY_d,          incnmaster,     {.i = -1} },
-	{ MODKEY,                    XKB_KEY_h,          setmfact,       {.f = -0.05f} },
-	{ MODKEY,                    XKB_KEY_l,          setmfact,       {.f = +0.05f} },
-	{ MODKEY,                    XKB_KEY_Return,     zoom,           {0} },
-	{ MODKEY,                    XKB_KEY_Tab,        view,           {0} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_C,          killclient,     {0} },
-	{ MODKEY,                    XKB_KEY_t,          setlayout,      {.v = &layouts[0]} },
-	{ MODKEY,                    XKB_KEY_f,          setlayout,      {.v = &layouts[1]} },
-	{ MODKEY,                    XKB_KEY_m,          setlayout,      {.v = &layouts[2]} },
-	{ MODKEY,                    XKB_KEY_space,      setlayout,      {0} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_space,      togglefloating, {0} },
-	{ MODKEY,                    XKB_KEY_e,         togglefullscreen, {0} },
-	{ MODKEY,                    XKB_KEY_0,          view,           {.ui = ~0} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_parenright, tag,            {.ui = ~0} },
-	{ MODKEY,                    XKB_KEY_comma,      focusmon,       {.i = WLR_DIRECTION_LEFT} },
-	{ MODKEY,                    XKB_KEY_period,     focusmon,       {.i = WLR_DIRECTION_RIGHT} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_less,       tagmon,         {.i = WLR_DIRECTION_LEFT} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_greater,    tagmon,         {.i = WLR_DIRECTION_RIGHT} },
-	TAGKEYS(          XKB_KEY_1, XKB_KEY_exclam,                     0),
-	TAGKEYS(          XKB_KEY_2, XKB_KEY_at,                         1),
-	TAGKEYS(          XKB_KEY_3, XKB_KEY_numbersign,                 2),
-	TAGKEYS(          XKB_KEY_4, XKB_KEY_dollar,                     3),
-	TAGKEYS(          XKB_KEY_5, XKB_KEY_percent,                    4),
-	TAGKEYS(          XKB_KEY_6, XKB_KEY_asciicircum,                5),
-	TAGKEYS(          XKB_KEY_7, XKB_KEY_ampersand,                  6),
-	TAGKEYS(          XKB_KEY_8, XKB_KEY_asterisk,                   7),
-	TAGKEYS(          XKB_KEY_9, XKB_KEY_parenleft,                  8),
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_Q,          quit,           {0} },
-
-	/* Ctrl-Alt-Backspace and Ctrl-Alt-Fx used to be handled by X server */
-	{ WLR_MODIFIER_CTRL|WLR_MODIFIER_ALT,XKB_KEY_Terminate_Server, quit, {0} },
-	/* Ctrl-Alt-Fx is used to switch to another VT, if you don't know what a VT is
-	 * do not remove them.
-	 */
-#define CHVT(n) { WLR_MODIFIER_CTRL|WLR_MODIFIER_ALT,XKB_KEY_XF86Switch_VT_##n, chvt, {.ui = (n)} }
-	CHVT(1), CHVT(2), CHVT(3), CHVT(4), CHVT(5), CHVT(6),
-	CHVT(7), CHVT(8), CHVT(9), CHVT(10), CHVT(11), CHVT(12),
-};
-
-static const Button buttons[] = {
-	{ MODKEY, BTN_LEFT,   moveresize,     {.ui = CurMove} },
-	{ MODKEY, BTN_MIDDLE, togglefloating, {0} },
-	{ MODKEY, BTN_RIGHT,  moveresize,     {.ui = CurResize} },
-};
+    static const int tap_to_click = 1;
+    static const int tap_and_drag = 1;
+    static const int drag_lock = 1;
+    static const int natural_scrolling = 1;
+    static const int disable_while_typing = 1;
+    static const int left_handed = 0;
+    static const int middle_button_emulation = 0;
+    static const enum libinput_config_scroll_method scroll_method = LIBINPUT_CONFIG_SCROLL_2FG;
+    static const enum libinput_config_click_method click_method = LIBINPUT_CONFIG_CLICK_METHOD_BUTTON_AREAS;
+    static const uint32_t send_events_mode = LIBINPUT_CONFIG_SEND_EVENTS_ENABLED;
+    static const enum libinput_config_accel_profile accel_profile = LIBINPUT_CONFIG_ACCEL_PROFILE_ADAPTIVE;
+    static const double accel_speed = 0.0;
+    static const enum libinput_config_tap_button_map button_map = LIBINPUT_CONFIG_TAP_MAP_LRM;
+
+/* Keybindings */
+    #define MODKEY WLR_MODIFIER_LOGO
+
+    void movetagandview(const Arg *arg) { tag(arg); view(arg); }
+
+    #define TAGKEYS(KEY,SKEY,TAG) \
+    	{ MODKEY,                    KEY,            view,            {.ui = 1 << TAG} }, \
+    	{ MODKEY|WLR_MODIFIER_CTRL,  KEY,            toggleview,      {.ui = 1 << TAG} }, \
+    	{ MODKEY|WLR_MODIFIER_SHIFT, SKEY,           movetagandview,  {.ui = 1 << TAG} }, \
+    	{ MODKEY|WLR_MODIFIER_CTRL|WLR_MODIFIER_SHIFT,SKEY,toggletag, {.ui = 1 << TAG} }
+
+    #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
+
+    /* commands */
+    static const char *termcmd[]  = { "foot", NULL };
+    static const char *browsercmd[]  = { "google-chrome-stable", NULL };
+    static const char *btopcmd[]  = { "foot", "-c", "/home/daniel/.config/foot/foot_no_pad.ini", "-e", "btop", NULL };
+    static const char *nvimcmd[]  = { "foot", "-c", "/home/daniel/.config/foot/foot_no_pad.ini", "-e", "nvim", NULL };
+    static const char *yazicmd[]  = { "foot", "-c", "/home/daniel/.config/foot/foot_no_pad.ini", "-e", "yazi", NULL };
+    static const char *pavucontrolcmd[] = { "pavucontrol", NULL };
+    static const char *thunarcmd[]  = { "thunar", NULL };
+    static const char *codecmd[]  = { "code", NULL };
+
+    /* Keys */
+    static const Key keys[] = {
+        /* Apps and Scripts */
+        { MODKEY, XKB_KEY_Return, spawn, {.v = termcmd } },
+        { MODKEY, XKB_KEY_b, spawn, {.v = browsercmd } },
+        { MODKEY, XKB_KEY_h, spawn, {.v = btopcmd } },
+        { MODKEY, XKB_KEY_y, spawn, {.v = yazicmd } },
+        { MODKEY, XKB_KEY_n, spawn, {.v = nvimcmd } },
+        { MODKEY, XKB_KEY_p, spawn, {.v = pavucontrolcmd } },
+        { MODKEY, XKB_KEY_w, spawn, SHCMD("killall bemenu || networkmanager_dmenu") },
+        { MODKEY, XKB_KEY_e, spawn, {.v = thunarcmd } },
+        { MODKEY, XKB_KEY_c, spawn, {.v = codecmd } },
+        { MODKEY, XKB_KEY_z, spawn, SHCMD("zeditor") },
+        { MODKEY, XKB_KEY_d, spawn, SHCMD("killall bemenu || j4-dmenu-desktop --no-generic --skip-i3-exec-check -b --dmenu bemenu -t foot") },
+        { MODKEY, XKB_KEY_l, spawn, SHCMD("killall bemenu || /home/daniel/scripts/dmenu_logout_dwl.sh") },
+        { MODKEY, XKB_KEY_u, spawn, SHCMD("killall bemenu || /home/daniel/scripts/prompt.sh && kill -64 $(pidof someblocks)") },
+        { MODKEY, XKB_KEY_v, spawn, SHCMD("killall bemenu || /home/daniel/scripts/cliphist-rofi") },
+        { MODKEY, XKB_KEY_a, spawn, SHCMD("killall bemenu || /home/daniel/scripts/dmenu_man") },
+        { MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_F, togglefullscreen, {0} },
+        { MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_S, spawn, SHCMD("/home/daniel/scripts/screenshot_river.sh") },
+        { MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_W, spawn, SHCMD("/home/daniel/scripts/background.sh") },
+        { MODKEY, XKB_KEY_q, killclient, {0} },
+
+        /* Volume and Brightness Controls */
+        { 0, XKB_KEY_XF86AudioMute, spawn, SHCMD("wpctl set-mute @DEFAULT_AUDIO_SINK@ toggle && kill -44 $(pidof someblocks)") },
+        { 0, XKB_KEY_XF86AudioMicMute, spawn, SHCMD("wpctl set-mute @DEFAULT_AUDIO_SOURCE@ toggle && kill -49 $(pidof someblocks)") },
+        { 0, XKB_KEY_XF86AudioLowerVolume, spawn, SHCMD("wpctl set-volume @DEFAULT_AUDIO_SINK@ 5%- && kill -44 $(pidof someblocks)") },
+        { 0, XKB_KEY_XF86AudioRaiseVolume, spawn, SHCMD("wpctl set-volume -l 1.5 @DEFAULT_AUDIO_SINK@ 5%+ && kill -44 $(pidof someblocks)") },
+        { 0, XKB_KEY_XF86MonBrightnessUp, spawn, SHCMD("brightnessctl set +5% && kill -54 $(pidof someblocks)") },
+        { 0, XKB_KEY_XF86MonBrightnessDown, spawn, SHCMD("brightnessctl set 5%- && kill -54 $(pidof someblocks)") },
+
+        /* Window Manager Stuff */
+        { MODKEY, XKB_KEY_Left, focusdir, {.ui = 0} },
+        { MODKEY, XKB_KEY_Right, focusdir, {.ui = 1} },
+        { MODKEY, XKB_KEY_Up, focusstack, {.i = -1} },
+        { MODKEY, XKB_KEY_Down, focusstack, {.i = +1} },
+        { MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_Left, swapdir, {.ui = 0} },
+        { MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_Right, swapdir, {.ui = 1} },
+        { MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_Up, swapdir, {.ui = 2} },
+        { MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_Down, swapdir, {.ui = 3} },
+        { MODKEY, XKB_KEY_plus, incnmaster, {.i = +1} },
+        { MODKEY, XKB_KEY_minus, incnmaster, {.i = -1} },
+        { MODKEY|WLR_MODIFIER_CTRL, XKB_KEY_Right, setmfact, {.f = +0.05f} },
+        { MODKEY|WLR_MODIFIER_CTRL, XKB_KEY_Left, setmfact, {.f = -0.05f} },
+        { MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_Return, zoom, {0} },
+        { MODKEY, XKB_KEY_Tab, view, {0} },
+        { MODKEY, XKB_KEY_q, killclient, {0} },
+        { MODKEY, XKB_KEY_t, setlayout, {.v = &layouts[0]} },
+        { MODKEY, XKB_KEY_f, setlayout, {.v = &layouts[1]} },
+        { MODKEY, XKB_KEY_m, setlayout, {.v = &layouts[2]} },
+        { MODKEY, XKB_KEY_space, togglefloating, {0} },
+        { MODKEY, XKB_KEY_0, view, {.ui = ~0} },
+        { MODKEY, XKB_KEY_o, focusmon, {.i = WLR_DIRECTION_LEFT} },
+        { MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_O, tagmon, {.i = WLR_DIRECTION_LEFT} },
+        TAGKEYS(XKB_KEY_1, XKB_KEY_exclam, 0),
+        TAGKEYS(XKB_KEY_2, XKB_KEY_quotedbl, 1),
+        TAGKEYS(XKB_KEY_3, XKB_KEY_periodcentered, 2),
+        TAGKEYS(XKB_KEY_4, XKB_KEY_dollar, 3),
+        TAGKEYS(XKB_KEY_5, XKB_KEY_percent, 4),
+        TAGKEYS(XKB_KEY_6, XKB_KEY_ampersand, 5),
+        TAGKEYS(XKB_KEY_7, XKB_KEY_slash, 6),
+        TAGKEYS(XKB_KEY_8, XKB_KEY_parenleft, 7),
+        TAGKEYS(XKB_KEY_9, XKB_KEY_parenright, 8),
+        { MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_Q, spawn, SHCMD("pkill -x someblocks && pkill -x dwl") },
+
+        /* Change TTYs */
+        #define CHVT(n) { WLR_MODIFIER_CTRL|WLR_MODIFIER_ALT,XKB_KEY_XF86Switch_VT_##n, chvt, {.ui = (n)} }
+        CHVT(1), CHVT(2), CHVT(3), CHVT(4), CHVT(5), CHVT(6),
+        CHVT(7), CHVT(8), CHVT(9), CHVT(10), CHVT(11), CHVT(12),
+    };
+
+    static const Key lockedkeys[] = {
+        { 0, XKB_KEY_XF86AudioMute, spawn, SHCMD("wpctl set-mute @DEFAULT_AUDIO_SINK@ toggle && kill -44 $(pidof someblocks)") },
+        { 0, XKB_KEY_XF86AudioLowerVolume, spawn, SHCMD("wpctl set-volume @DEFAULT_AUDIO_SINK@ 5%- && kill -44 $(pidof someblocks)") },
+        { 0, XKB_KEY_XF86AudioRaiseVolume, spawn, SHCMD("wpctl set-volume -l 1.5 @DEFAULT_AUDIO_SINK@ 5%+ && kill -44 $(pidof someblocks)") },
+        { 0, XKB_KEY_XF86MonBrightnessUp, spawn, SHCMD("brightnessctl set +5% && kill -54 $(pidof someblocks)") },
+        { 0, XKB_KEY_XF86MonBrightnessDown, spawn, SHCMD("brightnessctl set 5%- && kill -54 $(pidof someblocks)") },
+
+        CHVT(1), CHVT(2), CHVT(3), CHVT(4), CHVT(5), CHVT(6),
+        CHVT(7), CHVT(8), CHVT(9), CHVT(10), CHVT(11), CHVT(12),
+    };
+
+/* Mouse actions */
+    static const Button buttons[] = {
+        { ClkLtSymbol, 0, BTN_LEFT, setlayout, {.v = &layouts[0]} },
+        { ClkLtSymbol, 0, BTN_RIGHT, setlayout, {.v = &layouts[1]} },
+        { ClkLtSymbol, 0, BTN_MIDDLE, setlayout, {.v = &layouts[2]} },
+        { ClkTitle, 0, BTN_LEFT, zoom, {0} },
+        { ClkStatus, 0, BTN_LEFT, spawn, SHCMD("killall bemenu || j4-dmenu-desktop --no-generic --skip-i3-exec-check -b --dmenu bemenu -t foot") },
+        { ClkClient, MODKEY, BTN_LEFT, moveresize, {.ui = CurMove} },
+        { ClkClient, MODKEY, BTN_MIDDLE, togglefloating, {0} },
+        { ClkClient, MODKEY|WLR_MODIFIER_CTRL, BTN_LEFT, moveresize, {.ui = CurResize} },
+        { ClkTagBar, 0, BTN_LEFT, view, {0} },
+        { ClkTagBar, 0, BTN_MIDDLE, toggleview, {0} },
+        { ClkTagBar, 0, BTN_RIGHT, movetagandview, {0} },
+        { ClkTagBar, MODKEY, BTN_LEFT, toggletag, {0} },
+    };
diff '--color=auto' -urN dwl/cursor-shape-v1-protocol.h mis_repos/dwl/cursor-shape-v1-protocol.h
--- dwl/cursor-shape-v1-protocol.h	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/cursor-shape-v1-protocol.h	2024-10-01 23:08:38.139644179 +0200
@@ -0,0 +1,175 @@
+/* Generated by wayland-scanner 1.23.1 */
+
+#ifndef CURSOR_SHAPE_V1_ENUM_PROTOCOL_H
+#define CURSOR_SHAPE_V1_ENUM_PROTOCOL_H
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#ifndef WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ENUM
+#define WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ENUM
+/**
+ * @ingroup iface_wp_cursor_shape_device_v1
+ * cursor shapes
+ *
+ * This enum describes cursor shapes.
+ *
+ * The names are taken from the CSS W3C specification:
+ * https://w3c.github.io/csswg-drafts/css-ui/#cursor
+ */
+enum wp_cursor_shape_device_v1_shape {
+	/**
+	 * default cursor
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_DEFAULT = 1,
+	/**
+	 * a context menu is available for the object under the cursor
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_CONTEXT_MENU = 2,
+	/**
+	 * help is available for the object under the cursor
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_HELP = 3,
+	/**
+	 * pointer that indicates a link or another interactive element
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_POINTER = 4,
+	/**
+	 * progress indicator
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_PROGRESS = 5,
+	/**
+	 * program is busy, user should wait
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_WAIT = 6,
+	/**
+	 * a cell or set of cells may be selected
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_CELL = 7,
+	/**
+	 * simple crosshair
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_CROSSHAIR = 8,
+	/**
+	 * text may be selected
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_TEXT = 9,
+	/**
+	 * vertical text may be selected
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_VERTICAL_TEXT = 10,
+	/**
+	 * drag-and-drop: alias of/shortcut to something is to be created
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ALIAS = 11,
+	/**
+	 * drag-and-drop: something is to be copied
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_COPY = 12,
+	/**
+	 * drag-and-drop: something is to be moved
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_MOVE = 13,
+	/**
+	 * drag-and-drop: the dragged item cannot be dropped at the current cursor location
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NO_DROP = 14,
+	/**
+	 * drag-and-drop: the requested action will not be carried out
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NOT_ALLOWED = 15,
+	/**
+	 * drag-and-drop: something can be grabbed
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_GRAB = 16,
+	/**
+	 * drag-and-drop: something is being grabbed
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_GRABBING = 17,
+	/**
+	 * resizing: the east border is to be moved
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_E_RESIZE = 18,
+	/**
+	 * resizing: the north border is to be moved
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_N_RESIZE = 19,
+	/**
+	 * resizing: the north-east corner is to be moved
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NE_RESIZE = 20,
+	/**
+	 * resizing: the north-west corner is to be moved
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NW_RESIZE = 21,
+	/**
+	 * resizing: the south border is to be moved
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_S_RESIZE = 22,
+	/**
+	 * resizing: the south-east corner is to be moved
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_SE_RESIZE = 23,
+	/**
+	 * resizing: the south-west corner is to be moved
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_SW_RESIZE = 24,
+	/**
+	 * resizing: the west border is to be moved
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_W_RESIZE = 25,
+	/**
+	 * resizing: the east and west borders are to be moved
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_EW_RESIZE = 26,
+	/**
+	 * resizing: the north and south borders are to be moved
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NS_RESIZE = 27,
+	/**
+	 * resizing: the north-east and south-west corners are to be moved
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NESW_RESIZE = 28,
+	/**
+	 * resizing: the north-west and south-east corners are to be moved
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NWSE_RESIZE = 29,
+	/**
+	 * resizing: that the item/column can be resized horizontally
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_COL_RESIZE = 30,
+	/**
+	 * resizing: that the item/row can be resized vertically
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ROW_RESIZE = 31,
+	/**
+	 * something can be scrolled in any direction
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ALL_SCROLL = 32,
+	/**
+	 * something can be zoomed in
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ZOOM_IN = 33,
+	/**
+	 * something can be zoomed out
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ZOOM_OUT = 34,
+};
+#endif /* WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ENUM */
+
+#ifndef WP_CURSOR_SHAPE_DEVICE_V1_ERROR_ENUM
+#define WP_CURSOR_SHAPE_DEVICE_V1_ERROR_ENUM
+enum wp_cursor_shape_device_v1_error {
+	/**
+	 * the specified shape value is invalid
+	 */
+	WP_CURSOR_SHAPE_DEVICE_V1_ERROR_INVALID_SHAPE = 1,
+};
+#endif /* WP_CURSOR_SHAPE_DEVICE_V1_ERROR_ENUM */
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff '--color=auto' -urN dwl/drwl.h mis_repos/dwl/drwl.h
--- dwl/drwl.h	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/drwl.h	2024-10-01 23:08:38.139644179 +0200
@@ -0,0 +1,311 @@
+/*
+ * drwl - https://codeberg.org/sewn/drwl
+ *
+ * Copyright (c) 2023-2024 sewn <sewn@disroot.org>
+ * Copyright (c) 2024 notchoc <notchoc@disroot.org>
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * The UTF-8 Decoder included is from Bjoern Hoehrmann:
+ * Copyright (c) 2008-2010 Bjoern Hoehrmann <bjoern@hoehrmann.de>
+ * See http://bjoern.hoehrmann.de/utf-8/decoder/dfa/ for details.
+ */
+#pragma once
+
+#include <stdlib.h>
+#include <fcft/fcft.h>
+#include <pixman-1/pixman.h>
+
+enum { ColFg, ColBg, ColBorder }; /* colorscheme index */
+
+typedef struct fcft_font Fnt;
+typedef pixman_image_t Img;
+
+typedef struct {
+	Img *image;
+	Fnt *font;
+	uint32_t *scheme;
+} Drwl;
+
+#define UTF8_ACCEPT 0
+#define UTF8_REJECT 12
+#define UTF8_INVALID 0xFFFD
+
+static const uint8_t utf8d[] = {
+	 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+	 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+	 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+	 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+	 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,  9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
+	 7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+	 8,8,2,2,2,2,2,2,2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
+	10,3,3,3,3,3,3,3,3,3,3,3,3,4,3,3, 11,6,6,6,5,8,8,8,8,8,8,8,8,8,8,8,
+
+	 0,12,24,36,60,96,84,12,12,12,48,72, 12,12,12,12,12,12,12,12,12,12,12,12,
+	12, 0,12,12,12,12,12, 0,12, 0,12,12, 12,24,12,12,12,12,12,24,12,24,12,12,
+	12,12,12,12,12,12,12,24,12,12,12,12, 12,24,12,12,12,12,12,12,12,24,12,12,
+	12,12,12,12,12,12,12,36,12,36,12,12, 12,36,12,12,12,12,12,36,12,36,12,12,
+	12,36,12,12,12,12,12,12,12,12,12,12,
+};
+
+static inline uint32_t
+utf8decode(uint32_t *state, uint32_t *codep, uint8_t byte)
+{
+	uint32_t type = utf8d[byte];
+
+	*codep = (*state != UTF8_ACCEPT) ?
+		(byte & 0x3fu) | (*codep << 6) :
+		(0xff >> type) & (byte);
+
+	*state = utf8d[256 + *state + type];
+	return *state;
+}
+
+static int
+drwl_init(void)
+{
+	fcft_set_scaling_filter(FCFT_SCALING_FILTER_LANCZOS3);
+	return fcft_init(FCFT_LOG_COLORIZE_AUTO, 0, FCFT_LOG_CLASS_ERROR);
+}
+
+static Drwl *
+drwl_create(void)
+{
+	Drwl *drwl;
+
+	if (!(drwl = calloc(1, sizeof(Drwl))))
+		return NULL;
+
+	return drwl;
+}
+
+static void
+drwl_setfont(Drwl *drwl, Fnt *font)
+{
+	if (drwl)
+		drwl->font = font;
+}
+
+static void
+drwl_setimage(Drwl *drwl, Img *image)
+{
+	if (drwl)
+		drwl->image = image;
+}
+
+static Fnt *
+drwl_font_create(Drwl *drwl, size_t count,
+		const char *names[static count], const char *attributes)
+{
+	Fnt *font = fcft_from_name(count, names, attributes);
+	if (drwl)
+		drwl_setfont(drwl, font);
+	return font;
+}
+
+static void
+drwl_font_destroy(Fnt *font)
+{
+	fcft_destroy(font);
+}
+
+static inline pixman_color_t
+convert_color(uint32_t clr)
+{
+	return (pixman_color_t){
+		((clr >> 24) & 0xFF) * 0x101 * (clr & 0xFF) / 0xFF,
+		((clr >> 16) & 0xFF) * 0x101 * (clr & 0xFF) / 0xFF,
+		((clr >> 8) & 0xFF) * 0x101 * (clr & 0xFF) / 0xFF,
+		(clr & 0xFF) * 0x101
+	};
+}
+
+static void
+drwl_setscheme(Drwl *drwl, uint32_t *scm)
+{
+	if (drwl)
+		drwl->scheme = scm;
+}
+
+static Img *
+drwl_image_create(Drwl *drwl, unsigned int w, unsigned int h, uint32_t *bits)
+{
+	Img *image;
+	pixman_region32_t clip;
+
+	image = pixman_image_create_bits_no_clear(
+		PIXMAN_a8r8g8b8, w, h, bits, w * 4);
+	if (!image)
+		return NULL;
+	pixman_region32_init_rect(&clip, 0, 0, w, h);
+	pixman_image_set_clip_region32(image, &clip);
+	pixman_region32_fini(&clip);
+
+	if (drwl)
+		drwl_setimage(drwl, image);
+	return image;
+}
+
+static void
+drwl_rect(Drwl *drwl,
+		int x, int y, unsigned int w, unsigned int h,
+		int filled, int invert)
+{
+	pixman_color_t clr;
+	if (!drwl || !drwl->scheme || !drwl->image)
+		return;
+
+	clr = convert_color(drwl->scheme[invert ? ColBg : ColFg]);
+	if (filled)
+		pixman_image_fill_rectangles(PIXMAN_OP_SRC, drwl->image, &clr, 1,
+			&(pixman_rectangle16_t){x, y, w, h});
+	else
+		pixman_image_fill_rectangles(PIXMAN_OP_SRC, drwl->image, &clr, 4,
+			(pixman_rectangle16_t[4]){
+				{ x,         y,         w, 1 },
+				{ x,         y + h - 1, w, 1 },
+				{ x,         y,         1, h },
+				{ x + w - 1, y,         1, h }});
+}
+
+static int
+drwl_text(Drwl *drwl,
+		int x, int y, unsigned int w, unsigned int h,
+		unsigned int lpad, const char *text, int invert)
+{
+	int ty;
+	int render = x || y || w || h;
+	long x_kern;
+	uint32_t cp = 0, last_cp = 0, state;
+	pixman_color_t clr;
+	pixman_image_t *fg_pix = NULL;
+	int noellipsis = 0;
+	const struct fcft_glyph *glyph, *eg = NULL;
+	int fcft_subpixel_mode = FCFT_SUBPIXEL_DEFAULT;
+
+	if (!drwl || (render && (!drwl->scheme || !w || !drwl->image)) || !text || !drwl->font)
+		return 0;
+
+	if (!render) {
+		w = invert ? invert : ~invert;
+	} else {
+		clr = convert_color(drwl->scheme[invert ? ColBg : ColFg]);
+		fg_pix = pixman_image_create_solid_fill(&clr);
+
+		drwl_rect(drwl, x, y, w, h, 1, !invert);
+
+		x += lpad;
+		w -= lpad;
+	}
+
+	if (render && (drwl->scheme[ColBg] & 0xFF) != 0xFF)
+		fcft_subpixel_mode = FCFT_SUBPIXEL_NONE;
+
+	if (render)
+		eg = fcft_rasterize_char_utf32(drwl->font, 0x2026 /* â€¦ */, fcft_subpixel_mode);
+
+	for (const char *p = text, *pp; pp = p, *p; p++) {
+		for (state = UTF8_ACCEPT; *p &&
+		     utf8decode(&state, &cp, *p) > UTF8_REJECT; p++)
+			;
+		if (!*p || state == UTF8_REJECT) {
+			cp = UTF8_INVALID;
+			if (p > pp)
+				p--;
+		}
+
+		glyph = fcft_rasterize_char_utf32(drwl->font, cp, fcft_subpixel_mode);
+		if (!glyph)
+			continue;
+
+		x_kern = 0;
+		if (last_cp)
+			fcft_kerning(drwl->font, last_cp, cp, &x_kern, NULL);
+		last_cp = cp;
+
+		ty = y + (h - drwl->font->height) / 2 + drwl->font->ascent;
+
+		if (render && !noellipsis && x_kern + glyph->advance.x + eg->advance.x > w &&
+		    *(p + 1) != '\0') {
+			/* cannot fit ellipsis after current codepoint */
+			if (drwl_text(drwl, 0, 0, 0, 0, 0, pp, 0) + x_kern <= w) {
+				noellipsis = 1;
+			} else {
+				w -= eg->advance.x;
+				pixman_image_composite32(
+					PIXMAN_OP_OVER, fg_pix, eg->pix, drwl->image, 0, 0, 0, 0,
+					x + eg->x, ty - eg->y, eg->width, eg->height);
+			}
+		}
+
+		if ((x_kern + glyph->advance.x) > w)
+			break;
+
+		x += x_kern;
+
+		if (render && pixman_image_get_format(glyph->pix) == PIXMAN_a8r8g8b8)
+			/* pre-rendered glyphs (eg. emoji) */
+			pixman_image_composite32(
+				PIXMAN_OP_OVER, glyph->pix, NULL, drwl->image, 0, 0, 0, 0,
+				x + glyph->x, ty - glyph->y, glyph->width, glyph->height);
+		else if (render)
+			pixman_image_composite32(
+				PIXMAN_OP_OVER, fg_pix, glyph->pix, drwl->image, 0, 0, 0, 0,
+				x + glyph->x, ty - glyph->y, glyph->width, glyph->height);
+
+		x += glyph->advance.x;
+		w -= glyph->advance.x;
+	}
+
+	if (render)
+		pixman_image_unref(fg_pix);
+
+	return x + (render ? w : 0);
+}
+
+static unsigned int
+drwl_font_getwidth(Drwl *drwl, const char *text)
+{
+	if (!drwl || !drwl->font || !text)
+		return 0;
+	return drwl_text(drwl, 0, 0, 0, 0, 0, text, 0);
+}
+
+static void
+drwl_image_destroy(Img *image)
+{
+	pixman_image_unref(image);
+}
+
+static void
+drwl_destroy(Drwl *drwl)
+{
+	if (drwl->font)
+		drwl_font_destroy(drwl->font);
+	if (drwl->image)
+		drwl_image_destroy(drwl->image);
+	free(drwl);
+}
+
+static void
+drwl_fini(void)
+{
+	fcft_fini();
+}
Binary files dwl/dwl and mis_repos/dwl/dwl differ
diff '--color=auto' -urN dwl/dwl.c mis_repos/dwl/dwl.c
--- dwl/dwl.c	2024-08-06 20:03:27.000000000 +0200
+++ mis_repos/dwl/dwl.c	2024-10-01 23:08:38.149644015 +0200
@@ -5,6 +5,7 @@
 #include <libinput.h>
 #include <linux/input-event-codes.h>
 #include <math.h>
+#include <libdrm/drm_fourcc.h>
 #include <signal.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -58,6 +59,7 @@
 #include <wlr/types/wlr_xdg_decoration_v1.h>
 #include <wlr/types/wlr_xdg_output_v1.h>
 #include <wlr/types/wlr_xdg_shell.h>
+#include <wlr/interfaces/wlr_buffer.h>
 #include <wlr/util/log.h>
 #include <wlr/util/region.h>
 #include <xkbcommon/xkbcommon.h>
@@ -68,6 +70,7 @@
 #endif
 
 #include "util.h"
+#include "drwl.h"
 
 /* macros */
 #define MAX(A, B)               ((A) > (B) ? (A) : (B))
@@ -76,14 +79,17 @@
 #define VISIBLEON(C, M)         ((M) && (C)->mon == (M) && ((C)->tags & (M)->tagset[(M)->seltags]))
 #define LENGTH(X)               (sizeof X / sizeof X[0])
 #define END(A)                  ((A) + LENGTH(A))
-#define TAGMASK                 ((1u << TAGCOUNT) - 1)
+#define TAGMASK                 ((1u << LENGTH(tags)) - 1)
 #define LISTEN(E, L, H)         wl_signal_add((E), ((L)->notify = (H), (L)))
 #define LISTEN_STATIC(E, H)     do { static struct wl_listener _l = {.notify = (H)}; wl_signal_add((E), &_l); } while (0)
+#define TEXTW(mon, text)        (drwl_font_getwidth(mon->drw, text) + mon->lrpad)
 
 /* enums */
+enum { SchemeNorm, SchemeSel, SchemeUrg }; /* color schemes */
 enum { CurNormal, CurPressed, CurMove, CurResize }; /* cursor */
 enum { XDGShell, LayerShell, X11 }; /* client types */
 enum { LyrBg, LyrBottom, LyrTile, LyrFloat, LyrTop, LyrFS, LyrOverlay, LyrBlock, NUM_LAYERS }; /* scene layers */
+enum { ClkTagBar, ClkLtSymbol, ClkStatus, ClkTitle, ClkClient, ClkRoot }; /* clicks */
 #ifdef XWAYLAND
 enum { NetWMWindowTypeDialog, NetWMWindowTypeSplash, NetWMWindowTypeToolbar,
 	NetWMWindowTypeUtility, NetLast }; /* EWMH atoms */
@@ -97,12 +103,14 @@
 } Arg;
 
 typedef struct {
+	unsigned int click;
 	unsigned int mod;
 	unsigned int button;
 	void (*func)(const Arg *);
 	const Arg arg;
 } Button;
 
+typedef struct Pertag Pertag;
 typedef struct Monitor Monitor;
 typedef struct {
 	/* Must keep these three elements in this order */
@@ -186,10 +194,19 @@
 	void (*arrange)(Monitor *);
 } Layout;
 
+typedef struct {
+	struct wlr_buffer base;
+	struct wl_listener release;
+	bool busy;
+	Img *image;
+	uint32_t data[];
+} Buffer;
+
 struct Monitor {
 	struct wl_list link;
 	struct wlr_output *wlr_output;
 	struct wlr_scene_output *scene_output;
+	struct wlr_scene_buffer *scene_buffer; /* bar buffer */
 	struct wlr_scene_rect *fullscreen_bg; /* See createmon() for info */
 	struct wl_listener frame;
 	struct wl_listener destroy;
@@ -197,9 +214,16 @@
 	struct wl_listener destroy_lock_surface;
 	struct wlr_session_lock_surface_v1 *lock_surface;
 	struct wlr_box m; /* monitor area, layout-relative */
+	struct {
+		int width, height;
+		int real_width, real_height; /* non-scaled */
+		float scale;
+	} b; /* bar area */
 	struct wlr_box w; /* window area, layout-relative */
 	struct wl_list layers[4]; /* LayerSurface.link */
 	const Layout *lt[2];
+  	Pertag *pertag;
+	int gaps;
 	unsigned int seltags;
 	unsigned int sellt;
 	uint32_t tagset[2];
@@ -208,6 +232,9 @@
 	int nmaster;
 	char ltsymbol[16];
 	int asleep;
+	Drwl *drw;
+	Buffer *pool[2];
+	int lrpad;
 };
 
 typedef struct {
@@ -242,6 +269,11 @@
 	struct wl_listener destroy;
 } SessionLock;
 
+typedef struct {
+	int x;
+	int y;
+} Vector;
+
 /* function declarations */
 static void applybounds(Client *c, struct wlr_box *bbox);
 static void applyrules(Client *c);
@@ -250,6 +282,13 @@
 		struct wlr_box *usable_area, int exclusive);
 static void arrangelayers(Monitor *m);
 static void axisnotify(struct wl_listener *listener, void *data);
+static bool baracceptsinput(struct wlr_scene_buffer *buffer, double *sx, double *sy);
+static void bufdestroy(struct wlr_buffer *buffer);
+static bool bufdatabegin(struct wlr_buffer *buffer, uint32_t flags,
+		void **data, uint32_t *format, size_t *stride);
+static void bufdataend(struct wlr_buffer *buffer);
+static Buffer *bufmon(Monitor *m);
+static void bufrelease(struct wl_listener *listener, void *data);
 static void buttonpress(struct wl_listener *listener, void *data);
 static void chvt(const Arg *arg);
 static void checkidleinhibitor(struct wlr_surface *exclude);
@@ -285,9 +324,13 @@
 static void destroysessionmgr(struct wl_listener *listener, void *data);
 static void destroykeyboardgroup(struct wl_listener *listener, void *data);
 static Monitor *dirtomon(enum wlr_direction dir);
+static void drawbar(Monitor *m);
+static void drawbars(void);
 static void focusclient(Client *c, int lift);
 static void focusmon(const Arg *arg);
 static void focusstack(const Arg *arg);
+static void focusdir(const Arg *arg);
+static void swapdir(const Arg *arg);
 static Client *focustop(Monitor *m);
 static void fullscreennotify(struct wl_listener *listener, void *data);
 static void gpureset(struct wl_listener *listener, void *data);
@@ -295,6 +338,7 @@
 static void incnmaster(const Arg *arg);
 static void inputdevice(struct wl_listener *listener, void *data);
 static int keybinding(uint32_t mods, xkb_keysym_t sym);
+static int lockedkeybinding(uint32_t mods, xkb_keysym_t sym);
 static void keypress(struct wl_listener *listener, void *data);
 static void keypressmod(struct wl_listener *listener, void *data);
 static int keyrepeat(void *data);
@@ -313,7 +357,6 @@
 static void outputmgrtest(struct wl_listener *listener, void *data);
 static void pointerfocus(Client *c, struct wlr_surface *surface,
 		double sx, double sy, uint32_t time);
-static void printstatus(void);
 static void powermgrsetmode(struct wl_listener *listener, void *data);
 static void quit(const Arg *arg);
 static void rendermon(struct wl_listener *listener, void *data);
@@ -335,6 +378,7 @@
 static void setup(void);
 static void spawn(const Arg *arg);
 static void startdrag(struct wl_listener *listener, void *data);
+static int statusin(int fd, unsigned int mask, void *data);
 static void tag(const Arg *arg);
 static void tagmon(const Arg *arg);
 static void tile(Monitor *m);
@@ -346,11 +390,13 @@
 static void unmaplayersurfacenotify(struct wl_listener *listener, void *data);
 static void unmapnotify(struct wl_listener *listener, void *data);
 static void updatemons(struct wl_listener *listener, void *data);
+static void updatebar(Monitor *m);
 static void updatetitle(struct wl_listener *listener, void *data);
 static void urgent(struct wl_listener *listener, void *data);
 static void view(const Arg *arg);
 static void virtualkeyboard(struct wl_listener *listener, void *data);
 static void virtualpointer(struct wl_listener *listener, void *data);
+static void warpcursor(const Client *c);
 static Monitor *xytomon(double x, double y);
 static void xytonode(double x, double y, struct wlr_surface **psurface,
 		Client **pc, LayerSurface **pl, double *nx, double *ny);
@@ -406,13 +452,23 @@
 static KeyboardGroup *kb_group;
 static unsigned int cursor_mode;
 static Client *grabc;
-static int grabcx, grabcy; /* client-relative */
+static Client initial_grabc;
+static int grabcx, grabcy, grabx, graby, grabcenterx, grabcentery; /* client-relative */
 
 static struct wlr_output_layout *output_layout;
 static struct wlr_box sgeom;
 static struct wl_list mons;
 static Monitor *selmon;
 
+static char stext[256];
+static struct wl_event_source *status_event_source;
+
+static const struct wlr_buffer_impl buffer_impl = {
+    .destroy = bufdestroy,
+    .begin_data_ptr_access = bufdatabegin,
+    .end_data_ptr_access = bufdataend,
+};
+
 #ifdef XWAYLAND
 static void activatex11(struct wl_listener *listener, void *data);
 static void associatex11(struct wl_listener *listener, void *data);
@@ -432,6 +488,14 @@
 /* attempt to encapsulate suck into one file */
 #include "client.h"
 
+struct Pertag {
+	unsigned int curtag, prevtag; /* current and previous tag */
+	int nmasters[LENGTH(tags) + 1]; /* number of windows in master area */
+	float mfacts[LENGTH(tags) + 1]; /* mfacts per tag */
+	unsigned int sellts[LENGTH(tags) + 1]; /* selected layouts */
+	const Layout *ltidxs[LENGTH(tags) + 1][2]; /* matrix of tags and layouts indexes  */
+};
+
 /* function implementations */
 void
 applybounds(Client *c, struct wlr_box *bbox)
@@ -478,6 +542,10 @@
 			}
 		}
 	}
+	if (mon) {
+		c->geom.x = (mon->w.width - c->geom.width) / 2 + mon->m.x;
+		c->geom.y = (mon->w.height - c->geom.height) / 2 + mon->m.y;
+	}
 	setmon(c, mon, newtags);
 }
 
@@ -519,6 +587,7 @@
 		m->lt[m->sellt]->arrange(m);
 	motionnotify(0, NULL, 0, 0, 0, 0);
 	checkidleinhibitor(NULL);
+	warpcursor(focustop(selmon));
 }
 
 void
@@ -553,6 +622,11 @@
 	if (!m->wlr_output->enabled)
 		return;
 
+	if (m->scene_buffer->node.enabled) {
+		usable_area.height -= m->b.real_height;
+		usable_area.y += topbar ? m->b.real_height : 0;
+	}
+
 	/* Arrange exclusive surfaces from top->bottom */
 	for (i = 3; i >= 0; i--)
 		arrangelayer(m, &m->layers[i], &usable_area, 1);
@@ -595,17 +669,102 @@
 			event->delta_discrete, event->source, event->relative_direction);
 }
 
+bool
+baracceptsinput(struct wlr_scene_buffer *buffer, double *sx, double *sy)
+{
+	return true;
+}
+
+void
+bufdestroy(struct wlr_buffer *wlr_buffer)
+{
+	Buffer *buf = wl_container_of(wlr_buffer, buf, base);
+	if (buf->busy)
+		wl_list_remove(&buf->release.link);
+	drwl_image_destroy(buf->image);
+	free(buf);
+}
+
+bool
+bufdatabegin(struct wlr_buffer *wlr_buffer, uint32_t flags,
+		void **data, uint32_t *format, size_t *stride)
+{
+	Buffer *buf = wl_container_of(wlr_buffer, buf, base);
+
+	if (flags & WLR_BUFFER_DATA_PTR_ACCESS_WRITE) return false;
+
+	*data   = buf->data;
+	*stride = wlr_buffer->width * 4;
+	*format = DRM_FORMAT_ARGB8888;
+
+	return true;
+}
+
+void
+bufdataend(struct wlr_buffer *wlr_buffer)
+{
+}
+
+Buffer *
+bufmon(Monitor *m)
+{
+	size_t i;
+	Buffer *buf = NULL;
+
+	for (i = 0; i < LENGTH(m->pool); i++) {
+		if (m->pool[i]) {
+			if (m->pool[i]->busy)
+				continue;
+			buf = m->pool[i];
+			break;
+		}
+
+		buf = ecalloc(1, sizeof(Buffer) + (m->b.width * 4 * m->b.height));
+		buf->image = drwl_image_create(NULL, m->b.width, m->b.height, buf->data);
+		wlr_buffer_init(&buf->base, &buffer_impl, m->b.width, m->b.height);
+		m->pool[i] = buf;
+		break;
+	}
+	if (!buf)
+		return NULL;
+
+	buf->busy = true;
+	LISTEN(&buf->base.events.release, &buf->release, bufrelease);
+	wlr_buffer_lock(&buf->base);
+	drwl_setimage(m->drw, buf->image);
+	return buf;
+}
+
+void
+bufrelease(struct wl_listener *listener, void *data)
+{
+	Buffer *buf = wl_container_of(listener, buf, release);
+	buf->busy = false;
+	wl_list_remove(&buf->release.link);
+}
+
 void
 buttonpress(struct wl_listener *listener, void *data)
 {
+	unsigned int i = 0, x = 0;
+	double cx;
+	unsigned int click;
 	struct wlr_pointer_button_event *event = data;
 	struct wlr_keyboard *keyboard;
+	struct wlr_scene_node *node;
+	struct wlr_scene_buffer *buffer;
 	uint32_t mods;
+	Arg arg = {0};
 	Client *c;
 	const Button *b;
 
 	wlr_idle_notifier_v1_notify_activity(idle_notifier, seat);
 
+	click = ClkRoot;
+	xytonode(cursor->x, cursor->y, NULL, &c, NULL, NULL, NULL);
+	if (c)
+		click = ClkClient;
+
 	switch (event->state) {
 	case WL_POINTER_BUTTON_STATE_PRESSED:
 		cursor_mode = CurPressed;
@@ -613,17 +772,34 @@
 		if (locked)
 			break;
 
+		if (!c && !exclusive_focus &&
+			(node = wlr_scene_node_at(&layers[LyrBottom]->node, cursor->x, cursor->y, NULL, NULL)) &&
+			(buffer = wlr_scene_buffer_from_node(node)) && buffer == selmon->scene_buffer) {
+			cx = (cursor->x - selmon->m.x) * selmon->wlr_output->scale;
+			do
+				x += TEXTW(selmon, tags[i]);
+			while (cx >= x && ++i < LENGTH(tags));
+			if (i < LENGTH(tags)) {
+				click = ClkTagBar;
+				arg.ui = 1 << i;
+			} else if (cx < x + TEXTW(selmon, selmon->ltsymbol))
+				click = ClkLtSymbol;
+			else if (cx > selmon->b.width - (TEXTW(selmon, stext) - selmon->lrpad + 2)) {
+				click = ClkStatus;
+			} else
+				click = ClkTitle;
+		}
+
 		/* Change focus if the button was _pressed_ over a client */
 		xytonode(cursor->x, cursor->y, NULL, &c, NULL, NULL, NULL);
-		if (c && (!client_is_unmanaged(c) || client_wants_focus(c)))
+		if (click == ClkClient && (!client_is_unmanaged(c) || client_wants_focus(c)))
 			focusclient(c, 1);
 
 		keyboard = wlr_seat_get_keyboard(seat);
 		mods = keyboard ? wlr_keyboard_get_modifiers(keyboard) : 0;
 		for (b = buttons; b < END(buttons); b++) {
-			if (CLEANMASK(mods) == CLEANMASK(b->mod) &&
-					event->button == b->button && b->func) {
-				b->func(&b->arg);
+			if (CLEANMASK(mods) == CLEANMASK(b->mod) && event->button == b->button && click == b->click && b->func) {
+				b->func(click == ClkTagBar && b->arg.i == 0 ? &arg : &b->arg);
 				return;
 			}
 		}
@@ -697,6 +873,8 @@
 	/* Destroy after the wayland display (when the monitors are already destroyed)
 	   to avoid destroying them with an invalid scene output. */
 	wlr_scene_node_destroy(&scene->tree.node);
+
+	drwl_fini();
 }
 
 void
@@ -712,6 +890,12 @@
 			wlr_layer_surface_v1_destroy(l->layer_surface);
 	}
 
+	for (i = 0; i < LENGTH(m->pool); i++)
+		wlr_buffer_drop(&m->pool[i]->base);
+
+	drwl_setimage(m->drw, NULL);
+	drwl_destroy(m->drw);
+
 	wl_list_remove(&m->destroy.link);
 	wl_list_remove(&m->frame.link);
 	wl_list_remove(&m->link);
@@ -720,8 +904,10 @@
 	wlr_output_layout_remove(output_layout, m->wlr_output);
 	wlr_scene_output_destroy(m->scene_output);
 
+	free(m->pertag);
 	closemon(m);
 	wlr_scene_node_destroy(&m->fullscreen_bg->node);
+	wlr_scene_node_destroy(&m->scene_buffer->node);
 	free(m);
 }
 
@@ -751,7 +937,7 @@
 			setmon(c, selmon, c->tags);
 	}
 	focusclient(focustop(selmon), 1);
-	printstatus();
+	drawbars();
 }
 
 void
@@ -803,8 +989,10 @@
 		 * a wrong monitor.
 		 */
 		applyrules(c);
-		wlr_surface_set_preferred_buffer_scale(client_surface(c), (int)ceilf(c->mon->wlr_output->scale));
-		wlr_fractional_scale_v1_notify_scale(client_surface(c), c->mon->wlr_output->scale);
+		if (c->mon) {
+			wlr_surface_set_preferred_buffer_scale(client_surface(c), (int)ceilf(c->mon->wlr_output->scale));
+			wlr_fractional_scale_v1_notify_scale(client_surface(c), c->mon->wlr_output->scale);
+		}
 		setmon(c, NULL, 0); /* Make sure to reapply rules in mapnotify() */
 
 		wlr_xdg_toplevel_set_wm_capabilities(c->surface.xdg->toplevel, WLR_XDG_TOPLEVEL_WM_CAPABILITIES_FULLSCREEN);
@@ -991,6 +1179,8 @@
 
 	wlr_output_state_init(&state);
 	/* Initialize monitor state using configured rules */
+	m->gaps = gaps;
+
 	m->tagset[0] = m->tagset[1] = 1;
 	for (r = monrules; r < END(monrules); r++) {
 		if (!r->name || strstr(wlr_output->name, r->name)) {
@@ -1022,8 +1212,27 @@
 	wlr_output_commit_state(wlr_output, &state);
 	wlr_output_state_finish(&state);
 
+	if (!(m->drw = drwl_create()))
+		die("failed to create drwl context");
+
+	m->scene_buffer = wlr_scene_buffer_create(layers[LyrBottom], NULL);
+	m->scene_buffer->point_accepts_input = baracceptsinput;
+	updatebar(m);
+
 	wl_list_insert(&mons, &m->link);
-	printstatus();
+	drawbars();
+
+	m->pertag = calloc(1, sizeof(Pertag));
+	m->pertag->curtag = m->pertag->prevtag = 1;
+
+	for (i = 0; i <= LENGTH(tags); i++) {
+		m->pertag->nmasters[i] = m->nmaster;
+		m->pertag->mfacts[i] = m->mfact;
+
+		m->pertag->ltidxs[i][0] = m->lt[0];
+		m->pertag->ltidxs[i][1] = m->lt[1];
+		m->pertag->sellts[i] = m->sellt;
+	}
 
 	/* The xdg-protocol specifies:
 	 *
@@ -1337,6 +1546,80 @@
 }
 
 void
+drawbar(Monitor *m)
+{
+	int x, w, tw = 0;
+	int boxs = m->drw->font->height / 9;
+	int boxw = m->drw->font->height / 6 + 2;
+	uint32_t i, occ = 0, urg = 0;
+	Client *c;
+	Buffer *buf;
+
+	if (!m->scene_buffer->node.enabled)
+		return;
+	if (!(buf = bufmon(m)))
+		return;
+
+	/* draw status first so it can be overdrawn by tags later */
+	if (m == selmon) { /* status is only drawn on selected monitor */
+		drwl_setscheme(m->drw, colors[SchemeSel]);
+		tw = TEXTW(m, stext) - m->lrpad + 2; /* 2px right padding */
+		drwl_text(m->drw, m->b.width - tw, 0, tw, m->b.height, 0, stext, 0);
+	}
+
+	wl_list_for_each(c, &clients, link) {
+		if (c->mon != m)
+			continue;
+		occ |= c->tags;
+		if (c->isurgent)
+			urg |= c->tags;
+	}
+	x = 0;
+	c = focustop(m);
+	for (i = 0; i < LENGTH(tags); i++) {
+		w = TEXTW(m, tags[i]);
+		drwl_setscheme(m->drw, colors[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
+		drwl_text(m->drw, x, 0, w, m->b.height, m->lrpad / 2, tags[i], urg & 1 << i);
+		if (occ & 1 << i)
+			drwl_rect(m->drw, x + boxs, boxs, boxw, boxw,
+				m == selmon && c && c->tags & 1 << i,
+				urg & 1 << i);
+		x += w;
+	}
+	w = TEXTW(m, m->ltsymbol);
+	drwl_setscheme(m->drw, colors[SchemeNorm]);
+	x = drwl_text(m->drw, x, 0, w, m->b.height, m->lrpad / 2, m->ltsymbol, 0);
+
+	if ((w = m->b.width - tw - x) > m->b.height) {
+		if (c && m == selmon) {
+			drwl_setscheme(m->drw, colors[SchemeNorm]);
+			drwl_text(m->drw, x, 0, w, m->b.height, m->lrpad / 2, client_get_title(c), 0);
+			if (c && c->isfloating)
+				drwl_rect(m->drw, x + boxs, boxs, boxw, boxw, 0, 0);
+		} else {
+			drwl_setscheme(m->drw, colors[SchemeNorm]);
+			drwl_rect(m->drw, x, 0, w, m->b.height, 1, 1);
+		}
+	}
+
+	wlr_scene_buffer_set_dest_size(m->scene_buffer,
+		m->b.real_width, m->b.real_height);
+	wlr_scene_node_set_position(&m->scene_buffer->node, m->m.x,
+		m->m.y + (topbar ? 0 : m->m.height - m->b.real_height));
+	wlr_scene_buffer_set_buffer(m->scene_buffer, &buf->base);
+	wlr_buffer_unlock(&buf->base);
+}
+
+void
+drawbars(void)
+{
+	Monitor *m = NULL;
+
+	wl_list_for_each(m, &mons, link)
+		drawbar(m);
+}
+
+void
 focusclient(Client *c, int lift)
 {
 	struct wlr_surface *old = seat->keyboard_state.focused_surface;
@@ -1347,6 +1630,10 @@
 	if (locked)
 		return;
 
+	/* Warp cursor to center of client if it is outside */
+	if (lift)
+		warpcursor(c);
+
 	/* Raise client in stacking order if requested */
 	if (c && lift)
 		wlr_scene_node_raise_to_top(&c->scene->node);
@@ -1371,13 +1658,13 @@
 		/* Don't change border color if there is an exclusive focus or we are
 		 * handling a drag operation */
 		if (!exclusive_focus && !seat->drag)
-			client_set_border_color(c, focuscolor);
+			client_set_border_color(c, (float[])COLOR(colors[SchemeSel][ColBorder]));
 	}
 
 	/* Deactivate old client if focus is changing */
 	if (old && (!c || client_surface(c) != old)) {
 		/* If an overlay is focused, don't focus or activate the client,
-		 * but only update its position in fstack to render its border with focuscolor
+		 * but only update its position in fstack to render its border with its color
 		 * and focus it after the overlay is closed. */
 		if (old_client_type == LayerShell && wlr_scene_node_coords(
 					&old_l->scene->node, &unused_lx, &unused_ly)
@@ -1388,12 +1675,11 @@
 		/* Don't deactivate old client if the new one wants focus, as this causes issues with winecfg
 		 * and probably other clients */
 		} else if (old_c && !client_is_unmanaged(old_c) && (!c || !client_wants_focus(c))) {
-			client_set_border_color(old_c, bordercolor);
-
+			client_set_border_color(old_c, (float[])COLOR(colors[SchemeNorm][ColBorder]));
 			client_activate_surface(old, 0);
 		}
 	}
-	printstatus();
+	drawbars();
 
 	if (!c) {
 		/* With no client, all we have left is to clear focus */
@@ -1449,6 +1735,163 @@
 	focusclient(c, 1);
 }
 
+Vector
+position_of_box(const struct wlr_box *box)
+{
+	return (Vector){
+		.x = box->x + box->width / 2,
+		.y = box->y + box->height / 2,
+	};
+}
+
+Vector
+diff_of_vectors(Vector *a, Vector *b)
+{
+	return (Vector){
+		.x = b->x - a->x,
+		.y = b->y - a->y,
+	};
+}
+
+const char *
+direction_of_vector(Vector *vector)
+{
+	// A zero length vector has no direction
+	if (vector->x == 0 && vector->y == 0) return "";
+
+	if (abs(vector->y) > abs(vector->x)) {
+		// Careful: We are operating in a Y-inverted coordinate system.
+		return (vector->y > 0) ? "bottom" : "top";
+	} else {
+		return (vector->x > 0) ? "right" : "left";
+	}
+}
+
+uint32_t
+vector_length(Vector *vector)
+{
+	// Euclidean distance formula
+	return (uint32_t)sqrt(vector->x * vector->x + vector->y * vector->y);
+}
+
+// Spatial direction, based on focused client position.
+Client *
+client_in_direction(const char *direction, const int *skipfloat)
+{
+	Client *cfocused = focustop(selmon);
+	Vector cfocusedposition;
+	Client *ctarget = NULL;
+	double targetdistance = INFINITY;
+	Client *c;
+
+	if (!cfocused || cfocused->isfullscreen || (skipfloat && cfocused->isfloating))
+		return NULL;
+
+	cfocusedposition = position_of_box(&cfocused->geom);
+
+	wl_list_for_each(c, &clients, link) {
+		Vector cposition;
+		Vector positiondiff;
+		uint32_t distance;
+
+		if (c == cfocused)
+			continue;
+
+		if (skipfloat && c->isfloating)
+			continue;
+
+		if (!VISIBLEON(c, selmon))
+			continue;
+
+		cposition = position_of_box(&c->geom);
+		positiondiff = diff_of_vectors(&cfocusedposition, &cposition);
+
+		if (strcmp(direction, direction_of_vector(&positiondiff)) != 0)
+			continue;
+
+		distance = vector_length(&positiondiff);
+
+		 if (distance < targetdistance) {
+			ctarget = c;
+			targetdistance = distance;
+		}
+	}
+
+	return ctarget;
+}
+
+void
+focusdir(const Arg *arg)
+{
+	Client *c = NULL;
+
+	if (arg->ui == 0)
+		c = client_in_direction("left", (int *)0);
+	if (arg->ui == 1)
+		c = client_in_direction("right", (int *)0);
+	if (arg->ui == 2)
+		c = client_in_direction("top", (int *)0);
+	if (arg->ui == 3)
+		c = client_in_direction("bottom", (int *)0);
+
+	if (c != NULL)
+		focusclient(c, 1);
+}
+
+void
+wl_list_swap(struct wl_list *list1, struct wl_list *list2)
+{
+	struct wl_list *prev1, *next1, *prev2, *next2;
+	struct wl_list temp;
+
+	if (list1 == list2) {
+		// No need to swap the same list
+		return;
+	}
+
+	// Get the lists before and after list1
+	prev1 = list1->prev;
+	next1 = list1->next;
+
+	// Get the lists before and after list2
+	prev2 = list2->prev;
+	next2 = list2->next;
+
+	// Update the next and previous pointers of adjacent lists
+	prev1->next = list2;
+	next1->prev = list2;
+	prev2->next = list1;
+	next2->prev = list1;
+
+	// Swap the next and previous pointers of the lists to actually swap them
+	temp = *list1;
+	*list1 = *list2;
+	*list2 = temp;
+}
+
+void
+swapdir(const Arg *arg)
+{
+	Client *c = NULL;
+	Client *cfocused;
+
+	if (arg->ui == 0)
+		c = client_in_direction("left", (int *)1);
+	if (arg->ui == 1)
+		c = client_in_direction("right", (int *)1);
+	if (arg->ui == 2)
+		c = client_in_direction("top", (int *)1);
+	if (arg->ui == 3)
+		c = client_in_direction("bottom", (int *)1);
+
+	if (c == NULL)
+		return;
+
+	cfocused = focustop(selmon);
+	wl_list_swap(&cfocused->link, &c->link);
+	arrange(selmon);
+}
+
 /* We probably should change the name of this, it sounds like
  * will focus the topmost client of this mon, when actually will
  * only return that client */
@@ -1520,7 +1963,7 @@
 {
 	if (!arg || !selmon)
 		return;
-	selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
+	selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag] = MAX(selmon->nmaster + arg->i, 0);
 	arrange(selmon);
 }
 
@@ -1573,6 +2016,21 @@
 	return 0;
 }
 
+int
+lockedkeybinding(uint32_t mods, xkb_keysym_t sym)
+{
+	int handled = 0;
+	const Key *k;
+	for (k = lockedkeys; k < END(lockedkeys); k++) {
+		if (CLEANMASK(mods) == CLEANMASK(k->mod) &&
+				sym == k->keysym && k->func) {
+			k->func(&k->arg);
+			handled = 1;
+		}
+	}
+	return handled;
+}
+
 void
 keypress(struct wl_listener *listener, void *data)
 {
@@ -1600,6 +2058,10 @@
 			handled = keybinding(mods, syms[i]) || handled;
 	}
 
+	if (locked && event->state == WL_KEYBOARD_KEY_STATE_PRESSED)
+		for (i = 0; i < nsyms; i++)
+			handled = lockedkeybinding(mods, syms[i]) || handled;
+
 	if (handled && group->wlr_group->keyboard.repeat_info.delay > 0) {
 		group->mods = mods;
 		group->keysyms = syms;
@@ -1715,7 +2177,7 @@
 
 	for (i = 0; i < 4; i++) {
 		c->border[i] = wlr_scene_rect_create(c->scene, 0, 0,
-				c->isurgent ? urgentcolor : bordercolor);
+			(float[])COLOR(colors[c->isurgent ? SchemeUrg : SchemeNorm][ColBorder]));
 		c->border[i]->node.data = c;
 	}
 
@@ -1734,11 +2196,15 @@
 	 * try to apply rules for them */
 	if ((p = client_get_parent(c))) {
 		c->isfloating = 1;
+		if (p->mon) {
+			c->geom.x = (p->mon->w.width - c->geom.width) / 2 + p->mon->m.x;
+			c->geom.y = (p->mon->w.height - c->geom.height) / 2 + p->mon->m.y;
+		}
 		setmon(c, p->mon, p->tags);
 	} else {
 		applyrules(c);
 	}
-	printstatus();
+	drawbars();
 
 unset_fullscreen:
 	m = c->mon ? c->mon : xytomon(c->geom.x, c->geom.y);
@@ -1870,8 +2336,27 @@
 			.width = grabc->geom.width, .height = grabc->geom.height}, 1);
 		return;
 	} else if (cursor_mode == CurResize) {
-		resize(grabc, (struct wlr_box){.x = grabc->geom.x, .y = grabc->geom.y,
-			.width = (int)round(cursor->x) - grabc->geom.x, .height = (int)round(cursor->y) - grabc->geom.y}, 1);
+		if (grabcenterx < grabx) {
+			if (grabcentery < graby) {
+				/* bottom-right */
+				resize(grabc, (struct wlr_box){.x = initial_grabc.geom.x, .y = initial_grabc.geom.y,
+					.width = (int)round(cursor->x) - initial_grabc.geom.x, .height = (int)round(cursor->y) - initial_grabc.geom.y}, 1);
+			} else {
+				/* top-right */
+				resize(grabc, (struct wlr_box){.x = initial_grabc.geom.x, .y = (int)round(cursor->y),
+					.width = (int)round(cursor->x) - initial_grabc.geom.x, .height = initial_grabc.geom.y + initial_grabc.geom.height - (int)round(cursor->y)}, 1);
+			}
+		} else {
+			if (grabcentery < graby) {
+				/* bottom-left */
+				resize(grabc, (struct wlr_box){.x = (int)round(cursor->x), .y = initial_grabc.geom.y,
+					.width = initial_grabc.geom.x + initial_grabc.geom.width - (int)round(cursor->x), .height = (int)round(cursor->y) - initial_grabc.geom.y}, 1);
+			} else {
+				/* top-left */
+				resize(grabc, (struct wlr_box){.x = (int)round(cursor->x), .y = (int)round(cursor->y),
+					.width = initial_grabc.geom.x + initial_grabc.geom.width - (int)round(cursor->x), .height = initial_grabc.geom.y + initial_grabc.geom.height - (int)round(cursor->y)}, 1);
+			}
+		}
 		return;
 	}
 
@@ -1919,10 +2404,42 @@
 	case CurResize:
 		/* Doesn't work for X11 output - the next absolute motion event
 		 * returns the cursor to where it started */
-		wlr_cursor_warp_closest(cursor, NULL,
-				grabc->geom.x + grabc->geom.width,
-				grabc->geom.y + grabc->geom.height);
-		wlr_cursor_set_xcursor(cursor, cursor_mgr, "se-resize");
+		initial_grabc = *grabc;
+		grabx = (int)round(cursor->x);
+		graby = (int)round(cursor->y);
+		grabcx = (int)round(cursor->x) - grabc->geom.x;
+		grabcy = (int)round(cursor->y) - grabc->geom.y;
+		grabcenterx = grabc->geom.width / 2 + grabc->geom.x;
+		grabcentery = grabc->geom.height / 2 + grabc->geom.y;
+		if (grabcenterx < grabx) {
+			if (grabcentery < graby) {
+				/* bottom-right */
+				wlr_cursor_warp_closest(cursor, NULL,
+					grabc->geom.x + grabc->geom.width,
+					grabc->geom.y + grabc->geom.height);
+				wlr_cursor_set_xcursor(cursor, cursor_mgr, "se-resize");
+			} else {
+				/* top-right */
+				wlr_cursor_warp_closest(cursor, NULL,
+					grabc->geom.x + grabc->geom.width,
+					grabc->geom.y);
+				wlr_cursor_set_xcursor(cursor, cursor_mgr, "ne-resize");
+			}
+		} else {
+			if (grabcentery < graby) {
+				/* bottom-left */
+				wlr_cursor_warp_closest(cursor, NULL,
+					grabc->geom.x,
+					grabc->geom.y + grabc->geom.height);
+				wlr_cursor_set_xcursor(cursor, cursor_mgr, "sw-resize");
+			} else {
+				/* top-left */
+				wlr_cursor_warp_closest(cursor, NULL,
+					grabc->geom.x,
+					grabc->geom.y);
+				wlr_cursor_set_xcursor(cursor, cursor_mgr, "nw-resize");
+			}
+		}
 		break;
 	}
 }
@@ -2032,46 +2549,6 @@
 	wlr_seat_pointer_notify_motion(seat, time, sx, sy);
 }
 
-void
-printstatus(void)
-{
-	Monitor *m = NULL;
-	Client *c;
-	uint32_t occ, urg, sel;
-	const char *appid, *title;
-
-	wl_list_for_each(m, &mons, link) {
-		occ = urg = 0;
-		wl_list_for_each(c, &clients, link) {
-			if (c->mon != m)
-				continue;
-			occ |= c->tags;
-			if (c->isurgent)
-				urg |= c->tags;
-		}
-		if ((c = focustop(m))) {
-			title = client_get_title(c);
-			appid = client_get_appid(c);
-			printf("%s title %s\n", m->wlr_output->name, title ? title : broken);
-			printf("%s appid %s\n", m->wlr_output->name, appid ? appid : broken);
-			printf("%s fullscreen %d\n", m->wlr_output->name, c->isfullscreen);
-			printf("%s floating %d\n", m->wlr_output->name, c->isfloating);
-			sel = c->tags;
-		} else {
-			printf("%s title \n", m->wlr_output->name);
-			printf("%s appid \n", m->wlr_output->name);
-			printf("%s fullscreen \n", m->wlr_output->name);
-			printf("%s floating \n", m->wlr_output->name);
-			sel = 0;
-		}
-
-		printf("%s selmon %u\n", m->wlr_output->name, m == selmon);
-		printf("%s tags %"PRIu32" %"PRIu32" %"PRIu32" %"PRIu32"\n",
-			m->wlr_output->name, occ, m->tagset[m->seltags], sel, urg);
-		printf("%s layout %s\n", m->wlr_output->name, m->ltsymbol);
-	}
-	fflush(stdout);
-}
 
 void
 powermgrsetmode(struct wl_listener *listener, void *data)
@@ -2226,30 +2703,17 @@
 
 	/* Now that the socket exists and the backend is started, run the startup command */
 	if (startup_cmd) {
-		int piperw[2];
-		if (pipe(piperw) < 0)
-			die("startup: pipe:");
 		if ((child_pid = fork()) < 0)
 			die("startup: fork:");
 		if (child_pid == 0) {
+			close(STDIN_FILENO);
 			setsid();
-			dup2(piperw[0], STDIN_FILENO);
-			close(piperw[0]);
-			close(piperw[1]);
 			execl("/bin/sh", "/bin/sh", "-c", startup_cmd, NULL);
 			die("startup: execl:");
 		}
-		dup2(piperw[1], STDOUT_FILENO);
-		close(piperw[1]);
-		close(piperw[0]);
 	}
 
-	/* Mark stdout as non-blocking to avoid people who does not close stdin
-	 * nor consumes it in their startup script getting dwl frozen */
-	if (fd_set_nonblock(STDOUT_FILENO) < 0)
-		close(STDOUT_FILENO);
-
-	printstatus();
+	drawbars();
 
 	/* At this point the outputs are initialized, choose initial selmon based on
 	 * cursor position, and set default cursor image */
@@ -2315,7 +2779,7 @@
 			(p && p->isfullscreen) ? LyrFS
 			: c->isfloating ? LyrFloat : LyrTile]);
 	arrange(c->mon);
-	printstatus();
+	drawbars();
 }
 
 void
@@ -2338,7 +2802,7 @@
 		resize(c, c->prev, 0);
 	}
 	arrange(c->mon);
-	printstatus();
+	drawbars();
 }
 
 void
@@ -2358,12 +2822,12 @@
 	if (!selmon)
 		return;
 	if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
-		selmon->sellt ^= 1;
+		selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag] ^= 1;
 	if (arg && arg->v)
-		selmon->lt[selmon->sellt] = (Layout *)arg->v;
+		selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt] = (Layout *)arg->v;
 	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, LENGTH(selmon->ltsymbol));
 	arrange(selmon);
-	printstatus();
+	drawbar(selmon);
 }
 
 /* arg > 1.0 will set mfact absolutely */
@@ -2377,7 +2841,7 @@
 	f = arg->f < 1.0f ? arg->f + selmon->mfact : arg->f - 1.0f;
 	if (f < 0.1 || f > 0.9)
 		return;
-	selmon->mfact = f;
+	selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag] = f;
 	arrange(selmon);
 }
 
@@ -2436,6 +2900,7 @@
 	for (i = 0; i < (int)LENGTH(sig); i++)
 		sigaction(sig[i], &sa, NULL);
 
+
 	wlr_log_init(log_level, NULL);
 
 	/* The Wayland display is managed by libwayland. It handles accepting
@@ -2625,6 +3090,11 @@
 	LISTEN_STATIC(&output_mgr->events.apply, outputmgrapply);
 	LISTEN_STATIC(&output_mgr->events.test, outputmgrtest);
 
+	drwl_init();
+
+	status_event_source = wl_event_loop_add_fd(wl_display_get_event_loop(dpy),
+		STDIN_FILENO, WL_EVENT_READABLE, statusin, NULL);
+
 	/* Make sure XWayland clients don't connect to the parent X server,
 	 * e.g when running in the x11 backend or the wayland backend and the
 	 * compositor has Xwayland support */
@@ -2649,6 +3119,7 @@
 spawn(const Arg *arg)
 {
 	if (fork() == 0) {
+		close(STDIN_FILENO);
 		dup2(STDERR_FILENO, STDOUT_FILENO);
 		setsid();
 		execvp(((char **)arg->v)[0], (char **)arg->v);
@@ -2667,6 +3138,30 @@
 	LISTEN_STATIC(&drag->icon->events.destroy, destroydragicon);
 }
 
+int
+statusin(int fd, unsigned int mask, void *data)
+{
+	char status[1024];
+	ssize_t n;
+
+	if (mask & WL_EVENT_ERROR)
+		die("status in event error");
+	if (mask & WL_EVENT_HANGUP)
+		wl_event_source_remove(status_event_source);
+
+	n = read(fd, status, sizeof(status) - 1);
+	if (n < 0 && errno != EWOULDBLOCK)
+		die("read:");
+
+	status[n] = '\0';
+	status[strcspn(status, "\n")] = '\0';
+
+	strncpy(stext, status, sizeof(stext));
+	drawbars();
+
+	return 0;
+}
+
 void
 tag(const Arg *arg)
 {
@@ -2677,7 +3172,7 @@
 	sel->tags = arg->ui & TAGMASK;
 	focusclient(focustop(selmon), 1);
 	arrange(selmon);
-	printstatus();
+	drawbars();
 }
 
 void
@@ -2691,7 +3186,7 @@
 void
 tile(Monitor *m)
 {
-	unsigned int mw, my, ty;
+	unsigned int h, r, e = m->gaps, mw, my, ty;
 	int i, n = 0;
 	Client *c;
 
@@ -2700,23 +3195,30 @@
 			n++;
 	if (n == 0)
 		return;
+	if (smartgaps == n)
+		e = 0;
 
 	if (n > m->nmaster)
-		mw = m->nmaster ? (int)roundf(m->w.width * m->mfact) : 0;
+		mw = m->nmaster ? (int)roundf((m->w.width + gappx*e) * m->mfact) : 0;
 	else
 		mw = m->w.width;
-	i = my = ty = 0;
+	i = 0;
+	my = ty = gappx*e;
 	wl_list_for_each(c, &clients, link) {
 		if (!VISIBLEON(c, m) || c->isfloating || c->isfullscreen)
 			continue;
 		if (i < m->nmaster) {
-			resize(c, (struct wlr_box){.x = m->w.x, .y = m->w.y + my, .width = mw,
-				.height = (m->w.height - my) / (MIN(n, m->nmaster) - i)}, 0);
-			my += c->geom.height;
+			r = MIN(n, m->nmaster) - i;
+			h = (m->w.height - my - gappx*e - gappx*e * (r - 1)) / r;
+			resize(c, (struct wlr_box){.x = m->w.x + gappx*e, .y = m->w.y + my,
+				.width = mw - 2*gappx*e, .height = h}, 0);
+			my += c->geom.height + gappx*e;
 		} else {
+			r = n - i;
+			h = (m->w.height - ty - gappx*e - gappx*e * (r - 1)) / r;
 			resize(c, (struct wlr_box){.x = m->w.x + mw, .y = m->w.y + ty,
-				.width = m->w.width - mw, .height = (m->w.height - ty) / (n - i)}, 0);
-			ty += c->geom.height;
+				.width = m->w.width - mw - gappx*e, .height = h}, 0);
+			ty += c->geom.height + gappx*e;
 		}
 		i++;
 	}
@@ -2750,20 +3252,40 @@
 	sel->tags = newtags;
 	focusclient(focustop(selmon), 1);
 	arrange(selmon);
-	printstatus();
+	drawbars();
 }
 
 void
 toggleview(const Arg *arg)
 {
 	uint32_t newtagset;
+	size_t i;
 	if (!(newtagset = selmon ? selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK) : 0))
 		return;
 
+	if (newtagset == (uint32_t)~0) {
+		selmon->pertag->prevtag = selmon->pertag->curtag;
+		selmon->pertag->curtag = 0;
+	}
+
+	/* test if the user did not select the same tag */
+	if (!(newtagset & 1 << (selmon->pertag->curtag - 1))) {
+		selmon->pertag->prevtag = selmon->pertag->curtag;
+		for (i = 0; !(newtagset & 1 << i); i++) ;
+		selmon->pertag->curtag = i + 1;
+	}
+
+	/* apply settings for this view */
+	selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
+	selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
+	selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
+	selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
+	selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
+
 	selmon->tagset[selmon->seltags] = newtagset;
 	focusclient(focustop(selmon), 1);
 	arrange(selmon);
-	printstatus();
+	drawbars();
 }
 
 void
@@ -2811,7 +3333,7 @@
 	}
 
 	wlr_scene_node_destroy(&c->scene->node);
-	printstatus();
+	drawbars();
 	motionnotify(0, NULL, 0, 0, 0, 0);
 }
 
@@ -2911,22 +3433,57 @@
 		}
 	}
 
-	/* FIXME: figure out why the cursor image is at 0,0 after turning all
-	 * the monitors on.
-	 * Move the cursor image where it used to be. It does not generate a
-	 * wl_pointer.motion event for the clients, it's only the image what it's
-	 * at the wrong position after all. */
+	if (stext[0] == '\0')
+		strncpy(stext, "dwl-"VERSION, sizeof(stext));
+	wl_list_for_each(m, &mons, link) {
+		updatebar(m);
+		drawbar(m);
+	}
+
 	wlr_cursor_move(cursor, NULL, 0, 0);
 
 	wlr_output_manager_v1_set_configuration(output_mgr, config);
 }
 
 void
+updatebar(Monitor *m)
+{
+	size_t i;
+	int rw, rh;
+	char fontattrs[12];
+
+	wlr_output_transformed_resolution(m->wlr_output, &rw, &rh);
+	m->b.width = rw;
+	m->b.real_width = (int)((float)m->b.width / m->wlr_output->scale);
+
+	wlr_scene_node_set_enabled(&m->scene_buffer->node, m->wlr_output->enabled ? showbar : 0);
+
+	for (i = 0; i < LENGTH(m->pool); i++)
+		if (m->pool[i]) {
+			wlr_buffer_drop(&m->pool[i]->base);
+			m->pool[i] = NULL;
+		}
+
+	if (m->b.scale == m->wlr_output->scale && m->drw)
+		return;
+
+	drwl_font_destroy(m->drw->font);
+	snprintf(fontattrs, sizeof(fontattrs), "dpi=%.2f", 96. * m->wlr_output->scale);
+	if (!(drwl_font_create(m->drw, LENGTH(fonts), fonts, fontattrs)))
+		die("Could not load font");
+
+	m->b.scale = m->wlr_output->scale;
+	m->lrpad = m->drw->font->height;
+	m->b.height = user_bh ? user_bh :  m->drw->font->height + 2;
+	m->b.real_height = (int)((float)m->b.height / m->wlr_output->scale);
+}
+
+void
 updatetitle(struct wl_listener *listener, void *data)
 {
 	Client *c = wl_container_of(listener, c, set_title);
 	if (c == focustop(c->mon))
-		printstatus();
+		drawbars();
 }
 
 void
@@ -2939,23 +3496,45 @@
 		return;
 
 	c->isurgent = 1;
-	printstatus();
+	drawbars();
 
 	if (client_surface(c)->mapped)
-		client_set_border_color(c, urgentcolor);
+		client_set_border_color(c, (float[])COLOR(colors[SchemeUrg][ColBorder]));
 }
 
 void
 view(const Arg *arg)
 {
+	size_t i, tmptag;
+
 	if (!selmon || (arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
 		return;
 	selmon->seltags ^= 1; /* toggle sel tagset */
-	if (arg->ui & TAGMASK)
+	if (arg->ui & ~0) {
 		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
+		selmon->pertag->prevtag = selmon->pertag->curtag;
+
+		if (arg->ui == TAGMASK)
+			selmon->pertag->curtag = 0;
+		else {
+			for (i = 0; !(arg->ui & 1 << i); i++) ;
+			selmon->pertag->curtag = i + 1;
+		}
+	} else {
+		tmptag = selmon->pertag->prevtag;
+		selmon->pertag->prevtag = selmon->pertag->curtag;
+		selmon->pertag->curtag = tmptag;
+	}
+
+	selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
+	selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
+	selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
+	selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
+	selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
+
 	focusclient(focustop(selmon), 1);
 	arrange(selmon);
-	printstatus();
+	drawbars();
 }
 
 void
@@ -2983,6 +3562,27 @@
 		wlr_cursor_map_input_to_output(cursor, device, event->suggested_output);
 }
 
+void
+warpcursor(const Client *c) {
+	if (cursor_mode != CurNormal) {
+		return;
+	}
+	if (!c && selmon) {
+		wlr_cursor_warp_closest(cursor,
+			  NULL,
+			  selmon->w.x + selmon->w.width / 2.0 ,
+			  selmon->w.y + selmon->w.height / 2.0);
+	}
+	else if ( c && (cursor->x < c->geom.x ||
+		cursor->x > c->geom.x + c->geom.width ||
+		cursor->y < c->geom.y ||
+		cursor->y > c->geom.y + c->geom.height))
+		wlr_cursor_warp_closest(cursor,
+			  NULL,
+			  c->geom.x + c->geom.width / 2.0,
+			  c->geom.y + c->geom.height / 2.0);
+}
+
 Monitor *
 xytomon(double x, double y)
 {
@@ -2996,6 +3596,7 @@
 {
 	struct wlr_scene_node *node, *pnode;
 	struct wlr_surface *surface = NULL;
+	struct wlr_scene_surface *scene_surface = NULL;
 	Client *c = NULL;
 	LayerSurface *l = NULL;
 	int layer;
@@ -3004,9 +3605,12 @@
 		if (!(node = wlr_scene_node_at(&layers[layer]->node, x, y, nx, ny)))
 			continue;
 
-		if (node->type == WLR_SCENE_NODE_BUFFER)
-			surface = wlr_scene_surface_try_from_buffer(
-					wlr_scene_buffer_from_node(node))->surface;
+		if (node->type == WLR_SCENE_NODE_BUFFER) {
+			scene_surface = wlr_scene_surface_try_from_buffer(
+					wlr_scene_buffer_from_node(node));
+			if (!scene_surface) continue;
+			surface = scene_surface->surface;
+		}
 		/* Walk the tree to find a node that knows the client */
 		for (pnode = node; pnode && !c; pnode = &pnode->parent->node)
 			c = pnode->data;
@@ -3145,10 +3749,10 @@
 		return;
 
 	c->isurgent = xcb_icccm_wm_hints_get_urgency(c->surface.xwayland->hints);
-	printstatus();
+	drawbars();
 
 	if (c->isurgent && surface && surface->mapped)
-		client_set_border_color(c, urgentcolor);
+		client_set_border_color(c, (float[])COLOR(colors[SchemeUrg][ColBorder]));
 }
 
 void
Binary files dwl/dwl.o and mis_repos/dwl/dwl.o differ
diff '--color=auto' -urN dwl/.git/COMMIT_EDITMSG mis_repos/dwl/.git/COMMIT_EDITMSG
--- dwl/.git/COMMIT_EDITMSG	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/.git/COMMIT_EDITMSG	2024-10-01 23:12:25.819241960 +0200
@@ -0,0 +1 @@
+added .diff file
diff '--color=auto' -urN dwl/.git/config mis_repos/dwl/.git/config
--- dwl/.git/config	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/.git/config	2024-10-01 23:08:38.136310900 +0200
@@ -0,0 +1,11 @@
+[core]
+	repositoryformatversion = 0
+	filemode = true
+	bare = false
+	logallrefupdates = true
+[remote "origin"]
+	url = https://github.com/dcalonge/dwl.git
+	fetch = +refs/heads/*:refs/remotes/origin/*
+[branch "main"]
+	remote = origin
+	merge = refs/heads/main
diff '--color=auto' -urN dwl/.git/description mis_repos/dwl/.git/description
--- dwl/.git/description	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/.git/description	2024-10-01 23:08:33.983045710 +0200
@@ -0,0 +1 @@
+Unnamed repository; edit this file 'description' to name the repository.
diff '--color=auto' -urN dwl/.git/HEAD mis_repos/dwl/.git/HEAD
--- dwl/.git/HEAD	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/.git/HEAD	2024-10-01 23:08:38.136310900 +0200
@@ -0,0 +1 @@
+ref: refs/heads/main
diff '--color=auto' -urN dwl/.git/hooks/applypatch-msg.sample mis_repos/dwl/.git/hooks/applypatch-msg.sample
--- dwl/.git/hooks/applypatch-msg.sample	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/.git/hooks/applypatch-msg.sample	2024-10-01 23:08:33.976379152 +0200
@@ -0,0 +1,15 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message taken by
+# applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.  The hook is
+# allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "applypatch-msg".
+
+. git-sh-setup
+commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
+test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
+:
diff '--color=auto' -urN dwl/.git/hooks/commit-msg.sample mis_repos/dwl/.git/hooks/commit-msg.sample
--- dwl/.git/hooks/commit-msg.sample	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/.git/hooks/commit-msg.sample	2024-10-01 23:08:33.976379152 +0200
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message.
+# Called by "git commit" with one argument, the name of the file
+# that has the commit message.  The hook should exit with non-zero
+# status after issuing an appropriate message if it wants to stop the
+# commit.  The hook is allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "commit-msg".
+
+# Uncomment the below to add a Signed-off-by line to the message.
+# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
+# hook is more suited to it.
+#
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
+
+# This example catches duplicate Signed-off-by lines.
+
+test "" = "$(grep '^Signed-off-by: ' "$1" |
+	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
+	echo >&2 Duplicate Signed-off-by lines.
+	exit 1
+}
diff '--color=auto' -urN dwl/.git/hooks/fsmonitor-watchman.sample mis_repos/dwl/.git/hooks/fsmonitor-watchman.sample
--- dwl/.git/hooks/fsmonitor-watchman.sample	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/.git/hooks/fsmonitor-watchman.sample	2024-10-01 23:08:33.976379152 +0200
@@ -0,0 +1,174 @@
+#!/usr/bin/perl
+
+use strict;
+use warnings;
+use IPC::Open2;
+
+# An example hook script to integrate Watchman
+# (https://facebook.github.io/watchman/) with git to speed up detecting
+# new and modified files.
+#
+# The hook is passed a version (currently 2) and last update token
+# formatted as a string and outputs to stdout a new update token and
+# all files that have been modified since the update token. Paths must
+# be relative to the root of the working tree and separated by a single NUL.
+#
+# To enable this hook, rename this file to "query-watchman" and set
+# 'git config core.fsmonitor .git/hooks/query-watchman'
+#
+my ($version, $last_update_token) = @ARGV;
+
+# Uncomment for debugging
+# print STDERR "$0 $version $last_update_token\n";
+
+# Check the hook interface version
+if ($version ne 2) {
+	die "Unsupported query-fsmonitor hook version '$version'.\n" .
+	    "Falling back to scanning...\n";
+}
+
+my $git_work_tree = get_working_dir();
+
+my $retry = 1;
+
+my $json_pkg;
+eval {
+	require JSON::XS;
+	$json_pkg = "JSON::XS";
+	1;
+} or do {
+	require JSON::PP;
+	$json_pkg = "JSON::PP";
+};
+
+launch_watchman();
+
+sub launch_watchman {
+	my $o = watchman_query();
+	if (is_work_tree_watched($o)) {
+		output_result($o->{clock}, @{$o->{files}});
+	}
+}
+
+sub output_result {
+	my ($clockid, @files) = @_;
+
+	# Uncomment for debugging watchman output
+	# open (my $fh, ">", ".git/watchman-output.out");
+	# binmode $fh, ":utf8";
+	# print $fh "$clockid\n@files\n";
+	# close $fh;
+
+	binmode STDOUT, ":utf8";
+	print $clockid;
+	print "\0";
+	local $, = "\0";
+	print @files;
+}
+
+sub watchman_clock {
+	my $response = qx/watchman clock "$git_work_tree"/;
+	die "Failed to get clock id on '$git_work_tree'.\n" .
+		"Falling back to scanning...\n" if $? != 0;
+
+	return $json_pkg->new->utf8->decode($response);
+}
+
+sub watchman_query {
+	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
+	or die "open2() failed: $!\n" .
+	"Falling back to scanning...\n";
+
+	# In the query expression below we're asking for names of files that
+	# changed since $last_update_token but not from the .git folder.
+	#
+	# To accomplish this, we're using the "since" generator to use the
+	# recency index to select candidate nodes and "fields" to limit the
+	# output to file names only. Then we're using the "expression" term to
+	# further constrain the results.
+	my $last_update_line = "";
+	if (substr($last_update_token, 0, 1) eq "c") {
+		$last_update_token = "\"$last_update_token\"";
+		$last_update_line = qq[\n"since": $last_update_token,];
+	}
+	my $query = <<"	END";
+		["query", "$git_work_tree", {$last_update_line
+			"fields": ["name"],
+			"expression": ["not", ["dirname", ".git"]]
+		}]
+	END
+
+	# Uncomment for debugging the watchman query
+	# open (my $fh, ">", ".git/watchman-query.json");
+	# print $fh $query;
+	# close $fh;
+
+	print CHLD_IN $query;
+	close CHLD_IN;
+	my $response = do {local $/; <CHLD_OUT>};
+
+	# Uncomment for debugging the watch response
+	# open ($fh, ">", ".git/watchman-response.json");
+	# print $fh $response;
+	# close $fh;
+
+	die "Watchman: command returned no output.\n" .
+	"Falling back to scanning...\n" if $response eq "";
+	die "Watchman: command returned invalid output: $response\n" .
+	"Falling back to scanning...\n" unless $response =~ /^\{/;
+
+	return $json_pkg->new->utf8->decode($response);
+}
+
+sub is_work_tree_watched {
+	my ($output) = @_;
+	my $error = $output->{error};
+	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
+		$retry--;
+		my $response = qx/watchman watch "$git_work_tree"/;
+		die "Failed to make watchman watch '$git_work_tree'.\n" .
+		    "Falling back to scanning...\n" if $? != 0;
+		$output = $json_pkg->new->utf8->decode($response);
+		$error = $output->{error};
+		die "Watchman: $error.\n" .
+		"Falling back to scanning...\n" if $error;
+
+		# Uncomment for debugging watchman output
+		# open (my $fh, ">", ".git/watchman-output.out");
+		# close $fh;
+
+		# Watchman will always return all files on the first query so
+		# return the fast "everything is dirty" flag to git and do the
+		# Watchman query just to get it over with now so we won't pay
+		# the cost in git to look up each individual file.
+		my $o = watchman_clock();
+		$error = $output->{error};
+
+		die "Watchman: $error.\n" .
+		"Falling back to scanning...\n" if $error;
+
+		output_result($o->{clock}, ("/"));
+		$last_update_token = $o->{clock};
+
+		eval { launch_watchman() };
+		return 0;
+	}
+
+	die "Watchman: $error.\n" .
+	"Falling back to scanning...\n" if $error;
+
+	return 1;
+}
+
+sub get_working_dir {
+	my $working_dir;
+	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
+		$working_dir = Win32::GetCwd();
+		$working_dir =~ tr/\\/\//;
+	} else {
+		require Cwd;
+		$working_dir = Cwd::cwd();
+	}
+
+	return $working_dir;
+}
diff '--color=auto' -urN dwl/.git/hooks/post-update.sample mis_repos/dwl/.git/hooks/post-update.sample
--- dwl/.git/hooks/post-update.sample	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/.git/hooks/post-update.sample	2024-10-01 23:08:33.976379152 +0200
@@ -0,0 +1,8 @@
+#!/bin/sh
+#
+# An example hook script to prepare a packed repository for use over
+# dumb transports.
+#
+# To enable this hook, rename this file to "post-update".
+
+exec git update-server-info
diff '--color=auto' -urN dwl/.git/hooks/pre-applypatch.sample mis_repos/dwl/.git/hooks/pre-applypatch.sample
--- dwl/.git/hooks/pre-applypatch.sample	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/.git/hooks/pre-applypatch.sample	2024-10-01 23:08:33.976379152 +0200
@@ -0,0 +1,14 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed
+# by applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-applypatch".
+
+. git-sh-setup
+precommit="$(git rev-parse --git-path hooks/pre-commit)"
+test -x "$precommit" && exec "$precommit" ${1+"$@"}
+:
diff '--color=auto' -urN dwl/.git/hooks/pre-commit.sample mis_repos/dwl/.git/hooks/pre-commit.sample
--- dwl/.git/hooks/pre-commit.sample	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/.git/hooks/pre-commit.sample	2024-10-01 23:08:33.976379152 +0200
@@ -0,0 +1,49 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed.
+# Called by "git commit" with no arguments.  The hook should
+# exit with non-zero status after issuing an appropriate message if
+# it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-commit".
+
+if git rev-parse --verify HEAD >/dev/null 2>&1
+then
+	against=HEAD
+else
+	# Initial commit: diff against an empty tree object
+	against=$(git hash-object -t tree /dev/null)
+fi
+
+# If you want to allow non-ASCII filenames set this variable to true.
+allownonascii=$(git config --type=bool hooks.allownonascii)
+
+# Redirect output to stderr.
+exec 1>&2
+
+# Cross platform projects tend to avoid non-ASCII filenames; prevent
+# them from being added to the repository. We exploit the fact that the
+# printable range starts at the space character and ends with tilde.
+if [ "$allownonascii" != "true" ] &&
+	# Note that the use of brackets around a tr range is ok here, (it's
+	# even required, for portability to Solaris 10's /usr/bin/tr), since
+	# the square bracket bytes happen to fall in the designated range.
+	test $(git diff-index --cached --name-only --diff-filter=A -z $against |
+	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
+then
+	cat <<\EOF
+Error: Attempt to add a non-ASCII file name.
+
+This can cause problems if you want to work with people on other platforms.
+
+To be portable it is advisable to rename the file.
+
+If you know what you are doing you can disable this check using:
+
+  git config hooks.allownonascii true
+EOF
+	exit 1
+fi
+
+# If there are whitespace errors, print the offending file names and fail.
+exec git diff-index --check --cached $against --
diff '--color=auto' -urN dwl/.git/hooks/pre-merge-commit.sample mis_repos/dwl/.git/hooks/pre-merge-commit.sample
--- dwl/.git/hooks/pre-merge-commit.sample	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/.git/hooks/pre-merge-commit.sample	2024-10-01 23:08:33.976379152 +0200
@@ -0,0 +1,13 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed.
+# Called by "git merge" with no arguments.  The hook should
+# exit with non-zero status after issuing an appropriate message to
+# stderr if it wants to stop the merge commit.
+#
+# To enable this hook, rename this file to "pre-merge-commit".
+
+. git-sh-setup
+test -x "$GIT_DIR/hooks/pre-commit" &&
+        exec "$GIT_DIR/hooks/pre-commit"
+:
diff '--color=auto' -urN dwl/.git/hooks/prepare-commit-msg.sample mis_repos/dwl/.git/hooks/prepare-commit-msg.sample
--- dwl/.git/hooks/prepare-commit-msg.sample	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/.git/hooks/prepare-commit-msg.sample	2024-10-01 23:08:33.979712431 +0200
@@ -0,0 +1,42 @@
+#!/bin/sh
+#
+# An example hook script to prepare the commit log message.
+# Called by "git commit" with the name of the file that has the
+# commit message, followed by the description of the commit
+# message's source.  The hook's purpose is to edit the commit
+# message file.  If the hook fails with a non-zero status,
+# the commit is aborted.
+#
+# To enable this hook, rename this file to "prepare-commit-msg".
+
+# This hook includes three examples. The first one removes the
+# "# Please enter the commit message..." help message.
+#
+# The second includes the output of "git diff --name-status -r"
+# into the message, just before the "git status" output.  It is
+# commented because it doesn't cope with --amend or with squashed
+# commits.
+#
+# The third example adds a Signed-off-by line to the message, that can
+# still be edited.  This is rarely a good idea.
+
+COMMIT_MSG_FILE=$1
+COMMIT_SOURCE=$2
+SHA1=$3
+
+/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"
+
+# case "$COMMIT_SOURCE,$SHA1" in
+#  ,|template,)
+#    /usr/bin/perl -i.bak -pe '
+#       print "\n" . `git diff --cached --name-status -r`
+# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
+#  *) ;;
+# esac
+
+# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
+# if test -z "$COMMIT_SOURCE"
+# then
+#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
+# fi
diff '--color=auto' -urN dwl/.git/hooks/pre-push.sample mis_repos/dwl/.git/hooks/pre-push.sample
--- dwl/.git/hooks/pre-push.sample	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/.git/hooks/pre-push.sample	2024-10-01 23:08:33.976379152 +0200
@@ -0,0 +1,53 @@
+#!/bin/sh
+
+# An example hook script to verify what is about to be pushed.  Called by "git
+# push" after it has checked the remote status, but before anything has been
+# pushed.  If this script exits with a non-zero status nothing will be pushed.
+#
+# This hook is called with the following parameters:
+#
+# $1 -- Name of the remote to which the push is being done
+# $2 -- URL to which the push is being done
+#
+# If pushing without using a named remote those arguments will be equal.
+#
+# Information about the commits which are being pushed is supplied as lines to
+# the standard input in the form:
+#
+#   <local ref> <local oid> <remote ref> <remote oid>
+#
+# This sample shows how to prevent push of commits where the log message starts
+# with "WIP" (work in progress).
+
+remote="$1"
+url="$2"
+
+zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
+
+while read local_ref local_oid remote_ref remote_oid
+do
+	if test "$local_oid" = "$zero"
+	then
+		# Handle delete
+		:
+	else
+		if test "$remote_oid" = "$zero"
+		then
+			# New branch, examine all commits
+			range="$local_oid"
+		else
+			# Update to existing branch, examine new commits
+			range="$remote_oid..$local_oid"
+		fi
+
+		# Check for WIP commit
+		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
+		if test -n "$commit"
+		then
+			echo >&2 "Found WIP commit in $local_ref, not pushing"
+			exit 1
+		fi
+	fi
+done
+
+exit 0
diff '--color=auto' -urN dwl/.git/hooks/pre-rebase.sample mis_repos/dwl/.git/hooks/pre-rebase.sample
--- dwl/.git/hooks/pre-rebase.sample	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/.git/hooks/pre-rebase.sample	2024-10-01 23:08:33.979712431 +0200
@@ -0,0 +1,169 @@
+#!/bin/sh
+#
+# Copyright (c) 2006, 2008 Junio C Hamano
+#
+# The "pre-rebase" hook is run just before "git rebase" starts doing
+# its job, and can prevent the command from running by exiting with
+# non-zero status.
+#
+# The hook is called with the following parameters:
+#
+# $1 -- the upstream the series was forked from.
+# $2 -- the branch being rebased (or empty when rebasing the current branch).
+#
+# This sample shows how to prevent topic branches that are already
+# merged to 'next' branch from getting rebased, because allowing it
+# would result in rebasing already published history.
+
+publish=next
+basebranch="$1"
+if test "$#" = 2
+then
+	topic="refs/heads/$2"
+else
+	topic=`git symbolic-ref HEAD` ||
+	exit 0 ;# we do not interrupt rebasing detached HEAD
+fi
+
+case "$topic" in
+refs/heads/??/*)
+	;;
+*)
+	exit 0 ;# we do not interrupt others.
+	;;
+esac
+
+# Now we are dealing with a topic branch being rebased
+# on top of master.  Is it OK to rebase it?
+
+# Does the topic really exist?
+git show-ref -q "$topic" || {
+	echo >&2 "No such branch $topic"
+	exit 1
+}
+
+# Is topic fully merged to master?
+not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
+if test -z "$not_in_master"
+then
+	echo >&2 "$topic is fully merged to master; better remove it."
+	exit 1 ;# we could allow it, but there is no point.
+fi
+
+# Is topic ever merged to next?  If so you should not be rebasing it.
+only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
+only_next_2=`git rev-list ^master           ${publish} | sort`
+if test "$only_next_1" = "$only_next_2"
+then
+	not_in_topic=`git rev-list "^$topic" master`
+	if test -z "$not_in_topic"
+	then
+		echo >&2 "$topic is already up to date with master"
+		exit 1 ;# we could allow it, but there is no point.
+	else
+		exit 0
+	fi
+else
+	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
+	/usr/bin/perl -e '
+		my $topic = $ARGV[0];
+		my $msg = "* $topic has commits already merged to public branch:\n";
+		my (%not_in_next) = map {
+			/^([0-9a-f]+) /;
+			($1 => 1);
+		} split(/\n/, $ARGV[1]);
+		for my $elem (map {
+				/^([0-9a-f]+) (.*)$/;
+				[$1 => $2];
+			} split(/\n/, $ARGV[2])) {
+			if (!exists $not_in_next{$elem->[0]}) {
+				if ($msg) {
+					print STDERR $msg;
+					undef $msg;
+				}
+				print STDERR " $elem->[1]\n";
+			}
+		}
+	' "$topic" "$not_in_next" "$not_in_master"
+	exit 1
+fi
+
+<<\DOC_END
+
+This sample hook safeguards topic branches that have been
+published from being rewound.
+
+The workflow assumed here is:
+
+ * Once a topic branch forks from "master", "master" is never
+   merged into it again (either directly or indirectly).
+
+ * Once a topic branch is fully cooked and merged into "master",
+   it is deleted.  If you need to build on top of it to correct
+   earlier mistakes, a new topic branch is created by forking at
+   the tip of the "master".  This is not strictly necessary, but
+   it makes it easier to keep your history simple.
+
+ * Whenever you need to test or publish your changes to topic
+   branches, merge them into "next" branch.
+
+The script, being an example, hardcodes the publish branch name
+to be "next", but it is trivial to make it configurable via
+$GIT_DIR/config mechanism.
+
+With this workflow, you would want to know:
+
+(1) ... if a topic branch has ever been merged to "next".  Young
+    topic branches can have stupid mistakes you would rather
+    clean up before publishing, and things that have not been
+    merged into other branches can be easily rebased without
+    affecting other people.  But once it is published, you would
+    not want to rewind it.
+
+(2) ... if a topic branch has been fully merged to "master".
+    Then you can delete it.  More importantly, you should not
+    build on top of it -- other people may already want to
+    change things related to the topic as patches against your
+    "master", so if you need further changes, it is better to
+    fork the topic (perhaps with the same name) afresh from the
+    tip of "master".
+
+Let's look at this example:
+
+		   o---o---o---o---o---o---o---o---o---o "next"
+		  /       /           /           /
+		 /   a---a---b A     /           /
+		/   /               /           /
+	       /   /   c---c---c---c B         /
+	      /   /   /             \         /
+	     /   /   /   b---b C     \       /
+	    /   /   /   /             \     /
+    ---o---o---o---o---o---o---o---o---o---o---o "master"
+
+
+A, B and C are topic branches.
+
+ * A has one fix since it was merged up to "next".
+
+ * B has finished.  It has been fully merged up to "master" and "next",
+   and is ready to be deleted.
+
+ * C has not merged to "next" at all.
+
+We would want to allow C to be rebased, refuse A, and encourage
+B to be deleted.
+
+To compute (1):
+
+	git rev-list ^master ^topic next
+	git rev-list ^master        next
+
+	if these match, topic has not merged in next at all.
+
+To compute (2):
+
+	git rev-list master..topic
+
+	if this is empty, it is fully merged to "master".
+
+DOC_END
diff '--color=auto' -urN dwl/.git/hooks/pre-receive.sample mis_repos/dwl/.git/hooks/pre-receive.sample
--- dwl/.git/hooks/pre-receive.sample	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/.git/hooks/pre-receive.sample	2024-10-01 23:08:33.979712431 +0200
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to make use of push options.
+# The example simply echoes all push options that start with 'echoback='
+# and rejects all pushes when the "reject" push option is used.
+#
+# To enable this hook, rename this file to "pre-receive".
+
+if test -n "$GIT_PUSH_OPTION_COUNT"
+then
+	i=0
+	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
+	do
+		eval "value=\$GIT_PUSH_OPTION_$i"
+		case "$value" in
+		echoback=*)
+			echo "echo from the pre-receive-hook: ${value#*=}" >&2
+			;;
+		reject)
+			exit 1
+		esac
+		i=$((i + 1))
+	done
+fi
diff '--color=auto' -urN dwl/.git/hooks/push-to-checkout.sample mis_repos/dwl/.git/hooks/push-to-checkout.sample
--- dwl/.git/hooks/push-to-checkout.sample	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/.git/hooks/push-to-checkout.sample	2024-10-01 23:08:33.979712431 +0200
@@ -0,0 +1,78 @@
+#!/bin/sh
+
+# An example hook script to update a checked-out tree on a git push.
+#
+# This hook is invoked by git-receive-pack(1) when it reacts to git
+# push and updates reference(s) in its repository, and when the push
+# tries to update the branch that is currently checked out and the
+# receive.denyCurrentBranch configuration variable is set to
+# updateInstead.
+#
+# By default, such a push is refused if the working tree and the index
+# of the remote repository has any difference from the currently
+# checked out commit; when both the working tree and the index match
+# the current commit, they are updated to match the newly pushed tip
+# of the branch. This hook is to be used to override the default
+# behaviour; however the code below reimplements the default behaviour
+# as a starting point for convenient modification.
+#
+# The hook receives the commit with which the tip of the current
+# branch is going to be updated:
+commit=$1
+
+# It can exit with a non-zero status to refuse the push (when it does
+# so, it must not modify the index or the working tree).
+die () {
+	echo >&2 "$*"
+	exit 1
+}
+
+# Or it can make any necessary changes to the working tree and to the
+# index to bring them to the desired state when the tip of the current
+# branch is updated to the new commit, and exit with a zero status.
+#
+# For example, the hook can simply run git read-tree -u -m HEAD "$1"
+# in order to emulate git fetch that is run in the reverse direction
+# with git push, as the two-tree form of git read-tree -u -m is
+# essentially the same as git switch or git checkout that switches
+# branches while keeping the local changes in the working tree that do
+# not interfere with the difference between the branches.
+
+# The below is a more-or-less exact translation to shell of the C code
+# for the default behaviour for git's push-to-checkout hook defined in
+# the push_to_deploy() function in builtin/receive-pack.c.
+#
+# Note that the hook will be executed from the repository directory,
+# not from the working tree, so if you want to perform operations on
+# the working tree, you will have to adapt your code accordingly, e.g.
+# by adding "cd .." or using relative paths.
+
+if ! git update-index -q --ignore-submodules --refresh
+then
+	die "Up-to-date check failed"
+fi
+
+if ! git diff-files --quiet --ignore-submodules --
+then
+	die "Working directory has unstaged changes"
+fi
+
+# This is a rough translation of:
+#
+#   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
+if git cat-file -e HEAD 2>/dev/null
+then
+	head=HEAD
+else
+	head=$(git hash-object -t tree --stdin </dev/null)
+fi
+
+if ! git diff-index --quiet --cached --ignore-submodules $head --
+then
+	die "Working directory has staged changes"
+fi
+
+if ! git read-tree -u -m "$commit"
+then
+	die "Could not update working tree to new HEAD"
+fi
diff '--color=auto' -urN dwl/.git/hooks/sendemail-validate.sample mis_repos/dwl/.git/hooks/sendemail-validate.sample
--- dwl/.git/hooks/sendemail-validate.sample	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/.git/hooks/sendemail-validate.sample	2024-10-01 23:08:33.979712431 +0200
@@ -0,0 +1,77 @@
+#!/bin/sh
+
+# An example hook script to validate a patch (and/or patch series) before
+# sending it via email.
+#
+# The hook should exit with non-zero status after issuing an appropriate
+# message if it wants to prevent the email(s) from being sent.
+#
+# To enable this hook, rename this file to "sendemail-validate".
+#
+# By default, it will only check that the patch(es) can be applied on top of
+# the default upstream branch without conflicts in a secondary worktree. After
+# validation (successful or not) of the last patch of a series, the worktree
+# will be deleted.
+#
+# The following config variables can be set to change the default remote and
+# remote ref that are used to apply the patches against:
+#
+#   sendemail.validateRemote (default: origin)
+#   sendemail.validateRemoteRef (default: HEAD)
+#
+# Replace the TODO placeholders with appropriate checks according to your
+# needs.
+
+validate_cover_letter () {
+	file="$1"
+	# TODO: Replace with appropriate checks (e.g. spell checking).
+	true
+}
+
+validate_patch () {
+	file="$1"
+	# Ensure that the patch applies without conflicts.
+	git am -3 "$file" || return
+	# TODO: Replace with appropriate checks for this patch
+	# (e.g. checkpatch.pl).
+	true
+}
+
+validate_series () {
+	# TODO: Replace with appropriate checks for the whole series
+	# (e.g. quick build, coding style checks, etc.).
+	true
+}
+
+# main -------------------------------------------------------------------------
+
+if test "$GIT_SENDEMAIL_FILE_COUNTER" = 1
+then
+	remote=$(git config --default origin --get sendemail.validateRemote) &&
+	ref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&
+	worktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&
+	git worktree add -fd --checkout "$worktree" "refs/remotes/$remote/$ref" &&
+	git config --replace-all sendemail.validateWorktree "$worktree"
+else
+	worktree=$(git config --get sendemail.validateWorktree)
+fi || {
+	echo "sendemail-validate: error: failed to prepare worktree" >&2
+	exit 1
+}
+
+unset GIT_DIR GIT_WORK_TREE
+cd "$worktree" &&
+
+if grep -q "^diff --git " "$1"
+then
+	validate_patch "$1"
+else
+	validate_cover_letter "$1"
+fi &&
+
+if test "$GIT_SENDEMAIL_FILE_COUNTER" = "$GIT_SENDEMAIL_FILE_TOTAL"
+then
+	git config --unset-all sendemail.validateWorktree &&
+	trap 'git worktree remove -ff "$worktree"' EXIT &&
+	validate_series
+fi
diff '--color=auto' -urN dwl/.git/hooks/update.sample mis_repos/dwl/.git/hooks/update.sample
--- dwl/.git/hooks/update.sample	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/.git/hooks/update.sample	2024-10-01 23:08:33.983045710 +0200
@@ -0,0 +1,128 @@
+#!/bin/sh
+#
+# An example hook script to block unannotated tags from entering.
+# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
+#
+# To enable this hook, rename this file to "update".
+#
+# Config
+# ------
+# hooks.allowunannotated
+#   This boolean sets whether unannotated tags will be allowed into the
+#   repository.  By default they won't be.
+# hooks.allowdeletetag
+#   This boolean sets whether deleting tags will be allowed in the
+#   repository.  By default they won't be.
+# hooks.allowmodifytag
+#   This boolean sets whether a tag may be modified after creation. By default
+#   it won't be.
+# hooks.allowdeletebranch
+#   This boolean sets whether deleting branches will be allowed in the
+#   repository.  By default they won't be.
+# hooks.denycreatebranch
+#   This boolean sets whether remotely creating branches will be denied
+#   in the repository.  By default this is allowed.
+#
+
+# --- Command line
+refname="$1"
+oldrev="$2"
+newrev="$3"
+
+# --- Safety check
+if [ -z "$GIT_DIR" ]; then
+	echo "Don't run this script from the command line." >&2
+	echo " (if you want, you could supply GIT_DIR then run" >&2
+	echo "  $0 <ref> <oldrev> <newrev>)" >&2
+	exit 1
+fi
+
+if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
+	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
+	exit 1
+fi
+
+# --- Config
+allowunannotated=$(git config --type=bool hooks.allowunannotated)
+allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
+denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
+allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
+allowmodifytag=$(git config --type=bool hooks.allowmodifytag)
+
+# check for no description
+projectdesc=$(sed -e '1q' "$GIT_DIR/description")
+case "$projectdesc" in
+"Unnamed repository"* | "")
+	echo "*** Project description file hasn't been set" >&2
+	exit 1
+	;;
+esac
+
+# --- Check types
+# if $newrev is 0000...0000, it's a commit to delete a ref.
+zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
+if [ "$newrev" = "$zero" ]; then
+	newrev_type=delete
+else
+	newrev_type=$(git cat-file -t $newrev)
+fi
+
+case "$refname","$newrev_type" in
+	refs/tags/*,commit)
+		# un-annotated tag
+		short_refname=${refname##refs/tags/}
+		if [ "$allowunannotated" != "true" ]; then
+			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
+			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,delete)
+		# delete tag
+		if [ "$allowdeletetag" != "true" ]; then
+			echo "*** Deleting a tag is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,tag)
+		# annotated tag
+		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
+		then
+			echo "*** Tag '$refname' already exists." >&2
+			echo "*** Modifying a tag is not allowed in this repository." >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,commit)
+		# branch
+		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
+			echo "*** Creating a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,delete)
+		# delete branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/remotes/*,commit)
+		# tracking branch
+		;;
+	refs/remotes/*,delete)
+		# delete tracking branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	*)
+		# Anything else (is there anything else?)
+		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
+		exit 1
+		;;
+esac
+
+# --- Finished
+exit 0
Binary files dwl/.git/index and mis_repos/dwl/.git/index differ
diff '--color=auto' -urN dwl/.git/info/exclude mis_repos/dwl/.git/info/exclude
--- dwl/.git/info/exclude	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/.git/info/exclude	2024-10-01 23:08:33.983045710 +0200
@@ -0,0 +1,6 @@
+# git ls-files --others --exclude-from=.git/info/exclude
+# Lines that start with '#' are comments.
+# For a project mostly in C, the following would be a good set of
+# exclude patterns (uncomment them if you want to use them):
+# *.[oa]
+# *~
diff '--color=auto' -urN dwl/.git/logs/HEAD mis_repos/dwl/.git/logs/HEAD
--- dwl/.git/logs/HEAD	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/.git/logs/HEAD	2024-10-01 23:12:25.819241960 +0200
@@ -0,0 +1,2 @@
+0000000000000000000000000000000000000000 a70c61f7ed513936411df3007c384c5868734370 dcalonge <dcalonge01@gmail.com> 1727816918 +0200	clone: from https://github.com/dcalonge/dwl.git
+a70c61f7ed513936411df3007c384c5868734370 a0557d0eb1807afb2f8dca24003019cc9a8ccfd3 dcalonge <dcalonge01@gmail.com> 1727817145 +0200	commit: added .diff file
diff '--color=auto' -urN dwl/.git/logs/refs/heads/main mis_repos/dwl/.git/logs/refs/heads/main
--- dwl/.git/logs/refs/heads/main	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/.git/logs/refs/heads/main	2024-10-01 23:12:25.819241960 +0200
@@ -0,0 +1,2 @@
+0000000000000000000000000000000000000000 a70c61f7ed513936411df3007c384c5868734370 dcalonge <dcalonge01@gmail.com> 1727816918 +0200	clone: from https://github.com/dcalonge/dwl.git
+a70c61f7ed513936411df3007c384c5868734370 a0557d0eb1807afb2f8dca24003019cc9a8ccfd3 dcalonge <dcalonge01@gmail.com> 1727817145 +0200	commit: added .diff file
diff '--color=auto' -urN dwl/.git/logs/refs/remotes/origin/HEAD mis_repos/dwl/.git/logs/refs/remotes/origin/HEAD
--- dwl/.git/logs/refs/remotes/origin/HEAD	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/.git/logs/refs/remotes/origin/HEAD	2024-10-01 23:08:38.136310900 +0200
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 a70c61f7ed513936411df3007c384c5868734370 dcalonge <dcalonge01@gmail.com> 1727816918 +0200	clone: from https://github.com/dcalonge/dwl.git
diff '--color=auto' -urN dwl/.git/logs/refs/remotes/origin/main mis_repos/dwl/.git/logs/refs/remotes/origin/main
--- dwl/.git/logs/refs/remotes/origin/main	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/.git/logs/refs/remotes/origin/main	2024-10-01 23:12:30.985823858 +0200
@@ -0,0 +1 @@
+a70c61f7ed513936411df3007c384c5868734370 a0557d0eb1807afb2f8dca24003019cc9a8ccfd3 dcalonge <dcalonge01@gmail.com> 1727817150 +0200	update by push
Binary files dwl/.git/objects/92/d952c46c8771e88bea551bf767edd9e2d3d12a and mis_repos/dwl/.git/objects/92/d952c46c8771e88bea551bf767edd9e2d3d12a differ
diff '--color=auto' -urN dwl/.git/objects/a0/557d0eb1807afb2f8dca24003019cc9a8ccfd3 mis_repos/dwl/.git/objects/a0/557d0eb1807afb2f8dca24003019cc9a8ccfd3
--- dwl/.git/objects/a0/557d0eb1807afb2f8dca24003019cc9a8ccfd3	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/.git/objects/a0/557d0eb1807afb2f8dca24003019cc9a8ccfd3	2024-10-01 23:12:25.819241960 +0200
@@ -0,0 +1,4 @@
+xŽK
+Ã0D»ö)´/É²-JéUKNù”àÞ¿Ùô]æ1u_×¹ƒ÷ré‡ÔjºG¥”Ä“kg¢ŽÇ"Ê™TÝ»¶u(‚5QÓH|ãˆ´1¢T>M1§,XÐ•Oíh-Ë¾M÷_CzNk™—¡îëH¼d
+®èÝIÏƒÝþ˜º¢j
+ƒÎ­A›s_µ~F$
\ No newline at end of file
Binary files dwl/.git/objects/c8/4c69b80bd166721e4efe4e5db35ba7d32031dd and mis_repos/dwl/.git/objects/c8/4c69b80bd166721e4efe4e5db35ba7d32031dd differ
Binary files dwl/.git/objects/pack/pack-aecc2af9272869bea5df3c32a537c6de24f684d9.idx and mis_repos/dwl/.git/objects/pack/pack-aecc2af9272869bea5df3c32a537c6de24f684d9.idx differ
Binary files dwl/.git/objects/pack/pack-aecc2af9272869bea5df3c32a537c6de24f684d9.pack and mis_repos/dwl/.git/objects/pack/pack-aecc2af9272869bea5df3c32a537c6de24f684d9.pack differ
Binary files dwl/.git/objects/pack/pack-aecc2af9272869bea5df3c32a537c6de24f684d9.rev and mis_repos/dwl/.git/objects/pack/pack-aecc2af9272869bea5df3c32a537c6de24f684d9.rev differ
diff '--color=auto' -urN dwl/.git/packed-refs mis_repos/dwl/.git/packed-refs
--- dwl/.git/packed-refs	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/.git/packed-refs	2024-10-01 23:08:38.132977622 +0200
@@ -0,0 +1,2 @@
+# pack-refs with: peeled fully-peeled sorted 
+a70c61f7ed513936411df3007c384c5868734370 refs/remotes/origin/main
diff '--color=auto' -urN dwl/.git/refs/heads/main mis_repos/dwl/.git/refs/heads/main
--- dwl/.git/refs/heads/main	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/.git/refs/heads/main	2024-10-01 23:12:25.819241960 +0200
@@ -0,0 +1 @@
+a0557d0eb1807afb2f8dca24003019cc9a8ccfd3
diff '--color=auto' -urN dwl/.git/refs/remotes/origin/HEAD mis_repos/dwl/.git/refs/remotes/origin/HEAD
--- dwl/.git/refs/remotes/origin/HEAD	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/.git/refs/remotes/origin/HEAD	2024-10-01 23:08:38.132977622 +0200
@@ -0,0 +1 @@
+ref: refs/remotes/origin/main
diff '--color=auto' -urN dwl/.git/refs/remotes/origin/main mis_repos/dwl/.git/refs/remotes/origin/main
--- dwl/.git/refs/remotes/origin/main	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/.git/refs/remotes/origin/main	2024-10-01 23:12:30.985823858 +0200
@@ -0,0 +1 @@
+a0557d0eb1807afb2f8dca24003019cc9a8ccfd3
diff '--color=auto' -urN dwl/.gitea/issue_template/bug_report.yml mis_repos/dwl/.gitea/issue_template/bug_report.yml
--- dwl/.gitea/issue_template/bug_report.yml	2024-08-06 20:03:27.000000000 +0200
+++ mis_repos/dwl/.gitea/issue_template/bug_report.yml	1970-01-01 01:00:00.000000000 +0100
@@ -1,62 +0,0 @@
-name: Bug Report
-about: Something in dwl isn't working correctly
-title:
-labels:
-    - 'Kind/Bug'
-body:
-    - type: markdown
-      attributes:
-          value: |
-              - Only report bugs that can be reproduced on the main (or wlroots-next) branch without patches.
-              - Proprietary graphics drivers, including nvidia, are not supported. Please use the open source equivalents, such as nouveau, if you would like to use dwl.
-              - Report patch issues to their respective authors.
-
-    - type: input
-      id: dwl_version
-      attributes:
-          label: 'dwl version:'
-          placeholder: '`dwl -v`'
-      validations:
-          required: true
-
-    - type: input
-      id: wlroots_version
-      attributes:
-          label: 'wlroots version:'
-      validations:
-          required: true
-
-    - type: input
-      id: distro
-      attributes:
-          label: What distro (and version) are you using?
-      validations:
-          required: false
-
-    - type: textarea
-      attributes:
-          label: Description
-          value: |
-              The steps you took to reproduce the problem.
-      validations:
-          required: false
-
-    - type: textarea
-      id: debug_log
-      attributes:
-          label: Debug Log
-          value: |
-              Run `dwl -d 2> ~/dwl.log` from a TTY and attach the **full** (do not truncate it) file here, or upload it to a pastebin.
-              Please try to keep the reproduction as brief as possible and exit dwl.
-      validations:
-          required: false
-
-    - type: textarea
-      id: backtrace
-      attributes:
-          label: Stack Trace
-          value: |
-              - Only required if dwl crashes.
-              - If the lines mentioning dwl or wlroots have `??`. Please compile both dwl and wlroots from source (enabling debug symbols) and try to reproduce.
-      validations:
-          required: false
diff '--color=auto' -urN dwl/.gitea/issue_template/enhancement-idea.yml mis_repos/dwl/.gitea/issue_template/enhancement-idea.yml
--- dwl/.gitea/issue_template/enhancement-idea.yml	2024-08-06 20:03:27.000000000 +0200
+++ mis_repos/dwl/.gitea/issue_template/enhancement-idea.yml	1970-01-01 01:00:00.000000000 +0100
@@ -1,9 +0,0 @@
-name: Enhancement idea
-about: Suggest a feature or improvement
-title:
-labels:
-    - 'Kind/Feature'
-body:
-    - type: textarea
-      attributes:
-          label: Description
diff '--color=auto' -urN dwl/.gitignore mis_repos/dwl/.gitignore
--- dwl/.gitignore	2024-08-06 20:03:27.000000000 +0200
+++ mis_repos/dwl/.gitignore	1970-01-01 01:00:00.000000000 +0100
@@ -1,6 +0,0 @@
-dwl
-*.o
-*-protocol.c
-*-protocol.h
-.ccls-cache
-config.h
diff '--color=auto' -urN dwl/.mailmap mis_repos/dwl/.mailmap
--- dwl/.mailmap	2024-08-06 20:03:27.000000000 +0200
+++ mis_repos/dwl/.mailmap	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-Lennart Jablonka <humm@ljabl.com> <hummsmith42@gmail.com>
diff '--color=auto' -urN dwl/Makefile mis_repos/dwl/Makefile
--- dwl/Makefile	2024-08-06 20:03:27.000000000 +0200
+++ mis_repos/dwl/Makefile	2024-10-01 23:08:38.139644179 +0200
@@ -12,7 +12,7 @@
 	-Wfloat-conversion
 
 # CFLAGS / LDFLAGS
-PKGS      = wlroots-0.18 wayland-server xkbcommon libinput $(XLIBS)
+PKGS      = wlroots-0.18 wayland-server xkbcommon libinput pixman-1 fcft $(XLIBS)
 DWLCFLAGS = `$(PKG_CONFIG) --cflags $(PKGS)` $(DWLCPPFLAGS) $(DWLDEVCFLAGS) $(CFLAGS)
 LDLIBS    = `$(PKG_CONFIG) --libs $(PKGS)` -lm $(LIBS)
 
diff '--color=auto' -urN dwl/patches/alwayscenter.patch mis_repos/dwl/patches/alwayscenter.patch
--- dwl/patches/alwayscenter.patch	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/patches/alwayscenter.patch	2024-10-01 23:08:38.152977293 +0200
@@ -0,0 +1,38 @@
+From 6616470ef135019ef4c767003a66df76df45f53e Mon Sep 17 00:00:00 2001
+From: Guido Cella <guido@guidocella.xyz>
+Date: Wed, 5 Jun 2024 12:05:16 +0200
+Subject: [PATCH] center floating windows
+
+---
+ dwl.c | 8 ++++++++
+ 1 file changed, 8 insertions(+)
+
+diff --git a/dwl.c b/dwl.c
+index 6f041a0..79ace52 100644
+--- a/dwl.c
++++ b/dwl.c
+@@ -472,6 +472,10 @@ applyrules(Client *c)
+ 			}
+ 		}
+ 	}
++	if (mon) {
++		c->geom.x = (mon->w.width - c->geom.width) / 2 + mon->m.x;
++		c->geom.y = (mon->w.height - c->geom.height) / 2 + mon->m.y;
++	}
+ 	setmon(c, mon, newtags);
+ }
+ 
+@@ -1677,6 +1681,10 @@ mapnotify(struct wl_listener *listener, void *data)
+ 	 * try to apply rules for them */
+ 	if ((p = client_get_parent(c))) {
+ 		c->isfloating = 1;
++		if (p->mon) {
++			c->geom.x = (p->mon->w.width - c->geom.width) / 2 + p->mon->m.x;
++			c->geom.y = (p->mon->w.height - c->geom.height) / 2 + p->mon->m.y;
++		}
+ 		setmon(c, p->mon, p->tags);
+ 	} else {
+ 		applyrules(c);
+-- 
+2.45.1
+
diff '--color=auto' -urN dwl/patches/bar-0.7.patch mis_repos/dwl/patches/bar-0.7.patch
--- dwl/patches/bar-0.7.patch	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/patches/bar-0.7.patch	2024-10-01 23:08:38.152977293 +0200
@@ -0,0 +1,1246 @@
+From 1431cf1e9e03c8e59050af3b37514a6a2293d71d Mon Sep 17 00:00:00 2001
+From: sewn <sewn@disroot.org>
+Date: Fri, 23 Aug 2024 09:42:04 +0300
+Subject: [PATCH] Implement dwm bar clone
+
+---
+ Makefile     |   2 +-
+ config.def.h |  31 +++-
+ drwl.h       | 311 ++++++++++++++++++++++++++++++++++++
+ dwl.c        | 442 +++++++++++++++++++++++++++++++++++++++++----------
+ 4 files changed, 691 insertions(+), 95 deletions(-)
+ create mode 100644 drwl.h
+
+diff --git a/Makefile b/Makefile
+index 3358bae..9bc67db 100644
+--- a/Makefile
++++ b/Makefile
+@@ -12,7 +12,7 @@ DWLDEVCFLAGS = -g -pedantic -Wall -Wextra -Wdeclaration-after-statement \
+ 	-Wfloat-conversion
+ 
+ # CFLAGS / LDFLAGS
+-PKGS      = wlroots-0.18 wayland-server xkbcommon libinput $(XLIBS)
++PKGS      = wlroots-0.18 wayland-server xkbcommon libinput pixman-1 fcft $(XLIBS)
+ DWLCFLAGS = `$(PKG_CONFIG) --cflags $(PKGS)` $(DWLCPPFLAGS) $(DWLDEVCFLAGS) $(CFLAGS)
+ LDLIBS    = `$(PKG_CONFIG) --libs $(PKGS)` -lm $(LIBS)
+ 
+diff --git a/config.def.h b/config.def.h
+index 22d2171..5d1dc2b 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -7,15 +7,21 @@
+ static const int sloppyfocus               = 1;  /* focus follows mouse */
+ static const int bypass_surface_visibility = 0;  /* 1 means idle inhibitors will disable idle tracking even if it's surface isn't visible  */
+ static const unsigned int borderpx         = 1;  /* border pixel of windows */
+-static const float rootcolor[]             = COLOR(0x222222ff);
+-static const float bordercolor[]           = COLOR(0x444444ff);
+-static const float focuscolor[]            = COLOR(0x005577ff);
+-static const float urgentcolor[]           = COLOR(0xff0000ff);
++static const int showbar                   = 1; /* 0 means no bar */
++static const int topbar                    = 1; /* 0 means bottom bar */
++static const char *fonts[]                 = {"monospace:size=10"};
++static const float rootcolor[]             = COLOR(0x000000ff);
+ /* This conforms to the xdg-protocol. Set the alpha to zero to restore the old behavior */
+ static const float fullscreen_bg[]         = {0.1f, 0.1f, 0.1f, 1.0f}; /* You can also use glsl colors */
++static uint32_t colors[][3]                = {
++	/*               fg          bg          border    */
++	[SchemeNorm] = { 0xbbbbbbff, 0x222222ff, 0x444444ff },
++	[SchemeSel]  = { 0xeeeeeeff, 0x005577ff, 0x005577ff },
++	[SchemeUrg]  = { 0,          0,          0x770000ff },
++};
+ 
+ /* tagging - TAGCOUNT must be no greater than 31 */
+#define TAGCOUNT (9)
++static char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
+ 
+ /* logging */
+ static int log_level = WLR_ERROR;
+@@ -127,6 +133,7 @@ static const Key keys[] = {
+ 	/* modifier                  key                 function        argument */
+ 	{ MODKEY,                    XKB_KEY_p,          spawn,          {.v = menucmd} },
+ 	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_Return,     spawn,          {.v = termcmd} },
++	{ MODKEY,                    XKB_KEY_b,          togglebar,      {0} },
+ 	{ MODKEY,                    XKB_KEY_j,          focusstack,     {.i = +1} },
+ 	{ MODKEY,                    XKB_KEY_k,          focusstack,     {.i = -1} },
+ 	{ MODKEY,                    XKB_KEY_i,          incnmaster,     {.i = +1} },
+@@ -170,7 +177,15 @@ static const Key keys[] = {
+ };
+ 
+ static const Button buttons[] = {
+-	{ MODKEY, BTN_LEFT,   moveresize,     {.ui = CurMove} },
+-	{ MODKEY, BTN_MIDDLE, togglefloating, {0} },
+-	{ MODKEY, BTN_RIGHT,  moveresize,     {.ui = CurResize} },
++	{ ClkLtSymbol, 0,      					BTN_LEFT,   setlayout,      {.v = &layouts[0]} },
++	{ ClkLtSymbol, 0,      					BTN_RIGHT,  setlayout,      {.v = &layouts[2]} },
++	{ ClkLtSymbol, 0,      					BTN_MIDDLE, setlayout,      {.v = &layouts[1]} },
++	{ ClkTitle,    0,      					BTN_LEFT,   zoom,           {0} },
++	{ ClkStatus,   0,      					BTN_LEFT,   spawn,          {.v = termcmd} },
++	{ ClkClient,   MODKEY, 					BTN_LEFT,   moveresize,     {.ui = CurMove} },
++	{ ClkClient,   MODKEY, 					BTN_MIDDLE, togglefloating, {0} },
++	{ ClkClient,   MODKEY|WLR_MODIFIER_CTRL,BTN_LEFT,   moveresize, 	{.ui = CurResize} },
++	{ ClkTagBar,   0,      					BTN_LEFT,   view,           {0} },
++	{ ClkTagBar,   0,      					BTN_MIDDLE, toggleview,     {0} },
++	{ ClkTagBar,   0,						BTN_RIGHT,  movetagandview, {0} },
++	{ ClkTagBar,   MODKEY, 					BTN_LEFT,  toggletag,      	{0} },
+ };
+diff --git a/drwl.h b/drwl.h
+new file mode 100644
+index 0000000..b06a736
+--- /dev/null
++++ b/drwl.h
+@@ -0,0 +1,311 @@
++/*
++ * drwl - https://codeberg.org/sewn/drwl
++ *
++ * Copyright (c) 2023-2024 sewn <sewn@disroot.org>
++ * Copyright (c) 2024 notchoc <notchoc@disroot.org>
++ * 
++ * Permission is hereby granted, free of charge, to any person obtaining
++ * a copy of this software and associated documentation files (the
++ * "Software"), to deal in the Software without restriction, including
++ * without limitation the rights to use, copy, modify, merge, publish,
++ * distribute, sublicense, and/or sell copies of the Software, and to
++ * permit persons to whom the Software is furnished to do so, subject to
++ * the following conditions:
++ * 
++ * The above copyright notice and this permission notice shall be
++ * included in all copies or substantial portions of the Software.
++ * 
++ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
++ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
++ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
++ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
++ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
++ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
++ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
++ *
++ * The UTF-8 Decoder included is from Bjoern Hoehrmann:
++ * Copyright (c) 2008-2010 Bjoern Hoehrmann <bjoern@hoehrmann.de>
++ * See http://bjoern.hoehrmann.de/utf-8/decoder/dfa/ for details.
++ */
++#pragma once
++
++#include <stdlib.h>
++#include <fcft/fcft.h>
++#include <pixman-1/pixman.h>
++
++enum { ColFg, ColBg, ColBorder }; /* colorscheme index */
++
++typedef struct fcft_font Fnt;
++typedef pixman_image_t Img;
++
++typedef struct {
++	Img *image;
++	Fnt *font;
++	uint32_t *scheme;
++} Drwl;
++
++#define UTF8_ACCEPT 0
++#define UTF8_REJECT 12
++#define UTF8_INVALID 0xFFFD
++
++static const uint8_t utf8d[] = {
++	 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
++	 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
++	 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
++	 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
++	 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,  9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
++	 7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
++	 8,8,2,2,2,2,2,2,2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
++	10,3,3,3,3,3,3,3,3,3,3,3,3,4,3,3, 11,6,6,6,5,8,8,8,8,8,8,8,8,8,8,8,
++
++	 0,12,24,36,60,96,84,12,12,12,48,72, 12,12,12,12,12,12,12,12,12,12,12,12,
++	12, 0,12,12,12,12,12, 0,12, 0,12,12, 12,24,12,12,12,12,12,24,12,24,12,12,
++	12,12,12,12,12,12,12,24,12,12,12,12, 12,24,12,12,12,12,12,12,12,24,12,12,
++	12,12,12,12,12,12,12,36,12,36,12,12, 12,36,12,12,12,12,12,36,12,36,12,12,
++	12,36,12,12,12,12,12,12,12,12,12,12,
++};
++
++static inline uint32_t
++utf8decode(uint32_t *state, uint32_t *codep, uint8_t byte)
++{
++	uint32_t type = utf8d[byte];
++
++	*codep = (*state != UTF8_ACCEPT) ?
++		(byte & 0x3fu) | (*codep << 6) :
++		(0xff >> type) & (byte);
++
++	*state = utf8d[256 + *state + type];
++	return *state;
++}
++
++static int
++drwl_init(void)
++{
++	fcft_set_scaling_filter(FCFT_SCALING_FILTER_LANCZOS3);
++	return fcft_init(FCFT_LOG_COLORIZE_AUTO, 0, FCFT_LOG_CLASS_ERROR);
++}
++
++static Drwl *
++drwl_create(void)
++{
++	Drwl *drwl;
++
++	if (!(drwl = calloc(1, sizeof(Drwl))))
++		return NULL;
++
++	return drwl;
++}
++
++static void
++drwl_setfont(Drwl *drwl, Fnt *font)
++{
++	if (drwl)
++		drwl->font = font;
++}
++
++static void
++drwl_setimage(Drwl *drwl, Img *image)
++{
++	if (drwl)
++		drwl->image = image;
++}
++
++static Fnt *
++drwl_font_create(Drwl *drwl, size_t count,
++		const char *names[static count], const char *attributes)
++{
++	Fnt *font = fcft_from_name(count, names, attributes);
++	if (drwl)
++		drwl_setfont(drwl, font);
++	return font;
++}
++
++static void
++drwl_font_destroy(Fnt *font)
++{
++	fcft_destroy(font);
++}
++
++static inline pixman_color_t
++convert_color(uint32_t clr)
++{
++	return (pixman_color_t){
++		((clr >> 24) & 0xFF) * 0x101 * (clr & 0xFF) / 0xFF,
++		((clr >> 16) & 0xFF) * 0x101 * (clr & 0xFF) / 0xFF,
++		((clr >> 8) & 0xFF) * 0x101 * (clr & 0xFF) / 0xFF,
++		(clr & 0xFF) * 0x101
++	};
++}
++
++static void
++drwl_setscheme(Drwl *drwl, uint32_t *scm)
++{
++	if (drwl)
++		drwl->scheme = scm;
++}
++
++static Img *
++drwl_image_create(Drwl *drwl, unsigned int w, unsigned int h, uint32_t *bits)
++{
++	Img *image;
++	pixman_region32_t clip;
++
++	image = pixman_image_create_bits_no_clear(
++		PIXMAN_a8r8g8b8, w, h, bits, w * 4);
++	if (!image)
++		return NULL;
++	pixman_region32_init_rect(&clip, 0, 0, w, h);
++	pixman_image_set_clip_region32(image, &clip);
++	pixman_region32_fini(&clip);
++
++	if (drwl)
++		drwl_setimage(drwl, image);
++	return image;
++}
++
++static void
++drwl_rect(Drwl *drwl,
++		int x, int y, unsigned int w, unsigned int h,
++		int filled, int invert)
++{
++	pixman_color_t clr;
++	if (!drwl || !drwl->scheme || !drwl->image)
++		return;
++
++	clr = convert_color(drwl->scheme[invert ? ColBg : ColFg]);
++	if (filled)
++		pixman_image_fill_rectangles(PIXMAN_OP_SRC, drwl->image, &clr, 1,
++			&(pixman_rectangle16_t){x, y, w, h});
++	else
++		pixman_image_fill_rectangles(PIXMAN_OP_SRC, drwl->image, &clr, 4,
++			(pixman_rectangle16_t[4]){
++				{ x,         y,         w, 1 },
++				{ x,         y + h - 1, w, 1 },
++				{ x,         y,         1, h },
++				{ x + w - 1, y,         1, h }});
++}
++
++static int
++drwl_text(Drwl *drwl,
++		int x, int y, unsigned int w, unsigned int h,
++		unsigned int lpad, const char *text, int invert)
++{
++	int ty;
++	int render = x || y || w || h;
++	long x_kern;
++	uint32_t cp = 0, last_cp = 0, state;
++	pixman_color_t clr;
++	pixman_image_t *fg_pix = NULL;
++	int noellipsis = 0;
++	const struct fcft_glyph *glyph, *eg = NULL;
++	int fcft_subpixel_mode = FCFT_SUBPIXEL_DEFAULT;
++
++	if (!drwl || (render && (!drwl->scheme || !w || !drwl->image)) || !text || !drwl->font)
++		return 0;
++
++	if (!render) {
++		w = invert ? invert : ~invert;
++	} else {
++		clr = convert_color(drwl->scheme[invert ? ColBg : ColFg]);
++		fg_pix = pixman_image_create_solid_fill(&clr);
++
++		drwl_rect(drwl, x, y, w, h, 1, !invert);
++
++		x += lpad;
++		w -= lpad;
++	}
++
++	if (render && (drwl->scheme[ColBg] & 0xFF) != 0xFF)
++		fcft_subpixel_mode = FCFT_SUBPIXEL_NONE;
++
++	if (render)
++		eg = fcft_rasterize_char_utf32(drwl->font, 0x2026 /* â€¦ */, fcft_subpixel_mode);
++
++	for (const char *p = text, *pp; pp = p, *p; p++) {
++		for (state = UTF8_ACCEPT; *p &&
++		     utf8decode(&state, &cp, *p) > UTF8_REJECT; p++)
++			;
++		if (!*p || state == UTF8_REJECT) {
++			cp = UTF8_INVALID;
++			if (p > pp)
++				p--;
++		}
++
++		glyph = fcft_rasterize_char_utf32(drwl->font, cp, fcft_subpixel_mode);
++		if (!glyph)
++			continue;
++
++		x_kern = 0;
++		if (last_cp)
++			fcft_kerning(drwl->font, last_cp, cp, &x_kern, NULL);
++		last_cp = cp;
++
++		ty = y + (h - drwl->font->height) / 2 + drwl->font->ascent;
++
++		if (render && !noellipsis && x_kern + glyph->advance.x + eg->advance.x > w &&
++		    *(p + 1) != '\0') {
++			/* cannot fit ellipsis after current codepoint */
++			if (drwl_text(drwl, 0, 0, 0, 0, 0, pp, 0) + x_kern <= w) {
++				noellipsis = 1;
++			} else {
++				w -= eg->advance.x;
++				pixman_image_composite32(
++					PIXMAN_OP_OVER, fg_pix, eg->pix, drwl->image, 0, 0, 0, 0,
++					x + eg->x, ty - eg->y, eg->width, eg->height);
++			}
++		}
++
++		if ((x_kern + glyph->advance.x) > w)
++			break;
++
++		x += x_kern;
++
++		if (render && pixman_image_get_format(glyph->pix) == PIXMAN_a8r8g8b8)
++			/* pre-rendered glyphs (eg. emoji) */
++			pixman_image_composite32(
++				PIXMAN_OP_OVER, glyph->pix, NULL, drwl->image, 0, 0, 0, 0,
++				x + glyph->x, ty - glyph->y, glyph->width, glyph->height);
++		else if (render)
++			pixman_image_composite32(
++				PIXMAN_OP_OVER, fg_pix, glyph->pix, drwl->image, 0, 0, 0, 0,
++				x + glyph->x, ty - glyph->y, glyph->width, glyph->height);
++
++		x += glyph->advance.x;
++		w -= glyph->advance.x;
++	}
++
++	if (render)
++		pixman_image_unref(fg_pix);
++
++	return x + (render ? w : 0);
++}
++
++static unsigned int
++drwl_font_getwidth(Drwl *drwl, const char *text)
++{
++	if (!drwl || !drwl->font || !text)
++		return 0;
++	return drwl_text(drwl, 0, 0, 0, 0, 0, text, 0);
++}
++
++static void
++drwl_image_destroy(Img *image)
++{
++	pixman_image_unref(image);
++}
++
++static void
++drwl_destroy(Drwl *drwl)
++{
++	if (drwl->font)
++		drwl_font_destroy(drwl->font);
++	if (drwl->image)
++		drwl_image_destroy(drwl->image);
++	free(drwl);
++}
++
++static void
++drwl_fini(void)
++{
++	fcft_fini();
++}
+diff --git a/dwl.c b/dwl.c
+index a2711f6..ece537a 100644
+--- a/dwl.c
++++ b/dwl.c
+@@ -5,6 +5,7 @@
+ #include <libinput.h>
+ #include <linux/input-event-codes.h>
+ #include <math.h>
++#include <libdrm/drm_fourcc.h>
+ #include <signal.h>
+ #include <stdio.h>
+ #include <stdlib.h>
+@@ -58,6 +59,7 @@
+ #include <wlr/types/wlr_xdg_decoration_v1.h>
+ #include <wlr/types/wlr_xdg_output_v1.h>
+ #include <wlr/types/wlr_xdg_shell.h>
++#include <wlr/interfaces/wlr_buffer.h>
+ #include <wlr/util/log.h>
+ #include <wlr/util/region.h>
+ #include <xkbcommon/xkbcommon.h>
+@@ -68,6 +70,7 @@
+ #endif
+ 
+ #include "util.h"
++#include "drwl.h"
+ 
+ /* macros */
+ #define MAX(A, B)               ((A) > (B) ? (A) : (B))
+@@ -76,14 +79,17 @@
+ #define VISIBLEON(C, M)         ((M) && (C)->mon == (M) && ((C)->tags & (M)->tagset[(M)->seltags]))
+ #define LENGTH(X)               (sizeof X / sizeof X[0])
+ #define END(A)                  ((A) + LENGTH(A))
+-#define TAGMASK                 ((1u << TAGCOUNT) - 1)
++#define TAGMASK                 ((1u << LENGTH(tags)) - 1)
+ #define LISTEN(E, L, H)         wl_signal_add((E), ((L)->notify = (H), (L)))
+ #define LISTEN_STATIC(E, H)     do { static struct wl_listener _l = {.notify = (H)}; wl_signal_add((E), &_l); } while (0)
++#define TEXTW(mon, text)        (drwl_font_getwidth(mon->drw, text) + mon->lrpad)
+ 
+ /* enums */
++enum { SchemeNorm, SchemeSel, SchemeUrg }; /* color schemes */
+ enum { CurNormal, CurPressed, CurMove, CurResize }; /* cursor */
+ enum { XDGShell, LayerShell, X11 }; /* client types */
+ enum { LyrBg, LyrBottom, LyrTile, LyrFloat, LyrTop, LyrFS, LyrOverlay, LyrBlock, NUM_LAYERS }; /* scene layers */
++enum { ClkTagBar, ClkLtSymbol, ClkStatus, ClkTitle, ClkClient, ClkRoot }; /* clicks */
+ #ifdef XWAYLAND
+ enum { NetWMWindowTypeDialog, NetWMWindowTypeSplash, NetWMWindowTypeToolbar,
+ 	NetWMWindowTypeUtility, NetLast }; /* EWMH atoms */
+@@ -97,6 +103,7 @@ typedef union {
+ } Arg;
+ 
+ typedef struct {
++	unsigned int click;
+ 	unsigned int mod;
+ 	unsigned int button;
+ 	void (*func)(const Arg *);
+@@ -186,10 +193,19 @@ typedef struct {
+ 	void (*arrange)(Monitor *);
+ } Layout;
+ 
++typedef struct {
++	struct wlr_buffer base;
++	struct wl_listener release;
++	bool busy;
++	Img *image;
++	uint32_t data[];
++} Buffer;
++
+ struct Monitor {
+ 	struct wl_list link;
+ 	struct wlr_output *wlr_output;
+ 	struct wlr_scene_output *scene_output;
++	struct wlr_scene_buffer *scene_buffer; /* bar buffer */
+ 	struct wlr_scene_rect *fullscreen_bg; /* See createmon() for info */
+ 	struct wl_listener frame;
+ 	struct wl_listener destroy;
+@@ -197,6 +213,11 @@ struct Monitor {
+ 	struct wl_listener destroy_lock_surface;
+ 	struct wlr_session_lock_surface_v1 *lock_surface;
+ 	struct wlr_box m; /* monitor area, layout-relative */
++	struct {
++		int width, height;
++		int real_width, real_height; /* non-scaled */
++		float scale;
++	} b; /* bar area */
+ 	struct wlr_box w; /* window area, layout-relative */
+ 	struct wl_list layers[4]; /* LayerSurface.link */
+ 	const Layout *lt[2];
+@@ -208,6 +229,9 @@ struct Monitor {
+ 	int nmaster;
+ 	char ltsymbol[16];
+ 	int asleep;
++	Drwl *drw;
++	Buffer *pool[2];
++	int lrpad;
+ };
+ 
+ typedef struct {
+@@ -250,6 +274,13 @@ static void arrangelayer(Monitor *m, struct wl_list *list,
+ 		struct wlr_box *usable_area, int exclusive);
+ static void arrangelayers(Monitor *m);
+ static void axisnotify(struct wl_listener *listener, void *data);
++static bool baracceptsinput(struct wlr_scene_buffer *buffer, double *sx, double *sy);
++static void bufdestroy(struct wlr_buffer *buffer);
++static bool bufdatabegin(struct wlr_buffer *buffer, uint32_t flags,
++		void **data, uint32_t *format, size_t *stride);
++static void bufdataend(struct wlr_buffer *buffer);
++static Buffer *bufmon(Monitor *m);
++static void bufrelease(struct wl_listener *listener, void *data);
+ static void buttonpress(struct wl_listener *listener, void *data);
+ static void chvt(const Arg *arg);
+ static void checkidleinhibitor(struct wlr_surface *exclude);
+@@ -285,6 +316,8 @@ static void destroysessionlock(struct wl_listener *listener, void *data);
+ static void destroysessionmgr(struct wl_listener *listener, void *data);
+ static void destroykeyboardgroup(struct wl_listener *listener, void *data);
+ static Monitor *dirtomon(enum wlr_direction dir);
++static void drawbar(Monitor *m);
++static void drawbars(void);
+ static void focusclient(Client *c, int lift);
+ static void focusmon(const Arg *arg);
+ static void focusstack(const Arg *arg);
+@@ -313,7 +346,6 @@ static void outputmgrapplyortest(struct wlr_output_configuration_v1 *config, int
+ static void outputmgrtest(struct wl_listener *listener, void *data);
+ static void pointerfocus(Client *c, struct wlr_surface *surface,
+ 		double sx, double sy, uint32_t time);
+-static void printstatus(void);
+ static void powermgrsetmode(struct wl_listener *listener, void *data);
+ static void quit(const Arg *arg);
+ static void rendermon(struct wl_listener *listener, void *data);
+@@ -335,9 +367,11 @@ static void setsel(struct wl_listener *listener, void *data);
+ static void setup(void);
+ static void spawn(const Arg *arg);
+ static void startdrag(struct wl_listener *listener, void *data);
++static int statusin(int fd, unsigned int mask, void *data);
+ static void tag(const Arg *arg);
+ static void tagmon(const Arg *arg);
+ static void tile(Monitor *m);
++static void togglebar(const Arg *arg);
+ static void togglefloating(const Arg *arg);
+ static void togglefullscreen(const Arg *arg);
+ static void toggletag(const Arg *arg);
+@@ -346,6 +380,7 @@ static void unlocksession(struct wl_listener *listener, void *data);
+ static void unmaplayersurfacenotify(struct wl_listener *listener, void *data);
+ static void unmapnotify(struct wl_listener *listener, void *data);
+ static void updatemons(struct wl_listener *listener, void *data);
++static void updatebar(Monitor *m);
+ static void updatetitle(struct wl_listener *listener, void *data);
+ static void urgent(struct wl_listener *listener, void *data);
+ static void view(const Arg *arg);
+@@ -413,6 +448,15 @@ static struct wlr_box sgeom;
+ static struct wl_list mons;
+ static Monitor *selmon;
+ 
++static char stext[256];
++static struct wl_event_source *status_event_source;
++
++static const struct wlr_buffer_impl buffer_impl = {
++    .destroy = bufdestroy,
++    .begin_data_ptr_access = bufdatabegin,
++    .end_data_ptr_access = bufdataend,
++};
++
+ #ifdef XWAYLAND
+ static void activatex11(struct wl_listener *listener, void *data);
+ static void associatex11(struct wl_listener *listener, void *data);
+@@ -553,6 +597,11 @@ arrangelayers(Monitor *m)
+ 	if (!m->wlr_output->enabled)
+ 		return;
+ 
++	if (m->scene_buffer->node.enabled) {
++		usable_area.height -= m->b.real_height;
++		usable_area.y += topbar ? m->b.real_height : 0;
++	}
++
+ 	/* Arrange exclusive surfaces from top->bottom */
+ 	for (i = 3; i >= 0; i--)
+ 		arrangelayer(m, &m->layers[i], &usable_area, 1);
+@@ -595,17 +644,102 @@ axisnotify(struct wl_listener *listener, void *data)
+ 			event->delta_discrete, event->source, event->relative_direction);
+ }
+ 
++bool
++baracceptsinput(struct wlr_scene_buffer *buffer, double *sx, double *sy)
++{
++	return true;
++}
++
++void
++bufdestroy(struct wlr_buffer *wlr_buffer)
++{
++	Buffer *buf = wl_container_of(wlr_buffer, buf, base);
++	if (buf->busy)
++		wl_list_remove(&buf->release.link);
++	drwl_image_destroy(buf->image);
++	free(buf);
++}
++
++bool
++bufdatabegin(struct wlr_buffer *wlr_buffer, uint32_t flags,
++		void **data, uint32_t *format, size_t *stride)
++{
++	Buffer *buf = wl_container_of(wlr_buffer, buf, base);
++
++	if (flags & WLR_BUFFER_DATA_PTR_ACCESS_WRITE) return false;
++
++	*data   = buf->data;
++	*stride = wlr_buffer->width * 4;
++	*format = DRM_FORMAT_ARGB8888;
++
++	return true;
++}
++
++void
++bufdataend(struct wlr_buffer *wlr_buffer)
++{
++}
++
++Buffer *
++bufmon(Monitor *m)
++{
++	size_t i;
++	Buffer *buf = NULL;
++
++	for (i = 0; i < LENGTH(m->pool); i++) {
++		if (m->pool[i]) {
++			if (m->pool[i]->busy)
++				continue;
++			buf = m->pool[i];
++			break;
++		}
++
++		buf = ecalloc(1, sizeof(Buffer) + (m->b.width * 4 * m->b.height));
++		buf->image = drwl_image_create(NULL, m->b.width, m->b.height, buf->data);
++		wlr_buffer_init(&buf->base, &buffer_impl, m->b.width, m->b.height);
++		m->pool[i] = buf;
++		break;
++	}
++	if (!buf)
++		return NULL;
++
++	buf->busy = true;
++	LISTEN(&buf->base.events.release, &buf->release, bufrelease);
++	wlr_buffer_lock(&buf->base);
++	drwl_setimage(m->drw, buf->image);
++	return buf;
++}
++
++void
++bufrelease(struct wl_listener *listener, void *data)
++{
++	Buffer *buf = wl_container_of(listener, buf, release);
++	buf->busy = false;
++	wl_list_remove(&buf->release.link);
++}
++
+ void
+ buttonpress(struct wl_listener *listener, void *data)
+ {
++	unsigned int i = 0, x = 0;
++	double cx;
++	unsigned int click;
+ 	struct wlr_pointer_button_event *event = data;
+ 	struct wlr_keyboard *keyboard;
++	struct wlr_scene_node *node;
++	struct wlr_scene_buffer *buffer;
+ 	uint32_t mods;
++	Arg arg = {0};
+ 	Client *c;
+ 	const Button *b;
+ 
+ 	wlr_idle_notifier_v1_notify_activity(idle_notifier, seat);
+ 
++	click = ClkRoot;
++	xytonode(cursor->x, cursor->y, NULL, &c, NULL, NULL, NULL);
++	if (c)
++		click = ClkClient;
++
+ 	switch (event->state) {
+ 	case WL_POINTER_BUTTON_STATE_PRESSED:
+ 		cursor_mode = CurPressed;
+@@ -613,17 +747,34 @@ buttonpress(struct wl_listener *listener, void *data)
+ 		if (locked)
+ 			break;
+ 
++		if (!c && !exclusive_focus &&
++			(node = wlr_scene_node_at(&layers[LyrBottom]->node, cursor->x, cursor->y, NULL, NULL)) &&
++			(buffer = wlr_scene_buffer_from_node(node)) && buffer == selmon->scene_buffer) {
++			cx = (cursor->x - selmon->m.x) * selmon->wlr_output->scale;
++			do
++				x += TEXTW(selmon, tags[i]);
++			while (cx >= x && ++i < LENGTH(tags));
++			if (i < LENGTH(tags)) {
++				click = ClkTagBar;
++				arg.ui = 1 << i;
++			} else if (cx < x + TEXTW(selmon, selmon->ltsymbol))
++				click = ClkLtSymbol;
++			else if (cx > selmon->b.width - (TEXTW(selmon, stext) - selmon->lrpad + 2)) {
++				click = ClkStatus;
++			} else
++				click = ClkTitle;
++		}
++
+ 		/* Change focus if the button was _pressed_ over a client */
+ 		xytonode(cursor->x, cursor->y, NULL, &c, NULL, NULL, NULL);
+-		if (c && (!client_is_unmanaged(c) || client_wants_focus(c)))
++		if (click == ClkClient && (!client_is_unmanaged(c) || client_wants_focus(c)))
+ 			focusclient(c, 1);
+ 
+ 		keyboard = wlr_seat_get_keyboard(seat);
+ 		mods = keyboard ? wlr_keyboard_get_modifiers(keyboard) : 0;
+ 		for (b = buttons; b < END(buttons); b++) {
+-			if (CLEANMASK(mods) == CLEANMASK(b->mod) &&
+-					event->button == b->button && b->func) {
+-				b->func(&b->arg);
++			if (CLEANMASK(mods) == CLEANMASK(b->mod) && event->button == b->button && click == b->click && b->func) {
++				b->func(click == ClkTagBar && b->arg.i == 0 ? &arg : &b->arg);
+ 				return;
+ 			}
+ 		}
+@@ -697,6 +848,8 @@ cleanup(void)
+ 	/* Destroy after the wayland display (when the monitors are already destroyed)
+ 	   to avoid destroying them with an invalid scene output. */
+ 	wlr_scene_node_destroy(&scene->tree.node);
++
++	drwl_fini();
+ }
+ 
+ void
+@@ -712,6 +865,12 @@ cleanupmon(struct wl_listener *listener, void *data)
+ 			wlr_layer_surface_v1_destroy(l->layer_surface);
+ 	}
+ 
++	for (i = 0; i < LENGTH(m->pool); i++)
++		wlr_buffer_drop(&m->pool[i]->base);
++
++	drwl_setimage(m->drw, NULL);
++	drwl_destroy(m->drw);
++
+ 	wl_list_remove(&m->destroy.link);
+ 	wl_list_remove(&m->frame.link);
+ 	wl_list_remove(&m->link);
+@@ -722,6 +881,7 @@ cleanupmon(struct wl_listener *listener, void *data)
+ 
+ 	closemon(m);
+ 	wlr_scene_node_destroy(&m->fullscreen_bg->node);
++	wlr_scene_node_destroy(&m->scene_buffer->node);
+ 	free(m);
+ }
+ 
+@@ -751,7 +911,7 @@ closemon(Monitor *m)
+ 			setmon(c, selmon, c->tags);
+ 	}
+ 	focusclient(focustop(selmon), 1);
+-	printstatus();
++	drawbars();
+ }
+ 
+ void
+@@ -1022,8 +1182,15 @@ createmon(struct wl_listener *listener, void *data)
+ 	wlr_output_commit_state(wlr_output, &state);
+ 	wlr_output_state_finish(&state);
+ 
++	if (!(m->drw = drwl_create()))
++		die("failed to create drwl context");
++
++	m->scene_buffer = wlr_scene_buffer_create(layers[LyrBottom], NULL);
++	m->scene_buffer->point_accepts_input = baracceptsinput;
++	updatebar(m);
++
+ 	wl_list_insert(&mons, &m->link);
+-	printstatus();
++	drawbars();
+ 
+ 	/* The xdg-protocol specifies:
+ 	 *
+@@ -1336,6 +1503,80 @@ dirtomon(enum wlr_direction dir)
+ 	return selmon;
+ }
+ 
++void
++drawbar(Monitor *m)
++{
++	int x, w, tw = 0;
++	int boxs = m->drw->font->height / 9;
++	int boxw = m->drw->font->height / 6 + 2;
++	uint32_t i, occ = 0, urg = 0;
++	Client *c;
++	Buffer *buf;
++
++	if (!m->scene_buffer->node.enabled)
++		return;
++	if (!(buf = bufmon(m)))
++		return;
++
++	/* draw status first so it can be overdrawn by tags later */
++	if (m == selmon) { /* status is only drawn on selected monitor */
++		drwl_setscheme(m->drw, colors[SchemeSel]);
++		tw = TEXTW(m, stext) - m->lrpad + 2; /* 2px right padding */
++		drwl_text(m->drw, m->b.width - tw, 0, tw, m->b.height, 0, stext, 0);
++	}
++
++	wl_list_for_each(c, &clients, link) {
++		if (c->mon != m)
++			continue;
++		occ |= c->tags;
++		if (c->isurgent)
++			urg |= c->tags;
++	}
++	x = 0;
++	c = focustop(m);
++	for (i = 0; i < LENGTH(tags); i++) {
++		w = TEXTW(m, tags[i]);
++		drwl_setscheme(m->drw, colors[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
++		drwl_text(m->drw, x, 0, w, m->b.height, m->lrpad / 2, tags[i], urg & 1 << i);
++		if (occ & 1 << i)
++			drwl_rect(m->drw, x + boxs, boxs, boxw, boxw,
++				m == selmon && c && c->tags & 1 << i,
++				urg & 1 << i);
++		x += w;
++	}
++	w = TEXTW(m, m->ltsymbol);
++	drwl_setscheme(m->drw, colors[SchemeNorm]);
++	x = drwl_text(m->drw, x, 0, w, m->b.height, m->lrpad / 2, m->ltsymbol, 0);
++
++	if ((w = m->b.width - tw - x) > m->b.height) {
++		if (c && m == selmon) {
++			drwl_setscheme(m->drw, colors[SchemeNorm]);
++			drwl_text(m->drw, x, 0, w, m->b.height, m->lrpad / 2, client_get_title(c), 0);
++			if (c && c->isfloating)
++				drwl_rect(m->drw, x + boxs, boxs, boxw, boxw, 0, 0);
++		} else {
++			drwl_setscheme(m->drw, colors[SchemeNorm]);
++			drwl_rect(m->drw, x, 0, w, m->b.height, 1, 1);
++		}
++	}
++
++	wlr_scene_buffer_set_dest_size(m->scene_buffer,
++		m->b.real_width, m->b.real_height);
++	wlr_scene_node_set_position(&m->scene_buffer->node, m->m.x,
++		m->m.y + (topbar ? 0 : m->m.height - m->b.real_height));
++	wlr_scene_buffer_set_buffer(m->scene_buffer, &buf->base);
++	wlr_buffer_unlock(&buf->base);
++}
++
++void
++drawbars(void)
++{
++	Monitor *m = NULL;
++
++	wl_list_for_each(m, &mons, link)
++		drawbar(m);
++}
++
+ void
+ focusclient(Client *c, int lift)
+ {
+@@ -1371,13 +1612,13 @@ focusclient(Client *c, int lift)
+ 		/* Don't change border color if there is an exclusive focus or we are
+ 		 * handling a drag operation */
+ 		if (!exclusive_focus && !seat->drag)
+-			client_set_border_color(c, focuscolor);
++			client_set_border_color(c, (float[])COLOR(colors[SchemeSel][ColBorder]));
+ 	}
+ 
+ 	/* Deactivate old client if focus is changing */
+ 	if (old && (!c || client_surface(c) != old)) {
+ 		/* If an overlay is focused, don't focus or activate the client,
+-		 * but only update its position in fstack to render its border with focuscolor
++		 * but only update its position in fstack to render its border with its color
+ 		 * and focus it after the overlay is closed. */
+ 		if (old_client_type == LayerShell && wlr_scene_node_coords(
+ 					&old_l->scene->node, &unused_lx, &unused_ly)
+@@ -1388,12 +1629,11 @@ focusclient(Client *c, int lift)
+ 		/* Don't deactivate old client if the new one wants focus, as this causes issues with winecfg
+ 		 * and probably other clients */
+ 		} else if (old_c && !client_is_unmanaged(old_c) && (!c || !client_wants_focus(c))) {
+-			client_set_border_color(old_c, bordercolor);
+-
++			client_set_border_color(old_c, (float[])COLOR(colors[SchemeNorm][ColBorder]));
+ 			client_activate_surface(old, 0);
+ 		}
+ 	}
+-	printstatus();
++	drawbars();
+ 
+ 	if (!c) {
+ 		/* With no client, all we have left is to clear focus */
+@@ -1715,7 +1955,7 @@ mapnotify(struct wl_listener *listener, void *data)
+ 
+ 	for (i = 0; i < 4; i++) {
+ 		c->border[i] = wlr_scene_rect_create(c->scene, 0, 0,
+-				c->isurgent ? urgentcolor : bordercolor);
++			(float[])COLOR(colors[c->isurgent ? SchemeUrg : SchemeNorm][ColBorder]));
+ 		c->border[i]->node.data = c;
+ 	}
+ 
+@@ -1738,7 +1978,7 @@ mapnotify(struct wl_listener *listener, void *data)
+ 	} else {
+ 		applyrules(c);
+ 	}
+-	printstatus();
++	drawbars();
+ 
+ unset_fullscreen:
+ 	m = c->mon ? c->mon : xytomon(c->geom.x, c->geom.y);
+@@ -2032,46 +2272,6 @@ pointerfocus(Client *c, struct wlr_surface *surface, double sx, double sy,
+ 	wlr_seat_pointer_notify_motion(seat, time, sx, sy);
+ }
+ 
+-void
+-printstatus(void)
+-{
+-	Monitor *m = NULL;
+-	Client *c;
+-	uint32_t occ, urg, sel;
+-	const char *appid, *title;
+-
+-	wl_list_for_each(m, &mons, link) {
+-		occ = urg = 0;
+-		wl_list_for_each(c, &clients, link) {
+-			if (c->mon != m)
+-				continue;
+-			occ |= c->tags;
+-			if (c->isurgent)
+-				urg |= c->tags;
+-		}
+-		if ((c = focustop(m))) {
+-			title = client_get_title(c);
+-			appid = client_get_appid(c);
+-			printf("%s title %s\n", m->wlr_output->name, title ? title : broken);
+-			printf("%s appid %s\n", m->wlr_output->name, appid ? appid : broken);
+-			printf("%s fullscreen %d\n", m->wlr_output->name, c->isfullscreen);
+-			printf("%s floating %d\n", m->wlr_output->name, c->isfloating);
+-			sel = c->tags;
+-		} else {
+-			printf("%s title \n", m->wlr_output->name);
+-			printf("%s appid \n", m->wlr_output->name);
+-			printf("%s fullscreen \n", m->wlr_output->name);
+-			printf("%s floating \n", m->wlr_output->name);
+-			sel = 0;
+-		}
+-
+-		printf("%s selmon %u\n", m->wlr_output->name, m == selmon);
+-		printf("%s tags %"PRIu32" %"PRIu32" %"PRIu32" %"PRIu32"\n",
+-			m->wlr_output->name, occ, m->tagset[m->seltags], sel, urg);
+-		printf("%s layout %s\n", m->wlr_output->name, m->ltsymbol);
+-	}
+-	fflush(stdout);
+-}
+ 
+ void
+ powermgrsetmode(struct wl_listener *listener, void *data)
+@@ -2226,30 +2426,17 @@ run(char *startup_cmd)
+ 
+ 	/* Now that the socket exists and the backend is started, run the startup command */
+ 	if (startup_cmd) {
+-		int piperw[2];
+-		if (pipe(piperw) < 0)
+-			die("startup: pipe:");
+ 		if ((child_pid = fork()) < 0)
+ 			die("startup: fork:");
+ 		if (child_pid == 0) {
++			close(STDIN_FILENO);
+ 			setsid();
+-			dup2(piperw[0], STDIN_FILENO);
+-			close(piperw[0]);
+-			close(piperw[1]);
+ 			execl("/bin/sh", "/bin/sh", "-c", startup_cmd, NULL);
+ 			die("startup: execl:");
+ 		}
+-		dup2(piperw[1], STDOUT_FILENO);
+-		close(piperw[1]);
+-		close(piperw[0]);
+ 	}
+ 
+-	/* Mark stdout as non-blocking to avoid people who does not close stdin
+-	 * nor consumes it in their startup script getting dwl frozen */
+-	if (fd_set_nonblock(STDOUT_FILENO) < 0)
+-		close(STDOUT_FILENO);
+-
+-	printstatus();
++	drawbars();
+ 
+ 	/* At this point the outputs are initialized, choose initial selmon based on
+ 	 * cursor position, and set default cursor image */
+@@ -2315,7 +2502,7 @@ setfloating(Client *c, int floating)
+ 			(p && p->isfullscreen) ? LyrFS
+ 			: c->isfloating ? LyrFloat : LyrTile]);
+ 	arrange(c->mon);
+-	printstatus();
++	drawbars();
+ }
+ 
+ void
+@@ -2338,7 +2525,7 @@ setfullscreen(Client *c, int fullscreen)
+ 		resize(c, c->prev, 0);
+ 	}
+ 	arrange(c->mon);
+-	printstatus();
++	drawbars();
+ }
+ 
+ void
+@@ -2363,7 +2550,7 @@ setlayout(const Arg *arg)
+ 		selmon->lt[selmon->sellt] = (Layout *)arg->v;
+ 	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, LENGTH(selmon->ltsymbol));
+ 	arrange(selmon);
+-	printstatus();
++	drawbar(selmon);
+ }
+ 
+ /* arg > 1.0 will set mfact absolutely */
+@@ -2436,6 +2623,7 @@ setup(void)
+ 	for (i = 0; i < (int)LENGTH(sig); i++)
+ 		sigaction(sig[i], &sa, NULL);
+ 
++
+ 	wlr_log_init(log_level, NULL);
+ 
+ 	/* The Wayland display is managed by libwayland. It handles accepting
+@@ -2625,6 +2813,11 @@ setup(void)
+ 	LISTEN_STATIC(&output_mgr->events.apply, outputmgrapply);
+ 	LISTEN_STATIC(&output_mgr->events.test, outputmgrtest);
+ 
++	drwl_init();
++
++	status_event_source = wl_event_loop_add_fd(wl_display_get_event_loop(dpy),
++		STDIN_FILENO, WL_EVENT_READABLE, statusin, NULL);
++
+ 	/* Make sure XWayland clients don't connect to the parent X server,
+ 	 * e.g when running in the x11 backend or the wayland backend and the
+ 	 * compositor has Xwayland support */
+@@ -2649,6 +2842,7 @@ void
+ spawn(const Arg *arg)
+ {
+ 	if (fork() == 0) {
++		close(STDIN_FILENO);
+ 		dup2(STDERR_FILENO, STDOUT_FILENO);
+ 		setsid();
+ 		execvp(((char **)arg->v)[0], (char **)arg->v);
+@@ -2667,6 +2861,30 @@ startdrag(struct wl_listener *listener, void *data)
+ 	LISTEN_STATIC(&drag->icon->events.destroy, destroydragicon);
+ }
+ 
++int
++statusin(int fd, unsigned int mask, void *data)
++{
++	char status[1024];
++	ssize_t n;
++
++	if (mask & WL_EVENT_ERROR)
++		die("status in event error");
++	if (mask & WL_EVENT_HANGUP)
++		wl_event_source_remove(status_event_source);
++
++	n = read(fd, status, sizeof(status) - 1);
++	if (n < 0 && errno != EWOULDBLOCK)
++		die("read:");
++
++	status[n] = '\0';
++	status[strcspn(status, "\n")] = '\0';
++
++	strncpy(stext, status, sizeof(stext));
++	drawbars();
++
++	return 0;
++}
++
+ void
+ tag(const Arg *arg)
+ {
+@@ -2677,7 +2895,7 @@ tag(const Arg *arg)
+ 	sel->tags = arg->ui & TAGMASK;
+ 	focusclient(focustop(selmon), 1);
+ 	arrange(selmon);
+-	printstatus();
++	drawbars();
+ }
+ 
+ void
+@@ -2722,6 +2940,14 @@ tile(Monitor *m)
+ 	}
+ }
+ 
++void
++togglebar(const Arg *arg)
++{
++	wlr_scene_node_set_enabled(&selmon->scene_buffer->node,
++		!selmon->scene_buffer->node.enabled);
++	arrangelayers(selmon);
++}
++
+ void
+ togglefloating(const Arg *arg)
+ {
+@@ -2750,7 +2976,7 @@ toggletag(const Arg *arg)
+ 	sel->tags = newtags;
+ 	focusclient(focustop(selmon), 1);
+ 	arrange(selmon);
+-	printstatus();
++	drawbars();
+ }
+ 
+ void
+@@ -2763,7 +2989,7 @@ toggleview(const Arg *arg)
+ 	selmon->tagset[selmon->seltags] = newtagset;
+ 	focusclient(focustop(selmon), 1);
+ 	arrange(selmon);
+-	printstatus();
++	drawbars();
+ }
+ 
+ void
+@@ -2811,7 +3037,7 @@ unmapnotify(struct wl_listener *listener, void *data)
+ 	}
+ 
+ 	wlr_scene_node_destroy(&c->scene->node);
+-	printstatus();
++	drawbars();
+ 	motionnotify(0, NULL, 0, 0, 0, 0);
+ }
+ 
+@@ -2911,6 +3137,13 @@ updatemons(struct wl_listener *listener, void *data)
+ 		}
+ 	}
+ 
++	if (stext[0] == '\0')
++		strncpy(stext, "dwl-"VERSION, sizeof(stext));
++	wl_list_for_each(m, &mons, link) {
++		updatebar(m);
++		drawbar(m);
++	}
++
+ 	/* FIXME: figure out why the cursor image is at 0,0 after turning all
+ 	 * the monitors on.
+ 	 * Move the cursor image where it used to be. It does not generate a
+@@ -2921,12 +3154,45 @@ updatemons(struct wl_listener *listener, void *data)
+ 	wlr_output_manager_v1_set_configuration(output_mgr, config);
+ }
+ 
++void
++updatebar(Monitor *m)
++{
++	size_t i;
++	int rw, rh;
++	char fontattrs[12];
++
++	wlr_output_transformed_resolution(m->wlr_output, &rw, &rh);
++	m->b.width = rw;
++	m->b.real_width = (int)((float)m->b.width / m->wlr_output->scale);
++
++	wlr_scene_node_set_enabled(&m->scene_buffer->node, m->wlr_output->enabled ? showbar : 0);
++
++	for (i = 0; i < LENGTH(m->pool); i++)
++		if (m->pool[i]) {
++			wlr_buffer_drop(&m->pool[i]->base);
++			m->pool[i] = NULL;
++		}
++
++	if (m->b.scale == m->wlr_output->scale && m->drw)
++		return;
++
++	drwl_font_destroy(m->drw->font);
++	snprintf(fontattrs, sizeof(fontattrs), "dpi=%.2f", 96. * m->wlr_output->scale);
++	if (!(drwl_font_create(m->drw, LENGTH(fonts), fonts, fontattrs)))
++		die("Could not load font");
++
++	m->b.scale = m->wlr_output->scale;
++	m->lrpad = m->drw->font->height;
++	m->b.height = m->drw->font->height + 2;
++	m->b.real_height = (int)((float)m->b.height / m->wlr_output->scale);
++}
++
+ void
+ updatetitle(struct wl_listener *listener, void *data)
+ {
+ 	Client *c = wl_container_of(listener, c, set_title);
+ 	if (c == focustop(c->mon))
+-		printstatus();
++		drawbars();
+ }
+ 
+ void
+@@ -2939,10 +3205,10 @@ urgent(struct wl_listener *listener, void *data)
+ 		return;
+ 
+ 	c->isurgent = 1;
+-	printstatus();
++	drawbars();
+ 
+ 	if (client_surface(c)->mapped)
+-		client_set_border_color(c, urgentcolor);
++		client_set_border_color(c, (float[])COLOR(colors[SchemeUrg][ColBorder]));
+ }
+ 
+ void
+@@ -2955,7 +3221,7 @@ view(const Arg *arg)
+ 		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
+ 	focusclient(focustop(selmon), 1);
+ 	arrange(selmon);
+-	printstatus();
++	drawbars();
+ }
+ 
+ void
+@@ -2996,6 +3262,7 @@ xytonode(double x, double y, struct wlr_surface **psurface,
+ {
+ 	struct wlr_scene_node *node, *pnode;
+ 	struct wlr_surface *surface = NULL;
++	struct wlr_scene_surface *scene_surface = NULL;
+ 	Client *c = NULL;
+ 	LayerSurface *l = NULL;
+ 	int layer;
+@@ -3004,9 +3271,12 @@ xytonode(double x, double y, struct wlr_surface **psurface,
+ 		if (!(node = wlr_scene_node_at(&layers[layer]->node, x, y, nx, ny)))
+ 			continue;
+ 
+-		if (node->type == WLR_SCENE_NODE_BUFFER)
+-			surface = wlr_scene_surface_try_from_buffer(
+-					wlr_scene_buffer_from_node(node))->surface;
++		if (node->type == WLR_SCENE_NODE_BUFFER) {
++			scene_surface = wlr_scene_surface_try_from_buffer(
++					wlr_scene_buffer_from_node(node));
++			if (!scene_surface) continue;
++			surface = scene_surface->surface;
++		}
+ 		/* Walk the tree to find a node that knows the client */
+ 		for (pnode = node; pnode && !c; pnode = &pnode->parent->node)
+ 			c = pnode->data;
+@@ -3145,10 +3415,10 @@ sethints(struct wl_listener *listener, void *data)
+ 		return;
+ 
+ 	c->isurgent = xcb_icccm_wm_hints_get_urgency(c->surface.xwayland->hints);
+-	printstatus();
++	drawbars();
+ 
+ 	if (c->isurgent && surface && surface->mapped)
+-		client_set_border_color(c, urgentcolor);
++		client_set_border_color(c, (float[])COLOR(colors[SchemeUrg][ColBorder]));
+ }
+ 
+ void
+-- 
+2.46.0
+
diff '--color=auto' -urN dwl/patches/barheight.patch mis_repos/dwl/patches/barheight.patch
--- dwl/patches/barheight.patch	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/patches/barheight.patch	2024-10-01 23:08:38.152977293 +0200
@@ -0,0 +1,38 @@
+From d2f3ac840845802eaf9ff7daf406f04722fd02aa Mon Sep 17 00:00:00 2001
+From: Oak <Oak@petrifiedoak.com>
+Date: Sun, 25 Aug 2024 17:43:17 +0200
+Subject: [PATCH] Implement barheight patch
+
+---
+ config.def.h | 1 +
+ dwl.c        | 2 +-
+ 2 files changed, 2 insertions(+), 1 deletion(-)
+
+diff --git a/config.def.h b/config.def.h
+index 5d1dc2b..f11089c 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -7,6 +7,7 @@
+ static const int sloppyfocus               = 1;  /* focus follows mouse */
+ static const int bypass_surface_visibility = 0;  /* 1 means idle inhibitors will disable idle tracking even if it's surface isn't visible  */
+ static const unsigned int borderpx         = 1;  /* border pixel of windows */
++static const int user_bh		   = 30; /* 0 means that dwl will calculate barheight, >= 1 means dwl will use user_bh as the bar height. */
+ static const int showbar                   = 1; /* 0 means no bar */
+ static const int topbar                    = 1; /* 0 means bottom bar */
+ static const char *fonts[]                 = {"monospace:size=10"};
+diff --git a/dwl.c b/dwl.c
+index ece537a..2863202 100644
+--- a/dwl.c
++++ b/dwl.c
+@@ -3183,7 +3183,7 @@ updatebar(Monitor *m)
+ 
+ 	m->b.scale = m->wlr_output->scale;
+ 	m->lrpad = m->drw->font->height;
+-	m->b.height = m->drw->font->height + 2;
++	m->b.height = user_bh ? user_bh :  m->drw->font->height + 2;
+ 	m->b.real_height = (int)((float)m->b.height / m->wlr_output->scale);
+ }
+ 
+-- 
+2.46.0
+
diff '--color=auto' -urN dwl/patches/gaps.patch mis_repos/dwl/patches/gaps.patch
--- dwl/patches/gaps.patch	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/patches/gaps.patch	2024-10-01 23:08:38.152977293 +0200
@@ -0,0 +1,127 @@
+From 50e3dd4746b6cb719efb9f8213b94ac52a5320d9 Mon Sep 17 00:00:00 2001
+From: peesock <kcormn@gmail.com>
+Date: Mon, 24 Jun 2024 20:06:42 -0700
+Subject: [PATCH] gaps!
+
+Co-authored-by: sewn <sewn@disroot.org>
+Co-authored-by: serenevoid <ajuph9224@gmail.com>
+---
+ config.def.h |  4 ++++
+ dwl.c        | 34 ++++++++++++++++++++++++++--------
+ 2 files changed, 30 insertions(+), 8 deletions(-)
+
+diff --git a/config.def.h b/config.def.h
+index 22d2171..b388b4e 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -6,6 +6,9 @@
+ /* appearance */
+ static const int sloppyfocus               = 1;  /* focus follows mouse */
+ static const int bypass_surface_visibility = 0;  /* 1 means idle inhibitors will disable idle tracking even if it's surface isn't visible  */
++static const int smartgaps                 = 0;  /* 1 means no outer gap when there is only one window */
++static int gaps                            = 1;  /* 1 means gaps between windows are added */
++static const unsigned int gappx            = 10; /* gap pixel between windows */
+ static const unsigned int borderpx         = 1;  /* border pixel of windows */
+ static const float rootcolor[]             = COLOR(0x222222ff);
+ static const float bordercolor[]           = COLOR(0x444444ff);
+@@ -135,6 +138,7 @@ static const Key keys[] = {
+ 	{ MODKEY,                    XKB_KEY_l,          setmfact,       {.f = +0.05f} },
+ 	{ MODKEY,                    XKB_KEY_Return,     zoom,           {0} },
+ 	{ MODKEY,                    XKB_KEY_Tab,        view,           {0} },
++	{ MODKEY,                    XKB_KEY_g,          togglegaps,     {0} },
+ 	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_C,          killclient,     {0} },
+ 	{ MODKEY,                    XKB_KEY_t,          setlayout,      {.v = &layouts[0]} },
+ 	{ MODKEY,                    XKB_KEY_f,          setlayout,      {.v = &layouts[1]} },
+diff --git a/dwl.c b/dwl.c
+index dc0437e..dc851df 100644
+--- a/dwl.c
++++ b/dwl.c
+@@ -199,6 +199,7 @@ struct Monitor {
+ 	struct wlr_box w; /* window area, layout-relative */
+ 	struct wl_list layers[4]; /* LayerSurface.link */
+ 	const Layout *lt[2];
++	int gaps;
+ 	unsigned int seltags;
+ 	unsigned int sellt;
+ 	uint32_t tagset[2];
+@@ -336,6 +337,7 @@ static void tagmon(const Arg *arg);
+ static void tile(Monitor *m);
+ static void togglefloating(const Arg *arg);
+ static void togglefullscreen(const Arg *arg);
++static void togglegaps(const Arg *arg);
+ static void toggletag(const Arg *arg);
+ static void toggleview(const Arg *arg);
+ static void unlocksession(struct wl_listener *listener, void *data);
+@@ -949,6 +951,8 @@ createmon(struct wl_listener *listener, void *data)
+ 
+ 	wlr_output_state_init(&state);
+ 	/* Initialize monitor state using configured rules */
++	m->gaps = gaps;
++
+ 	m->tagset[0] = m->tagset[1] = 1;
+ 	for (r = monrules; r < END(monrules); r++) {
+ 		if (!r->name || strstr(wlr_output->name, r->name)) {
+@@ -2638,7 +2642,7 @@ tagmon(const Arg *arg)
+ void
+ tile(Monitor *m)
+ {
+-	unsigned int mw, my, ty;
++	unsigned int h, r, e = m->gaps, mw, my, ty;
+ 	int i, n = 0;
+ 	Client *c;
+ 
+@@ -2647,23 +2651,30 @@ tile(Monitor *m)
+ 			n++;
+ 	if (n == 0)
+ 		return;
++	if (smartgaps == n)
++		e = 0;
+ 
+ 	if (n > m->nmaster)
+-		mw = m->nmaster ? (int)roundf(m->w.width * m->mfact) : 0;
++		mw = m->nmaster ? (int)roundf((m->w.width + gappx*e) * m->mfact) : 0;
+ 	else
+ 		mw = m->w.width;
+-	i = my = ty = 0;
++	i = 0;
++	my = ty = gappx*e;
+ 	wl_list_for_each(c, &clients, link) {
+ 		if (!VISIBLEON(c, m) || c->isfloating || c->isfullscreen)
+ 			continue;
+ 		if (i < m->nmaster) {
+-			resize(c, (struct wlr_box){.x = m->w.x, .y = m->w.y + my, .width = mw,
+-				.height = (m->w.height - my) / (MIN(n, m->nmaster) - i)}, 0);
+-			my += c->geom.height;
++			r = MIN(n, m->nmaster) - i;
++			h = (m->w.height - my - gappx*e - gappx*e * (r - 1)) / r;
++			resize(c, (struct wlr_box){.x = m->w.x + gappx*e, .y = m->w.y + my,
++				.width = mw - 2*gappx*e, .height = h}, 0);
++			my += c->geom.height + gappx*e;
+ 		} else {
++			r = n - i;
++			h = (m->w.height - ty - gappx*e - gappx*e * (r - 1)) / r;
+ 			resize(c, (struct wlr_box){.x = m->w.x + mw, .y = m->w.y + ty,
+-				.width = m->w.width - mw, .height = (m->w.height - ty) / (n - i)}, 0);
+-			ty += c->geom.height;
++				.width = m->w.width - mw - gappx*e, .height = h}, 0);
++			ty += c->geom.height + gappx*e;
+ 		}
+ 		i++;
+ 	}
+@@ -2686,6 +2697,13 @@ togglefullscreen(const Arg *arg)
+ 		setfullscreen(sel, !sel->isfullscreen);
+ }
+ 
++void
++togglegaps(const Arg *arg)
++{
++	selmon->gaps = !selmon->gaps;
++	arrange(selmon);
++}
++
+ void
+ toggletag(const Arg *arg)
+ {
+-- 
+2.45.2
+
diff '--color=auto' -urN dwl/patches/lockedkeys.patch mis_repos/dwl/patches/lockedkeys.patch
--- dwl/patches/lockedkeys.patch	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/patches/lockedkeys.patch	2024-10-01 23:08:38.152977293 +0200
@@ -0,0 +1,80 @@
+From 70dc03a3817b8fd933244c2db1bb849d9626b12b Mon Sep 17 00:00:00 2001
+From: wochap <gean.marroquin@gmail.com>
+Date: Thu, 11 Apr 2024 13:16:40 -0500
+Subject: [PATCH] allow to add keybindings in lockscreen
+
+---
+ config.def.h | 11 +++++++++++
+ dwl.c        | 20 ++++++++++++++++++++
+ 2 files changed, 31 insertions(+)
+
+diff --git a/config.def.h b/config.def.h
+index 8847e58..0d4a4f8 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -164,6 +164,17 @@ static const Key keys[] = {
+ 	CHVT(7), CHVT(8), CHVT(9), CHVT(10), CHVT(11), CHVT(12),
+ };
+ 
++static const Key lockedkeys[] = {
++	/* Note that Shift changes certain key codes: c -> C, 2 -> at, etc. */
++	/* modifier                  key                 function        argument */
++
++	/* Ctrl-Alt-Backspace and Ctrl-Alt-Fx used to be handled by X server */
++	{ WLR_MODIFIER_CTRL|WLR_MODIFIER_ALT,XKB_KEY_Terminate_Server, quit, {0} },
++#define CHVT(n) { WLR_MODIFIER_CTRL|WLR_MODIFIER_ALT,XKB_KEY_XF86Switch_VT_##n, chvt, {.ui = (n)} }
++	CHVT(1), CHVT(2), CHVT(3), CHVT(4), CHVT(5), CHVT(6),
++	CHVT(7), CHVT(8), CHVT(9), CHVT(10), CHVT(11), CHVT(12),
++};
++
+ static const Button buttons[] = {
+ 	{ MODKEY, BTN_LEFT,   moveresize,     {.ui = CurMove} },
+ 	{ MODKEY, BTN_MIDDLE, togglefloating, {0} },
+diff --git a/dwl.c b/dwl.c
+index bf763df..db4bb2b 100644
+--- a/dwl.c
++++ b/dwl.c
+@@ -287,6 +287,7 @@ static void handlesig(int signo);
+ static void incnmaster(const Arg *arg);
+ static void inputdevice(struct wl_listener *listener, void *data);
+ static int keybinding(uint32_t mods, xkb_keysym_t sym);
++static int lockedkeybinding(uint32_t mods, xkb_keysym_t sym);
+ static void keypress(struct wl_listener *listener, void *data);
+ static void keypressmod(struct wl_listener *listener, void *data);
+ static int keyrepeat(void *data);
+@@ -1446,6 +1447,21 @@ keybinding(uint32_t mods, xkb_keysym_t sym)
+ 	return 0;
+ }
+ 
++int
++lockedkeybinding(uint32_t mods, xkb_keysym_t sym)
++{
++	int handled = 0;
++	const Key *k;
++	for (k = lockedkeys; k < END(lockedkeys); k++) {
++		if (CLEANMASK(mods) == CLEANMASK(k->mod) &&
++				sym == k->keysym && k->func) {
++			k->func(&k->arg);
++			handled = 1;
++		}
++	}
++	return handled;
++}
++
+ void
+ keypress(struct wl_listener *listener, void *data)
+ {
+@@ -1473,6 +1489,10 @@ keypress(struct wl_listener *listener, void *data)
+ 			handled = keybinding(mods, syms[i]) || handled;
+ 	}
+ 
++	if (locked && event->state == WL_KEYBOARD_KEY_STATE_PRESSED)
++		for (i = 0; i < nsyms; i++)
++			handled = lockedkeybinding(mods, syms[i]) || handled;
++
+ 	if (handled && group->wlr_group->keyboard.repeat_info.delay > 0) {
+ 		group->mods = mods;
+ 		group->keysyms = syms;
+-- 
+2.43.2
+
diff '--color=auto' -urN dwl/patches/pertag.patch mis_repos/dwl/patches/pertag.patch
--- dwl/patches/pertag.patch	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/patches/pertag.patch	2024-10-01 23:08:38.156310572 +0200
@@ -0,0 +1,170 @@
+From d3b551ffe3ec85e16341962e322150b81af6722f Mon Sep 17 00:00:00 2001
+From: wochap <gean.marroquin@gmail.com>
+Date: Wed, 31 Jul 2024 08:27:26 -0500
+Subject: [PATCH] makes layout, mwfact and nmaster individual for every tag
+
+inspiration: https://github.com/djpohly/dwl/wiki/pertag
+---
+ dwl.c | 75 +++++++++++++++++++++++++++++++++++++++++++++++++++++++----
+ 1 file changed, 70 insertions(+), 5 deletions(-)
+
+diff --git a/dwl.c b/dwl.c
+index 145fd01..2f364bc 100644
+--- a/dwl.c
++++ b/dwl.c
+@@ -102,6 +102,7 @@ typedef struct {
+ 	const Arg arg;
+ } Button;
+ 
++typedef struct Pertag Pertag;
+ typedef struct Monitor Monitor;
+ typedef struct {
+ 	/* Must keep these three elements in this order */
+@@ -199,6 +200,7 @@ struct Monitor {
+ 	struct wlr_box w; /* window area, layout-relative */
+ 	struct wl_list layers[4]; /* LayerSurface.link */
+ 	const Layout *lt[2];
++	Pertag *pertag;
+ 	unsigned int seltags;
+ 	unsigned int sellt;
+ 	uint32_t tagset[2];
+@@ -427,6 +429,14 @@ static xcb_atom_t netatom[NetLast];
+ /* attempt to encapsulate suck into one file */
+ #include "client.h"
+ 
++struct Pertag {
++	unsigned int curtag, prevtag; /* current and previous tag */
++	int nmasters[TAGCOUNT + 1]; /* number of windows in master area */
++	float mfacts[TAGCOUNT + 1]; /* mfacts per tag */
++	unsigned int sellts[TAGCOUNT + 1]; /* selected layouts */
++	const Layout *ltidxs[TAGCOUNT + 1][2]; /* matrix of tags and layouts indexes  */
++};
++
+ /* function implementations */
+ void
+ applybounds(Client *c, struct wlr_box *bbox)
+@@ -712,6 +722,7 @@ cleanupmon(struct wl_listener *listener, void *data)
+ 	wlr_output_layout_remove(output_layout, m->wlr_output);
+ 	wlr_scene_output_destroy(m->scene_output);
+ 
++	free(m->pertag);
+ 	closemon(m);
+ 	wlr_scene_node_destroy(&m->fullscreen_bg->node);
+ 	free(m);
+@@ -983,6 +994,18 @@ createmon(struct wl_listener *listener, void *data)
+ 	wl_list_insert(&mons, &m->link);
+ 	printstatus();
+ 
++	m->pertag = calloc(1, sizeof(Pertag));
++	m->pertag->curtag = m->pertag->prevtag = 1;
++
++	for (i = 0; i <= TAGCOUNT; i++) {
++		m->pertag->nmasters[i] = m->nmaster;
++		m->pertag->mfacts[i] = m->mfact;
++
++		m->pertag->ltidxs[i][0] = m->lt[0];
++		m->pertag->ltidxs[i][1] = m->lt[1];
++		m->pertag->sellts[i] = m->sellt;
++	}
++
+ 	/* The xdg-protocol specifies:
+ 	 *
+ 	 * If the fullscreened surface is not opaque, the compositor must make
+@@ -1472,7 +1495,7 @@ incnmaster(const Arg *arg)
+ {
+ 	if (!arg || !selmon)
+ 		return;
+-	selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
++	selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag] = MAX(selmon->nmaster + arg->i, 0);
+ 	arrange(selmon);
+ }
+ 
+@@ -2305,9 +2328,9 @@ setlayout(const Arg *arg)
+ 	if (!selmon)
+ 		return;
+ 	if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
+-		selmon->sellt ^= 1;
++		selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag] ^= 1;
+ 	if (arg && arg->v)
+-		selmon->lt[selmon->sellt] = (Layout *)arg->v;
++		selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt] = (Layout *)arg->v;
+ 	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, LENGTH(selmon->ltsymbol));
+ 	arrange(selmon);
+ 	printstatus();
+@@ -2324,7 +2347,7 @@ setmfact(const Arg *arg)
+ 	f = arg->f < 1.0f ? arg->f + selmon->mfact : arg->f - 1.0f;
+ 	if (f < 0.1 || f > 0.9)
+ 		return;
+-	selmon->mfact = f;
++	selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag] = f;
+ 	arrange(selmon);
+ }
+ 
+@@ -2701,9 +2724,29 @@ void
+ toggleview(const Arg *arg)
+ {
+ 	uint32_t newtagset;
++	size_t i;
+ 	if (!(newtagset = selmon ? selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK) : 0))
+ 		return;
+ 
++	if (newtagset == (uint32_t)~0) {
++		selmon->pertag->prevtag = selmon->pertag->curtag;
++		selmon->pertag->curtag = 0;
++	}
++
++	/* test if the user did not select the same tag */
++	if (!(newtagset & 1 << (selmon->pertag->curtag - 1))) {
++		selmon->pertag->prevtag = selmon->pertag->curtag;
++		for (i = 0; !(newtagset & 1 << i); i++) ;
++		selmon->pertag->curtag = i + 1;
++	}
++
++	/* apply settings for this view */
++	selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
++	selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
++	selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
++	selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
++	selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
++
+ 	selmon->tagset[selmon->seltags] = newtagset;
+ 	focusclient(focustop(selmon), 1);
+ 	arrange(selmon);
+@@ -2892,11 +2935,33 @@ urgent(struct wl_listener *listener, void *data)
+ void
+ view(const Arg *arg)
+ {
++	size_t i, tmptag;
++
+ 	if (!selmon || (arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
+ 		return;
+ 	selmon->seltags ^= 1; /* toggle sel tagset */
+-	if (arg->ui & TAGMASK)
++	if (arg->ui & ~0) {
+ 		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
++		selmon->pertag->prevtag = selmon->pertag->curtag;
++
++		if (arg->ui == TAGMASK)
++			selmon->pertag->curtag = 0;
++		else {
++			for (i = 0; !(arg->ui & 1 << i); i++) ;
++			selmon->pertag->curtag = i + 1;
++		}
++	} else {
++		tmptag = selmon->pertag->prevtag;
++		selmon->pertag->prevtag = selmon->pertag->curtag;
++		selmon->pertag->curtag = tmptag;
++	}
++
++	selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
++	selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
++	selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
++	selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
++	selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
++
+ 	focusclient(focustop(selmon), 1);
+ 	arrange(selmon);
+ 	printstatus();
+-- 
+2.45.2
+
diff '--color=auto' -urN dwl/patches/relative-mouse-resize.patch mis_repos/dwl/patches/relative-mouse-resize.patch
--- dwl/patches/relative-mouse-resize.patch	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/patches/relative-mouse-resize.patch	2024-10-01 23:08:38.156310572 +0200
@@ -0,0 +1,102 @@
+From 5c75c67fe49e5ab89e4a61dfb2fe74c768477b90 Mon Sep 17 00:00:00 2001
+From: wochap <gean.marroquin@gmail.com>
+Date: Fri, 5 Jul 2024 11:13:53 -0500
+Subject: [PATCH] implement relative-muse-resize
+
+---
+ dwl.c | 66 ++++++++++++++++++++++++++++++++++++++++++++++++++++-------
+ 1 file changed, 59 insertions(+), 7 deletions(-)
+
+diff --git a/dwl.c b/dwl.c
+index dc0437e..ebf9ef1 100644
+--- a/dwl.c
++++ b/dwl.c
+@@ -401,7 +401,8 @@ static struct wlr_seat *seat;
+ static KeyboardGroup *kb_group;
+ static unsigned int cursor_mode;
+ static Client *grabc;
+-static int grabcx, grabcy; /* client-relative */
++static Client initial_grabc;
++static int grabcx, grabcy, grabx, graby, grabcenterx, grabcentery; /* client-relative */
+ 
+ static struct wlr_output_layout *output_layout;
+ static struct wlr_box sgeom;
+@@ -1821,8 +1822,27 @@ motionnotify(uint32_t time, struct wlr_input_device *device, double dx, double d
+ 			.width = grabc->geom.width, .height = grabc->geom.height}, 1);
+ 		return;
+ 	} else if (cursor_mode == CurResize) {
+-		resize(grabc, (struct wlr_box){.x = grabc->geom.x, .y = grabc->geom.y,
+-			.width = (int)round(cursor->x) - grabc->geom.x, .height = (int)round(cursor->y) - grabc->geom.y}, 1);
++		if (grabcenterx < grabx) {
++			if (grabcentery < graby) {
++				/* bottom-right */
++				resize(grabc, (struct wlr_box){.x = initial_grabc.geom.x, .y = initial_grabc.geom.y,
++					.width = (int)round(cursor->x) - initial_grabc.geom.x, .height = (int)round(cursor->y) - initial_grabc.geom.y}, 1);
++			} else {
++				/* top-right */
++				resize(grabc, (struct wlr_box){.x = initial_grabc.geom.x, .y = (int)round(cursor->y),
++					.width = (int)round(cursor->x) - initial_grabc.geom.x, .height = initial_grabc.geom.y + initial_grabc.geom.height - (int)round(cursor->y)}, 1);
++			}
++		} else {
++			if (grabcentery < graby) {
++				/* bottom-left */
++				resize(grabc, (struct wlr_box){.x = (int)round(cursor->x), .y = initial_grabc.geom.y,
++					.width = initial_grabc.geom.x + initial_grabc.geom.width - (int)round(cursor->x), .height = (int)round(cursor->y) - initial_grabc.geom.y}, 1);
++			} else {
++				/* top-left */
++				resize(grabc, (struct wlr_box){.x = (int)round(cursor->x), .y = (int)round(cursor->y),
++					.width = initial_grabc.geom.x + initial_grabc.geom.width - (int)round(cursor->x), .height = initial_grabc.geom.y + initial_grabc.geom.height - (int)round(cursor->y)}, 1);
++			}
++		}
+ 		return;
+ 	}
+ 
+@@ -1870,10 +1890,42 @@ moveresize(const Arg *arg)
+ 	case CurResize:
+ 		/* Doesn't work for X11 output - the next absolute motion event
+ 		 * returns the cursor to where it started */
+-		wlr_cursor_warp_closest(cursor, NULL,
+-				grabc->geom.x + grabc->geom.width,
+-				grabc->geom.y + grabc->geom.height);
+-		wlr_cursor_set_xcursor(cursor, cursor_mgr, "se-resize");
++		initial_grabc = *grabc;
++		grabx = (int)round(cursor->x);
++		graby = (int)round(cursor->y);
++		grabcx = (int)round(cursor->x) - grabc->geom.x;
++		grabcy = (int)round(cursor->y) - grabc->geom.y;
++		grabcenterx = grabc->geom.width / 2 + grabc->geom.x;
++		grabcentery = grabc->geom.height / 2 + grabc->geom.y;
++		if (grabcenterx < grabx) {
++			if (grabcentery < graby) {
++				/* bottom-right */
++				wlr_cursor_warp_closest(cursor, NULL,
++					grabc->geom.x + grabc->geom.width,
++					grabc->geom.y + grabc->geom.height);
++				wlr_cursor_set_xcursor(cursor, cursor_mgr, "se-resize");
++			} else {
++				/* top-right */
++				wlr_cursor_warp_closest(cursor, NULL,
++					grabc->geom.x + grabc->geom.width,
++					grabc->geom.y);
++				wlr_cursor_set_xcursor(cursor, cursor_mgr, "ne-resize");
++			}
++		} else {
++			if (grabcentery < graby) {
++				/* bottom-left */
++				wlr_cursor_warp_closest(cursor, NULL,
++					grabc->geom.x,
++					grabc->geom.y + grabc->geom.height);
++				wlr_cursor_set_xcursor(cursor, cursor_mgr, "sw-resize");
++			} else {
++				/* top-left */
++				wlr_cursor_warp_closest(cursor, NULL,
++					grabc->geom.x,
++					grabc->geom.y);
++				wlr_cursor_set_xcursor(cursor, cursor_mgr, "nw-resize");
++			}
++		}
+ 		break;
+ 	}
+ }
+-- 
+2.45.1
\ No newline at end of file
diff '--color=auto' -urN dwl/patches/swapandfocusdir.patch mis_repos/dwl/patches/swapandfocusdir.patch
--- dwl/patches/swapandfocusdir.patch	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/patches/swapandfocusdir.patch	2024-10-01 23:08:38.156310572 +0200
@@ -0,0 +1,221 @@
+From 285470897406b653e77d732a77356aaf9a70b799 Mon Sep 17 00:00:00 2001
+From: wochap <gean.marroquin@gmail.com>
+Date: Fri, 5 Jul 2024 12:37:39 -0500
+Subject: [PATCH] implement swapandfocusdir
+
+---
+ config.def.h |   8 +++
+ dwl.c        | 164 +++++++++++++++++++++++++++++++++++++++++++++++++++
+ 2 files changed, 172 insertions(+)
+
+diff --git a/config.def.h b/config.def.h
+index 22d2171..724e15e 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -129,6 +129,14 @@ static const Key keys[] = {
+ 	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_Return,     spawn,          {.v = termcmd} },
+ 	{ MODKEY,                    XKB_KEY_j,          focusstack,     {.i = +1} },
+ 	{ MODKEY,                    XKB_KEY_k,          focusstack,     {.i = -1} },
++	{ MODKEY|WLR_MODIFIER_CTRL,  XKB_KEY_Left,       focusdir,       {.ui = 0} },
++	{ MODKEY|WLR_MODIFIER_CTRL,  XKB_KEY_Right,      focusdir,       {.ui = 1} },
++	{ MODKEY|WLR_MODIFIER_CTRL,  XKB_KEY_Up,         focusdir,       {.ui = 2} },
++	{ MODKEY|WLR_MODIFIER_CTRL,  XKB_KEY_Down,       focusdir,       {.ui = 3} },
++	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_Left,       swapdir,        {.ui = 0} },
++	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_Right,      swapdir,        {.ui = 1} },
++	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_Up,         swapdir,        {.ui = 2} },
++	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_Down,       swapdir,        {.ui = 3} },
+ 	{ MODKEY,                    XKB_KEY_i,          incnmaster,     {.i = +1} },
+ 	{ MODKEY,                    XKB_KEY_d,          incnmaster,     {.i = -1} },
+ 	{ MODKEY,                    XKB_KEY_h,          setmfact,       {.f = -0.05f} },
+diff --git a/dwl.c b/dwl.c
+index dc0437e..844c1f5 100644
+--- a/dwl.c
++++ b/dwl.c
+@@ -241,6 +241,11 @@ typedef struct {
+ 	struct wl_listener destroy;
+ } SessionLock;
+ 
++typedef struct {
++	int x;
++	int y;
++} Vector;
++
+ /* function declarations */
+ static void applybounds(Client *c, struct wlr_box *bbox);
+ static void applyrules(Client *c);
+@@ -285,6 +290,8 @@ static Monitor *dirtomon(enum wlr_direction dir);
+ static void focusclient(Client *c, int lift);
+ static void focusmon(const Arg *arg);
+ static void focusstack(const Arg *arg);
++static void focusdir(const Arg *arg);
++static void swapdir(const Arg *arg);
+ static Client *focustop(Monitor *m);
+ static void fullscreennotify(struct wl_listener *listener, void *data);
+ static void handlesig(int signo);
+@@ -1425,6 +1432,163 @@ focusstack(const Arg *arg)
+ 	focusclient(c, 1);
+ }
+ 
++Vector
++position_of_box(const struct wlr_box *box)
++{
++	return (Vector){
++		.x = box->x + box->width / 2,
++		.y = box->y + box->height / 2,
++	};
++}
++
++Vector
++diff_of_vectors(Vector *a, Vector *b)
++{
++	return (Vector){
++		.x = b->x - a->x,
++		.y = b->y - a->y,
++	};
++}
++
++const char *
++direction_of_vector(Vector *vector)
++{
++	// A zero length vector has no direction
++	if (vector->x == 0 && vector->y == 0) return "";
++
++	if (abs(vector->y) > abs(vector->x)) {
++		// Careful: We are operating in a Y-inverted coordinate system.
++		return (vector->y > 0) ? "bottom" : "top";
++	} else {
++		return (vector->x > 0) ? "right" : "left";
++	}
++}
++
++uint32_t
++vector_length(Vector *vector)
++{
++	// Euclidean distance formula
++	return (uint32_t)sqrt(vector->x * vector->x + vector->y * vector->y);
++}
++
++// Spatial direction, based on focused client position.
++Client *
++client_in_direction(const char *direction, const int *skipfloat)
++{
++	Client *cfocused = focustop(selmon);
++	Vector cfocusedposition;
++	Client *ctarget = NULL;
++	double targetdistance = INFINITY;
++	Client *c;
++
++	if (!cfocused || cfocused->isfullscreen || (skipfloat && cfocused->isfloating))
++		return NULL;
++
++	cfocusedposition = position_of_box(&cfocused->geom);
++
++	wl_list_for_each(c, &clients, link) {
++		Vector cposition;
++		Vector positiondiff;
++		uint32_t distance;
++
++		if (c == cfocused)
++			continue;
++
++		if (skipfloat && c->isfloating)
++			continue;
++
++		if (!VISIBLEON(c, selmon))
++			continue;
++
++		cposition = position_of_box(&c->geom);
++		positiondiff = diff_of_vectors(&cfocusedposition, &cposition);
++
++		if (strcmp(direction, direction_of_vector(&positiondiff)) != 0)
++			continue;
++
++		distance = vector_length(&positiondiff);
++
++		 if (distance < targetdistance) {
++			ctarget = c;
++			targetdistance = distance;
++		}
++	}
++
++	return ctarget;
++}
++
++void
++focusdir(const Arg *arg)
++{
++	Client *c = NULL;
++
++	if (arg->ui == 0)
++		c = client_in_direction("left", (int *)0);
++	if (arg->ui == 1)
++		c = client_in_direction("right", (int *)0);
++	if (arg->ui == 2)
++		c = client_in_direction("top", (int *)0);
++	if (arg->ui == 3)
++		c = client_in_direction("bottom", (int *)0);
++
++	if (c != NULL)
++		focusclient(c, 1);
++}
++
++void
++wl_list_swap(struct wl_list *list1, struct wl_list *list2)
++{
++	struct wl_list *prev1, *next1, *prev2, *next2;
++	struct wl_list temp;
++
++	if (list1 == list2) {
++		// No need to swap the same list
++		return;
++	}
++
++	// Get the lists before and after list1
++	prev1 = list1->prev;
++	next1 = list1->next;
++
++	// Get the lists before and after list2
++	prev2 = list2->prev;
++	next2 = list2->next;
++
++	// Update the next and previous pointers of adjacent lists
++	prev1->next = list2;
++	next1->prev = list2;
++	prev2->next = list1;
++	next2->prev = list1;
++
++	// Swap the next and previous pointers of the lists to actually swap them
++	temp = *list1;
++	*list1 = *list2;
++	*list2 = temp;
++}
++
++void
++swapdir(const Arg *arg)
++{
++	Client *c = NULL;
++	Client *cfocused;
++
++	if (arg->ui == 0)
++		c = client_in_direction("left", (int *)1);
++	if (arg->ui == 1)
++		c = client_in_direction("right", (int *)1);
++	if (arg->ui == 2)
++		c = client_in_direction("top", (int *)1);
++	if (arg->ui == 3)
++		c = client_in_direction("bottom", (int *)1);
++
++	if (c == NULL)
++		return;
++
++	cfocused = focustop(selmon);
++	wl_list_swap(&cfocused->link, &c->link);
++	arrange(selmon);
++}
++
+ /* We probably should change the name of this, it sounds like
+  * will focus the topmost client of this mon, when actually will
+  * only return that client */
+-- 
+2.45.1
+
diff '--color=auto' -urN dwl/patches/warpcursor.patch mis_repos/dwl/patches/warpcursor.patch
--- dwl/patches/warpcursor.patch	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/patches/warpcursor.patch	2024-10-01 23:08:38.156310572 +0200
@@ -0,0 +1,71 @@
+From 4951ccc89dac2b557994b2f6c3aacb2398e2d1b1 Mon Sep 17 00:00:00 2001
+From: Ben Collerson <benc@benc.cc>
+Date: Thu, 4 Jan 2024 20:30:01 +1000
+Subject: [PATCH] warpcursor
+
+---
+ dwl.c | 27 +++++++++++++++++++++++++++
+ 1 file changed, 27 insertions(+)
+
+diff --git a/dwl.c b/dwl.c
+index 145fd018..f7ad6c13 100644
+--- a/dwl.c
++++ b/dwl.c
+@@ -347,6 +347,7 @@ static void urgent(struct wl_listener *listener, void *data);
+ static void view(const Arg *arg);
+ static void virtualkeyboard(struct wl_listener *listener, void *data);
+ static void virtualpointer(struct wl_listener *listener, void *data);
++static void warpcursor(const Client *c);
+ static Monitor *xytomon(double x, double y);
+ static void xytonode(double x, double y, struct wlr_surface **psurface,
+ 		Client **pc, LayerSurface **pl, double *nx, double *ny);
+@@ -514,6 +515,7 @@ arrange(Monitor *m)
+ 		m->lt[m->sellt]->arrange(m);
+ 	motionnotify(0, NULL, 0, 0, 0, 0);
+ 	checkidleinhibitor(NULL);
++	warpcursor(focustop(selmon));
+ }
+ 
+ void
+@@ -1323,6 +1325,10 @@ focusclient(Client *c, int lift)
+ 	if (locked)
+ 		return;
+ 
++	/* Warp cursor to center of client if it is outside */
++	if (lift)
++		warpcursor(c);
++
+ 	/* Raise client in stacking order if requested */
+ 	if (c && lift)
+ 		wlr_scene_node_raise_to_top(&c->scene->node);
+@@ -2927,6 +2933,27 @@ virtualpointer(struct wl_listener *listener, void *data)
+ 		wlr_cursor_map_input_to_output(cursor, &pointer.base, event->suggested_output);
+ }
+ 
++void
++warpcursor(const Client *c) {
++	if (cursor_mode != CurNormal) {
++		return;
++	}
++	if (!c && selmon) {
++		wlr_cursor_warp_closest(cursor,
++			  NULL,
++			  selmon->w.x + selmon->w.width / 2.0 ,
++			  selmon->w.y + selmon->w.height / 2.0);
++	}
++	else if ( c && (cursor->x < c->geom.x ||
++		cursor->x > c->geom.x + c->geom.width ||
++		cursor->y < c->geom.y ||
++		cursor->y > c->geom.y + c->geom.height))
++		wlr_cursor_warp_closest(cursor,
++			  NULL,
++			  c->geom.x + c->geom.width / 2.0,
++			  c->geom.y + c->geom.height / 2.0);
++}
++
+ Monitor *
+ xytomon(double x, double y)
+ {
+-- 
+2.45.2
+
diff '--color=auto' -urN dwl/pointer-constraints-unstable-v1-protocol.h mis_repos/dwl/pointer-constraints-unstable-v1-protocol.h
--- dwl/pointer-constraints-unstable-v1-protocol.h	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/pointer-constraints-unstable-v1-protocol.h	2024-10-01 23:08:38.156310572 +0200
@@ -0,0 +1,63 @@
+/* Generated by wayland-scanner 1.23.1 */
+
+#ifndef POINTER_CONSTRAINTS_UNSTABLE_V1_ENUM_PROTOCOL_H
+#define POINTER_CONSTRAINTS_UNSTABLE_V1_ENUM_PROTOCOL_H
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#ifndef ZWP_POINTER_CONSTRAINTS_V1_ERROR_ENUM
+#define ZWP_POINTER_CONSTRAINTS_V1_ERROR_ENUM
+/**
+ * @ingroup iface_zwp_pointer_constraints_v1
+ * wp_pointer_constraints error values
+ *
+ * These errors can be emitted in response to wp_pointer_constraints
+ * requests.
+ */
+enum zwp_pointer_constraints_v1_error {
+	/**
+	 * pointer constraint already requested on that surface
+	 */
+	ZWP_POINTER_CONSTRAINTS_V1_ERROR_ALREADY_CONSTRAINED = 1,
+};
+#endif /* ZWP_POINTER_CONSTRAINTS_V1_ERROR_ENUM */
+
+#ifndef ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_ENUM
+#define ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_ENUM
+/**
+ * @ingroup iface_zwp_pointer_constraints_v1
+ * constraint lifetime
+ *
+ * These values represent different lifetime semantics. They are passed
+ * as arguments to the factory requests to specify how the constraint
+ * lifetimes should be managed.
+ */
+enum zwp_pointer_constraints_v1_lifetime {
+	/**
+	 * the pointer constraint is defunct once deactivated
+	 *
+	 * A oneshot pointer constraint will never reactivate once it has
+	 * been deactivated. See the corresponding deactivation event
+	 * (wp_locked_pointer.unlocked and wp_confined_pointer.unconfined)
+	 * for details.
+	 */
+	ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_ONESHOT = 1,
+	/**
+	 * the pointer constraint may reactivate
+	 *
+	 * A persistent pointer constraint may again reactivate once it
+	 * has been deactivated. See the corresponding deactivation event
+	 * (wp_locked_pointer.unlocked and wp_confined_pointer.unconfined)
+	 * for details.
+	 */
+	ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_PERSISTENT = 2,
+};
+#endif /* ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_ENUM */
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff '--color=auto' -urN dwl/README.md mis_repos/dwl/README.md
--- dwl/README.md	2024-08-06 20:03:27.000000000 +0200
+++ mis_repos/dwl/README.md	2024-10-01 23:08:38.139644179 +0200
@@ -1,201 +1,23 @@
-# dwl - dwm for Wayland
+**My dwl 0.7 fork with the following patches:**
 
-Join us on our IRC channel: [#dwl on Libera Chat]  
-Or on our [Discord server].
-
-dwl is a compact, hackable compositor for [Wayland] based on [wlroots]. It is
-intended to fill the same space in the Wayland world that dwm does in X11,
-primarily in terms of functionality, and secondarily in terms of
-philosophy. Like dwm, dwl is:
-
-- Easy to understand, hack on, and extend with patches
-- One C source file (or a very small number) configurable via `config.h`
-- Tied to as few external dependencies as possible
-
-## Getting Started:
-
-### **dwl branch 0.7 and releases based upon 0.7 build against [wlroots] 0.18**
-
-### Latest semi-stable [release]
-This is probably where you want to start. This builds against the dependent
-packages' versions currently shipping in major distributions. If your
-distribution's wlroots version is older, use an earlier dwl [release] or [0.x
-branch].
-
-### Development branch [main]
-Active development progresses on the `main` branch. The `main` branch is built
-against a late (and often changing) git commit of wlroots. While the adventurous
-are welcome to use `main`, it is a rocky road. Using `main` requires that the
-user be willing to chase git commits of wlroots. Testing development pull
-requests may involve merging unmerged pull requests in [wlroots]' git repository
-and/or git commits of wayland.
-  
-### Building dwl
-dwl has the following dependencies:
-- libinput
-- wayland
-- wlroots (compiled with the libinput backend)
-- xkbcommon
-- wayland-protocols (compile-time only)
-- pkg-config (compile-time only)
-
-dwl has the following additional dependencies if XWayland support is enabled:
-- libxcb
-- libxcb-wm
-- wlroots (compiled with X11 support)
-- Xwayland (runtime only)
-
-Install these (and their `-devel` versions if your distro has separate
-development packages) and run `make`. If you wish to build against a released
-version of wlroots (*you probably do*), use a [release] or a [0.x branch]. If
-you want to use the unstable development `main` branch, you need to use the git
-version of [wlroots].
-
-To enable XWayland, you should uncomment its flags in `config.mk`.
-
-## Configuration
-
-All configuration is done by editing `config.h` and recompiling, in the same
-manner as dwm. There is no way to separately restart the window manager in
-Wayland without restarting the entire display server, so any changes will take
-effect the next time dwl is executed.
-
-As in the dwm community, we encourage users to share patches they have
-created. Check out the [dwl-patches] repository!
-
-## Running dwl
-
-dwl can be run on any of the backends supported by wlroots. This means you can
-run it as a separate window inside either an X11 or Wayland session, as well as
-directly from a VT console. Depending on your distro's setup, you may need to
-add your user to the `video` and `input` groups before you can run dwl on a
-VT. If you are using `elogind` or `systemd-logind` you need to install polkit;
-otherwise you need to add yourself in the `seat` group and enable/start the
-seatd daemon.
-
-When dwl is run with no arguments, it will launch the server and begin handling
-any shortcuts configured in `config.h`. There is no status bar or other
-decoration initially; these are instead clients that can be run within the
-Wayland session. Do note that the default background color is black. This can be
-modified in `config.h`.
-
-If you would like to run a script or command automatically at startup, you can
-specify the command using the `-s` option. This command will be executed as a
-shell command using `/bin/sh -c`.  It serves a similar function to `.xinitrc`,
-but differs in that the display server will not shut down when this process
-terminates. Instead, dwl will send this process a SIGTERM at shutdown and wait
-for it to terminate (if it hasn't already). This makes it ideal for execing into
-a user service manager like [s6], [anopa], [runit], [dinit], or [`systemd
---user`].
-
-Note: The `-s` command is run as a *child process* of dwl, which means that it
-does not have the ability to affect the environment of dwl or of any processes
-that it spawns. If you need to set environment variables that affect the entire
-dwl session, these must be set prior to running dwl. For example, Wayland
-requires a valid `XDG_RUNTIME_DIR`, which is usually set up by a session manager
-such as `elogind` or `systemd-logind`.  If your system doesn't do this
-automatically, you will need to configure it prior to launching `dwl`, e.g.:
-
-    export XDG_RUNTIME_DIR=/tmp/xdg-runtime-$(id -u)
-    mkdir -p $XDG_RUNTIME_DIR
-    dwl
-
-### Status information
-
-Information about selected layouts, current window title, app-id, and
-selected/occupied/urgent tags is written to the stdin of the `-s` command (see
-the `printstatus()` function for details).  This information can be used to
-populate an external status bar with a script that parses the
-information. Failing to read this information will cause dwl to block, so if you
-do want to run a startup command that does not consume the status information,
-you can close standard input with the `<&-` shell redirection, for example:
-
-    dwl -s 'foot --server <&-'
-
-If your startup command is a shell script, you can achieve the same inside the
-script with the line
-
-    exec <&-
-
-To get a list of status bars that work with dwl consult our [wiki].
-
-## Replacements for X applications
-
-You can find a [list of useful resources on our wiki].
-
-## Background
-
-dwl is not meant to provide every feature under the sun. Instead, like dwm, it
-sticks to features which are necessary, simple, and straightforward to implement
-given the base on which it is built. Implemented default features are:
-
-- Any features provided by dwm/Xlib: simple window borders, tags, keybindings,
-  client rules, mouse move/resize. Providing a built-in status bar is an
-  exception to this goal, to avoid dependencies on font rendering and/or drawing
-  libraries when an external bar could work well.
-- Configurable multi-monitor layout support, including position and rotation
-- Configurable HiDPI/multi-DPI support
-- Idle-inhibit protocol which lets applications such as mpv disable idle
-  monitoring
-- Provide information to external status bars via stdout/stdin
-- Urgency hints via xdg-activate protocol
-- Support screen lockers via ext-session-lock-v1 protocol
-- Various Wayland protocols
-- XWayland support as provided by wlroots (can be enabled in `config.mk`)
-- Zero flickering - Wayland users naturally expect that "every frame is perfect"
-- Layer shell popups (used by Waybar)
-- Damage tracking provided by scenegraph API
-
-Given the Wayland architecture, dwl has to implement features from dwm **and**
-the xorg-server. Because of this, it is impossible to maintain the original
-project goal of 2000 SLOC and have a reasonably complete compositor with
-features comparable to dwm. However, this does not mean that the code will grow
-indiscriminately. We will try to keep the code as small as possible.
-
-Features under consideration (possibly as patches) are:
-
-- Protocols made trivial by wlroots
-- Implement the text-input and input-method protocols to support IME once ibus
-  implements input-method v2 (see https://github.com/ibus/ibus/pull/2256 and
-  https://codeberg.org/dwl/dwl/pulls/235)
-
-Feature *non-goals* for the main codebase include:
-
-- Client-side decoration (any more than is necessary to tell the clients not to)
-- Client-initiated window management, such as move, resize, and close, which can
-  be done through the compositor
-- Animations and visual effects
-
-## Acknowledgements
-
-dwl began by extending the TinyWL example provided (CC0) by the sway/wlroots
-developers. This was made possible in many cases by looking at how sway
-accomplished something, then trying to do the same in as suckless a way as
-possible.
-
-Many thanks to suckless.org and the dwm developers and community for the
-inspiration, and to the various contributors to the project, including:
-
-- **Devin J. Pohly for creating and nurturing the fledgling project**
-- Alexander Courtis for the XWayland implementation
-- Guido Cella for the layer-shell protocol implementation, patch maintenance,
-  and for helping to keep the project running
-- Stivvo for output management and fullscreen support, and patch maintenance
+  - alwayscenter
+  
+  - barheight
+  
+  - lockedkeys
+  
+  - relative-mouse-resize
+  
+  - warpcursor
 
+  - bar
+  
+  - gaps
+  
+  - pertag
+  
+  - swapandfocusdir
 
-[`systemd --user`]: https://wiki.archlinux.org/title/Systemd/User
-[#dwl on Libera Chat]: https://web.libera.chat/?channels=#dwl
-[0.7-rc1]: https://codeberg.org/dwl/dwl/releases/tag/v0.7-rc1
-[0.x branch]: https://codeberg.org/dwl/dwl/branches
-[anopa]: https://jjacky.com/anopa/
-[dinit]: https://davmac.org/projects/dinit/
-[dwl-patches]: https://codeberg.org/dwl/dwl-patches
-[list of useful resources on our wiki]: https://codeberg.org/dwl/dwl/wiki/Home#migrating-from-x
-[main]: https://codeberg.org/dwl/dwl/src/branch/main
-[release]: https://codeberg.org/dwl/dwl/releases
-[runit]: http://smarden.org/runit/faq.html#userservices
-[s6]: https://skarnet.org/software/s6/
-[wlroots]: https://gitlab.freedesktop.org/wlroots/wlroots/
-[wiki]: https://codeberg.org/dwl/dwl/wiki/Home#compatible-status-bars
-[Discord server]: https://discord.gg/jJxZnrGPWN
-[Wayland]: https://wayland.freedesktop.org/
+  **Screenshot:**
+  
+  ![image](https://github.com/user-attachments/assets/f4b51318-730d-4139-ae2c-6dcc32200424)
Binary files dwl/util.o and mis_repos/dwl/util.o differ
diff '--color=auto' -urN dwl/wlr-layer-shell-unstable-v1-protocol.h mis_repos/dwl/wlr-layer-shell-unstable-v1-protocol.h
--- dwl/wlr-layer-shell-unstable-v1-protocol.h	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/wlr-layer-shell-unstable-v1-protocol.h	2024-10-01 23:08:38.156310572 +0200
@@ -0,0 +1,177 @@
+/* Generated by wayland-scanner 1.23.1 */
+
+#ifndef WLR_LAYER_SHELL_UNSTABLE_V1_ENUM_PROTOCOL_H
+#define WLR_LAYER_SHELL_UNSTABLE_V1_ENUM_PROTOCOL_H
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#ifndef ZWLR_LAYER_SHELL_V1_ERROR_ENUM
+#define ZWLR_LAYER_SHELL_V1_ERROR_ENUM
+enum zwlr_layer_shell_v1_error {
+	/**
+	 * wl_surface has another role
+	 */
+	ZWLR_LAYER_SHELL_V1_ERROR_ROLE = 0,
+	/**
+	 * layer value is invalid
+	 */
+	ZWLR_LAYER_SHELL_V1_ERROR_INVALID_LAYER = 1,
+	/**
+	 * wl_surface has a buffer attached or committed
+	 */
+	ZWLR_LAYER_SHELL_V1_ERROR_ALREADY_CONSTRUCTED = 2,
+};
+#endif /* ZWLR_LAYER_SHELL_V1_ERROR_ENUM */
+
+#ifndef ZWLR_LAYER_SHELL_V1_LAYER_ENUM
+#define ZWLR_LAYER_SHELL_V1_LAYER_ENUM
+/**
+ * @ingroup iface_zwlr_layer_shell_v1
+ * available layers for surfaces
+ *
+ * These values indicate which layers a surface can be rendered in. They
+ * are ordered by z depth, bottom-most first. Traditional shell surfaces
+ * will typically be rendered between the bottom and top layers.
+ * Fullscreen shell surfaces are typically rendered at the top layer.
+ * Multiple surfaces can share a single layer, and ordering within a
+ * single layer is undefined.
+ */
+enum zwlr_layer_shell_v1_layer {
+	ZWLR_LAYER_SHELL_V1_LAYER_BACKGROUND = 0,
+	ZWLR_LAYER_SHELL_V1_LAYER_BOTTOM = 1,
+	ZWLR_LAYER_SHELL_V1_LAYER_TOP = 2,
+	ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY = 3,
+};
+#endif /* ZWLR_LAYER_SHELL_V1_LAYER_ENUM */
+
+#ifndef ZWLR_LAYER_SURFACE_V1_KEYBOARD_INTERACTIVITY_ENUM
+#define ZWLR_LAYER_SURFACE_V1_KEYBOARD_INTERACTIVITY_ENUM
+/**
+ * @ingroup iface_zwlr_layer_surface_v1
+ * types of keyboard interaction possible for a layer shell surface
+ *
+ * Types of keyboard interaction possible for layer shell surfaces. The
+ * rationale for this is twofold: (1) some applications are not interested
+ * in keyboard events and not allowing them to be focused can improve the
+ * desktop experience; (2) some applications will want to take exclusive
+ * keyboard focus.
+ */
+enum zwlr_layer_surface_v1_keyboard_interactivity {
+	/**
+	 * no keyboard focus is possible
+	 *
+	 * This value indicates that this surface is not interested in
+	 * keyboard events and the compositor should never assign it the
+	 * keyboard focus.
+	 *
+	 * This is the default value, set for newly created layer shell
+	 * surfaces.
+	 *
+	 * This is useful for e.g. desktop widgets that display information
+	 * or only have interaction with non-keyboard input devices.
+	 */
+	ZWLR_LAYER_SURFACE_V1_KEYBOARD_INTERACTIVITY_NONE = 0,
+	/**
+	 * request exclusive keyboard focus
+	 *
+	 * Request exclusive keyboard focus if this surface is above the
+	 * shell surface layer.
+	 *
+	 * For the top and overlay layers, the seat will always give
+	 * exclusive keyboard focus to the top-most layer which has
+	 * keyboard interactivity set to exclusive. If this layer contains
+	 * multiple surfaces with keyboard interactivity set to exclusive,
+	 * the compositor determines the one receiving keyboard events in
+	 * an implementation- defined manner. In this case, no guarantee is
+	 * made when this surface will receive keyboard focus (if ever).
+	 *
+	 * For the bottom and background layers, the compositor is allowed
+	 * to use normal focus semantics.
+	 *
+	 * This setting is mainly intended for applications that need to
+	 * ensure they receive all keyboard events, such as a lock screen
+	 * or a password prompt.
+	 */
+	ZWLR_LAYER_SURFACE_V1_KEYBOARD_INTERACTIVITY_EXCLUSIVE = 1,
+	/**
+	 * request regular keyboard focus semantics
+	 *
+	 * This requests the compositor to allow this surface to be
+	 * focused and unfocused by the user in an implementation-defined
+	 * manner. The user should be able to unfocus this surface even
+	 * regardless of the layer it is on.
+	 *
+	 * Typically, the compositor will want to use its normal mechanism
+	 * to manage keyboard focus between layer shell surfaces with this
+	 * setting and regular toplevels on the desktop layer (e.g. click
+	 * to focus). Nevertheless, it is possible for a compositor to
+	 * require a special interaction to focus or unfocus layer shell
+	 * surfaces (e.g. requiring a click even if focus follows the mouse
+	 * normally, or providing a keybinding to switch focus between
+	 * layers).
+	 *
+	 * This setting is mainly intended for desktop shell components
+	 * (e.g. panels) that allow keyboard interaction. Using this option
+	 * can allow implementing a desktop shell that can be fully usable
+	 * without the mouse.
+	 * @since 4
+	 */
+	ZWLR_LAYER_SURFACE_V1_KEYBOARD_INTERACTIVITY_ON_DEMAND = 2,
+};
+/**
+ * @ingroup iface_zwlr_layer_surface_v1
+ */
+#define ZWLR_LAYER_SURFACE_V1_KEYBOARD_INTERACTIVITY_ON_DEMAND_SINCE_VERSION 4
+#endif /* ZWLR_LAYER_SURFACE_V1_KEYBOARD_INTERACTIVITY_ENUM */
+
+#ifndef ZWLR_LAYER_SURFACE_V1_ERROR_ENUM
+#define ZWLR_LAYER_SURFACE_V1_ERROR_ENUM
+enum zwlr_layer_surface_v1_error {
+	/**
+	 * provided surface state is invalid
+	 */
+	ZWLR_LAYER_SURFACE_V1_ERROR_INVALID_SURFACE_STATE = 0,
+	/**
+	 * size is invalid
+	 */
+	ZWLR_LAYER_SURFACE_V1_ERROR_INVALID_SIZE = 1,
+	/**
+	 * anchor bitfield is invalid
+	 */
+	ZWLR_LAYER_SURFACE_V1_ERROR_INVALID_ANCHOR = 2,
+	/**
+	 * keyboard interactivity is invalid
+	 */
+	ZWLR_LAYER_SURFACE_V1_ERROR_INVALID_KEYBOARD_INTERACTIVITY = 3,
+};
+#endif /* ZWLR_LAYER_SURFACE_V1_ERROR_ENUM */
+
+#ifndef ZWLR_LAYER_SURFACE_V1_ANCHOR_ENUM
+#define ZWLR_LAYER_SURFACE_V1_ANCHOR_ENUM
+enum zwlr_layer_surface_v1_anchor {
+	/**
+	 * the top edge of the anchor rectangle
+	 */
+	ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP = 1,
+	/**
+	 * the bottom edge of the anchor rectangle
+	 */
+	ZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM = 2,
+	/**
+	 * the left edge of the anchor rectangle
+	 */
+	ZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT = 4,
+	/**
+	 * the right edge of the anchor rectangle
+	 */
+	ZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT = 8,
+};
+#endif /* ZWLR_LAYER_SURFACE_V1_ANCHOR_ENUM */
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff '--color=auto' -urN dwl/wlr-output-power-management-unstable-v1-protocol.h mis_repos/dwl/wlr-output-power-management-unstable-v1-protocol.h
--- dwl/wlr-output-power-management-unstable-v1-protocol.h	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/wlr-output-power-management-unstable-v1-protocol.h	2024-10-01 23:08:38.156310572 +0200
@@ -0,0 +1,277 @@
+/* Generated by wayland-scanner 1.23.1 */
+
+#ifndef WLR_OUTPUT_POWER_MANAGEMENT_UNSTABLE_V1_SERVER_PROTOCOL_H
+#define WLR_OUTPUT_POWER_MANAGEMENT_UNSTABLE_V1_SERVER_PROTOCOL_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include "wayland-server.h"
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+struct wl_client;
+struct wl_resource;
+
+/**
+ * @page page_wlr_output_power_management_unstable_v1 The wlr_output_power_management_unstable_v1 protocol
+ * Control power management modes of outputs
+ *
+ * @section page_desc_wlr_output_power_management_unstable_v1 Description
+ *
+ * This protocol allows clients to control power management modes
+ * of outputs that are currently part of the compositor space. The
+ * intent is to allow special clients like desktop shells to power
+ * down outputs when the system is idle.
+ *
+ * To modify outputs not currently part of the compositor space see
+ * wlr-output-management.
+ *
+ * Warning! The protocol described in this file is experimental and
+ * backward incompatible changes may be made. Backward compatible changes
+ * may be added together with the corresponding interface version bump.
+ * Backward incompatible changes are done by bumping the version number in
+ * the protocol and interface names and resetting the interface version.
+ * Once the protocol is to be declared stable, the 'z' prefix and the
+ * version number in the protocol and interface names are removed and the
+ * interface version number is reset.
+ *
+ * @section page_ifaces_wlr_output_power_management_unstable_v1 Interfaces
+ * - @subpage page_iface_zwlr_output_power_manager_v1 - manager to create per-output power management
+ * - @subpage page_iface_zwlr_output_power_v1 - adjust power management mode for an output
+ * @section page_copyright_wlr_output_power_management_unstable_v1 Copyright
+ * <pre>
+ *
+ * Copyright Â© 2019 Purism SPC
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * </pre>
+ */
+struct wl_output;
+struct zwlr_output_power_manager_v1;
+struct zwlr_output_power_v1;
+
+#ifndef ZWLR_OUTPUT_POWER_MANAGER_V1_INTERFACE
+#define ZWLR_OUTPUT_POWER_MANAGER_V1_INTERFACE
+/**
+ * @page page_iface_zwlr_output_power_manager_v1 zwlr_output_power_manager_v1
+ * @section page_iface_zwlr_output_power_manager_v1_desc Description
+ *
+ * This interface is a manager that allows creating per-output power
+ * management mode controls.
+ * @section page_iface_zwlr_output_power_manager_v1_api API
+ * See @ref iface_zwlr_output_power_manager_v1.
+ */
+/**
+ * @defgroup iface_zwlr_output_power_manager_v1 The zwlr_output_power_manager_v1 interface
+ *
+ * This interface is a manager that allows creating per-output power
+ * management mode controls.
+ */
+extern const struct wl_interface zwlr_output_power_manager_v1_interface;
+#endif
+#ifndef ZWLR_OUTPUT_POWER_V1_INTERFACE
+#define ZWLR_OUTPUT_POWER_V1_INTERFACE
+/**
+ * @page page_iface_zwlr_output_power_v1 zwlr_output_power_v1
+ * @section page_iface_zwlr_output_power_v1_desc Description
+ *
+ * This object offers requests to set the power management mode of
+ * an output.
+ * @section page_iface_zwlr_output_power_v1_api API
+ * See @ref iface_zwlr_output_power_v1.
+ */
+/**
+ * @defgroup iface_zwlr_output_power_v1 The zwlr_output_power_v1 interface
+ *
+ * This object offers requests to set the power management mode of
+ * an output.
+ */
+extern const struct wl_interface zwlr_output_power_v1_interface;
+#endif
+
+/**
+ * @ingroup iface_zwlr_output_power_manager_v1
+ * @struct zwlr_output_power_manager_v1_interface
+ */
+struct zwlr_output_power_manager_v1_interface {
+	/**
+	 * get a power management for an output
+	 *
+	 * Create a output power management mode control that can be used
+	 * to adjust the power management mode for a given output.
+	 */
+	void (*get_output_power)(struct wl_client *client,
+				 struct wl_resource *resource,
+				 uint32_t id,
+				 struct wl_resource *output);
+	/**
+	 * destroy the manager
+	 *
+	 * All objects created by the manager will still remain valid,
+	 * until their appropriate destroy request has been called.
+	 */
+	void (*destroy)(struct wl_client *client,
+			struct wl_resource *resource);
+};
+
+
+/**
+ * @ingroup iface_zwlr_output_power_manager_v1
+ */
+#define ZWLR_OUTPUT_POWER_MANAGER_V1_GET_OUTPUT_POWER_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwlr_output_power_manager_v1
+ */
+#define ZWLR_OUTPUT_POWER_MANAGER_V1_DESTROY_SINCE_VERSION 1
+
+#ifndef ZWLR_OUTPUT_POWER_V1_MODE_ENUM
+#define ZWLR_OUTPUT_POWER_V1_MODE_ENUM
+enum zwlr_output_power_v1_mode {
+	/**
+	 * Output is turned off.
+	 */
+	ZWLR_OUTPUT_POWER_V1_MODE_OFF = 0,
+	/**
+	 * Output is turned on, no power saving
+	 */
+	ZWLR_OUTPUT_POWER_V1_MODE_ON = 1,
+};
+/**
+ * @ingroup iface_zwlr_output_power_v1
+ * Validate a zwlr_output_power_v1 mode value.
+ *
+ * @return true on success, false on error.
+ * @ref zwlr_output_power_v1_mode
+ */
+static inline bool
+zwlr_output_power_v1_mode_is_valid(uint32_t value, uint32_t version) {
+	switch (value) {
+	case ZWLR_OUTPUT_POWER_V1_MODE_OFF:
+		return version >= 1;
+	case ZWLR_OUTPUT_POWER_V1_MODE_ON:
+		return version >= 1;
+	default:
+		return false;
+	}
+}
+#endif /* ZWLR_OUTPUT_POWER_V1_MODE_ENUM */
+
+#ifndef ZWLR_OUTPUT_POWER_V1_ERROR_ENUM
+#define ZWLR_OUTPUT_POWER_V1_ERROR_ENUM
+enum zwlr_output_power_v1_error {
+	/**
+	 * inexistent power save mode
+	 */
+	ZWLR_OUTPUT_POWER_V1_ERROR_INVALID_MODE = 1,
+};
+/**
+ * @ingroup iface_zwlr_output_power_v1
+ * Validate a zwlr_output_power_v1 error value.
+ *
+ * @return true on success, false on error.
+ * @ref zwlr_output_power_v1_error
+ */
+static inline bool
+zwlr_output_power_v1_error_is_valid(uint32_t value, uint32_t version) {
+	switch (value) {
+	case ZWLR_OUTPUT_POWER_V1_ERROR_INVALID_MODE:
+		return version >= 1;
+	default:
+		return false;
+	}
+}
+#endif /* ZWLR_OUTPUT_POWER_V1_ERROR_ENUM */
+
+/**
+ * @ingroup iface_zwlr_output_power_v1
+ * @struct zwlr_output_power_v1_interface
+ */
+struct zwlr_output_power_v1_interface {
+	/**
+	 * Set an outputs power save mode
+	 *
+	 * Set an output's power save mode to the given mode. The mode
+	 * change is effective immediately. If the output does not support
+	 * the given mode a failed event is sent.
+	 * @param mode the power save mode to set
+	 */
+	void (*set_mode)(struct wl_client *client,
+			 struct wl_resource *resource,
+			 uint32_t mode);
+	/**
+	 * destroy this power management
+	 *
+	 * Destroys the output power management mode control object.
+	 */
+	void (*destroy)(struct wl_client *client,
+			struct wl_resource *resource);
+};
+
+#define ZWLR_OUTPUT_POWER_V1_MODE 0
+#define ZWLR_OUTPUT_POWER_V1_FAILED 1
+
+/**
+ * @ingroup iface_zwlr_output_power_v1
+ */
+#define ZWLR_OUTPUT_POWER_V1_MODE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwlr_output_power_v1
+ */
+#define ZWLR_OUTPUT_POWER_V1_FAILED_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zwlr_output_power_v1
+ */
+#define ZWLR_OUTPUT_POWER_V1_SET_MODE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwlr_output_power_v1
+ */
+#define ZWLR_OUTPUT_POWER_V1_DESTROY_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zwlr_output_power_v1
+ * Sends an mode event to the client owning the resource.
+ * @param resource_ The client's resource
+ * @param mode the output's new power management mode
+ */
+static inline void
+zwlr_output_power_v1_send_mode(struct wl_resource *resource_, uint32_t mode)
+{
+	wl_resource_post_event(resource_, ZWLR_OUTPUT_POWER_V1_MODE, mode);
+}
+
+/**
+ * @ingroup iface_zwlr_output_power_v1
+ * Sends an failed event to the client owning the resource.
+ * @param resource_ The client's resource
+ */
+static inline void
+zwlr_output_power_v1_send_failed(struct wl_resource *resource_)
+{
+	wl_resource_post_event(resource_, ZWLR_OUTPUT_POWER_V1_FAILED);
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff '--color=auto' -urN dwl/xdg-shell-protocol.h mis_repos/dwl/xdg-shell-protocol.h
--- dwl/xdg-shell-protocol.h	1970-01-01 01:00:00.000000000 +0100
+++ mis_repos/dwl/xdg-shell-protocol.h	2024-10-01 23:08:38.156310572 +0200
@@ -0,0 +1,2261 @@
+/* Generated by wayland-scanner 1.23.1 */
+
+#ifndef XDG_SHELL_SERVER_PROTOCOL_H
+#define XDG_SHELL_SERVER_PROTOCOL_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include "wayland-server.h"
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+struct wl_client;
+struct wl_resource;
+
+/**
+ * @page page_xdg_shell The xdg_shell protocol
+ * @section page_ifaces_xdg_shell Interfaces
+ * - @subpage page_iface_xdg_wm_base - create desktop-style surfaces
+ * - @subpage page_iface_xdg_positioner - child surface positioner
+ * - @subpage page_iface_xdg_surface - desktop user interface surface base interface
+ * - @subpage page_iface_xdg_toplevel - toplevel surface
+ * - @subpage page_iface_xdg_popup - short-lived, popup surfaces for menus
+ * @section page_copyright_xdg_shell Copyright
+ * <pre>
+ *
+ * Copyright Â© 2008-2013 Kristian HÃ¸gsberg
+ * Copyright Â© 2013      Rafael Antognolli
+ * Copyright Â© 2013      Jasper St. Pierre
+ * Copyright Â© 2010-2013 Intel Corporation
+ * Copyright Â© 2015-2017 Samsung Electronics Co., Ltd
+ * Copyright Â© 2015-2017 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * </pre>
+ */
+struct wl_output;
+struct wl_seat;
+struct wl_surface;
+struct xdg_popup;
+struct xdg_positioner;
+struct xdg_surface;
+struct xdg_toplevel;
+struct xdg_wm_base;
+
+#ifndef XDG_WM_BASE_INTERFACE
+#define XDG_WM_BASE_INTERFACE
+/**
+ * @page page_iface_xdg_wm_base xdg_wm_base
+ * @section page_iface_xdg_wm_base_desc Description
+ *
+ * The xdg_wm_base interface is exposed as a global object enabling clients
+ * to turn their wl_surfaces into windows in a desktop environment. It
+ * defines the basic functionality needed for clients and the compositor to
+ * create windows that can be dragged, resized, maximized, etc, as well as
+ * creating transient windows such as popup menus.
+ * @section page_iface_xdg_wm_base_api API
+ * See @ref iface_xdg_wm_base.
+ */
+/**
+ * @defgroup iface_xdg_wm_base The xdg_wm_base interface
+ *
+ * The xdg_wm_base interface is exposed as a global object enabling clients
+ * to turn their wl_surfaces into windows in a desktop environment. It
+ * defines the basic functionality needed for clients and the compositor to
+ * create windows that can be dragged, resized, maximized, etc, as well as
+ * creating transient windows such as popup menus.
+ */
+extern const struct wl_interface xdg_wm_base_interface;
+#endif
+#ifndef XDG_POSITIONER_INTERFACE
+#define XDG_POSITIONER_INTERFACE
+/**
+ * @page page_iface_xdg_positioner xdg_positioner
+ * @section page_iface_xdg_positioner_desc Description
+ *
+ * The xdg_positioner provides a collection of rules for the placement of a
+ * child surface relative to a parent surface. Rules can be defined to ensure
+ * the child surface remains within the visible area's borders, and to
+ * specify how the child surface changes its position, such as sliding along
+ * an axis, or flipping around a rectangle. These positioner-created rules are
+ * constrained by the requirement that a child surface must intersect with or
+ * be at least partially adjacent to its parent surface.
+ *
+ * See the various requests for details about possible rules.
+ *
+ * At the time of the request, the compositor makes a copy of the rules
+ * specified by the xdg_positioner. Thus, after the request is complete the
+ * xdg_positioner object can be destroyed or reused; further changes to the
+ * object will have no effect on previous usages.
+ *
+ * For an xdg_positioner object to be considered complete, it must have a
+ * non-zero size set by set_size, and a non-zero anchor rectangle set by
+ * set_anchor_rect. Passing an incomplete xdg_positioner object when
+ * positioning a surface raises an invalid_positioner error.
+ * @section page_iface_xdg_positioner_api API
+ * See @ref iface_xdg_positioner.
+ */
+/**
+ * @defgroup iface_xdg_positioner The xdg_positioner interface
+ *
+ * The xdg_positioner provides a collection of rules for the placement of a
+ * child surface relative to a parent surface. Rules can be defined to ensure
+ * the child surface remains within the visible area's borders, and to
+ * specify how the child surface changes its position, such as sliding along
+ * an axis, or flipping around a rectangle. These positioner-created rules are
+ * constrained by the requirement that a child surface must intersect with or
+ * be at least partially adjacent to its parent surface.
+ *
+ * See the various requests for details about possible rules.
+ *
+ * At the time of the request, the compositor makes a copy of the rules
+ * specified by the xdg_positioner. Thus, after the request is complete the
+ * xdg_positioner object can be destroyed or reused; further changes to the
+ * object will have no effect on previous usages.
+ *
+ * For an xdg_positioner object to be considered complete, it must have a
+ * non-zero size set by set_size, and a non-zero anchor rectangle set by
+ * set_anchor_rect. Passing an incomplete xdg_positioner object when
+ * positioning a surface raises an invalid_positioner error.
+ */
+extern const struct wl_interface xdg_positioner_interface;
+#endif
+#ifndef XDG_SURFACE_INTERFACE
+#define XDG_SURFACE_INTERFACE
+/**
+ * @page page_iface_xdg_surface xdg_surface
+ * @section page_iface_xdg_surface_desc Description
+ *
+ * An interface that may be implemented by a wl_surface, for
+ * implementations that provide a desktop-style user interface.
+ *
+ * It provides a base set of functionality required to construct user
+ * interface elements requiring management by the compositor, such as
+ * toplevel windows, menus, etc. The types of functionality are split into
+ * xdg_surface roles.
+ *
+ * Creating an xdg_surface does not set the role for a wl_surface. In order
+ * to map an xdg_surface, the client must create a role-specific object
+ * using, e.g., get_toplevel, get_popup. The wl_surface for any given
+ * xdg_surface can have at most one role, and may not be assigned any role
+ * not based on xdg_surface.
+ *
+ * A role must be assigned before any other requests are made to the
+ * xdg_surface object.
+ *
+ * The client must call wl_surface.commit on the corresponding wl_surface
+ * for the xdg_surface state to take effect.
+ *
+ * Creating an xdg_surface from a wl_surface which has a buffer attached or
+ * committed is a client error, and any attempts by a client to attach or
+ * manipulate a buffer prior to the first xdg_surface.configure call must
+ * also be treated as errors.
+ *
+ * After creating a role-specific object and setting it up, the client must
+ * perform an initial commit without any buffer attached. The compositor
+ * will reply with initial wl_surface state such as
+ * wl_surface.preferred_buffer_scale followed by an xdg_surface.configure
+ * event. The client must acknowledge it and is then allowed to attach a
+ * buffer to map the surface.
+ *
+ * Mapping an xdg_surface-based role surface is defined as making it
+ * possible for the surface to be shown by the compositor. Note that
+ * a mapped surface is not guaranteed to be visible once it is mapped.
+ *
+ * For an xdg_surface to be mapped by the compositor, the following
+ * conditions must be met:
+ * (1) the client has assigned an xdg_surface-based role to the surface
+ * (2) the client has set and committed the xdg_surface state and the
+ * role-dependent state to the surface
+ * (3) the client has committed a buffer to the surface
+ *
+ * A newly-unmapped surface is considered to have met condition (1) out
+ * of the 3 required conditions for mapping a surface if its role surface
+ * has not been destroyed, i.e. the client must perform the initial commit
+ * again before attaching a buffer.
+ * @section page_iface_xdg_surface_api API
+ * See @ref iface_xdg_surface.
+ */
+/**
+ * @defgroup iface_xdg_surface The xdg_surface interface
+ *
+ * An interface that may be implemented by a wl_surface, for
+ * implementations that provide a desktop-style user interface.
+ *
+ * It provides a base set of functionality required to construct user
+ * interface elements requiring management by the compositor, such as
+ * toplevel windows, menus, etc. The types of functionality are split into
+ * xdg_surface roles.
+ *
+ * Creating an xdg_surface does not set the role for a wl_surface. In order
+ * to map an xdg_surface, the client must create a role-specific object
+ * using, e.g., get_toplevel, get_popup. The wl_surface for any given
+ * xdg_surface can have at most one role, and may not be assigned any role
+ * not based on xdg_surface.
+ *
+ * A role must be assigned before any other requests are made to the
+ * xdg_surface object.
+ *
+ * The client must call wl_surface.commit on the corresponding wl_surface
+ * for the xdg_surface state to take effect.
+ *
+ * Creating an xdg_surface from a wl_surface which has a buffer attached or
+ * committed is a client error, and any attempts by a client to attach or
+ * manipulate a buffer prior to the first xdg_surface.configure call must
+ * also be treated as errors.
+ *
+ * After creating a role-specific object and setting it up, the client must
+ * perform an initial commit without any buffer attached. The compositor
+ * will reply with initial wl_surface state such as
+ * wl_surface.preferred_buffer_scale followed by an xdg_surface.configure
+ * event. The client must acknowledge it and is then allowed to attach a
+ * buffer to map the surface.
+ *
+ * Mapping an xdg_surface-based role surface is defined as making it
+ * possible for the surface to be shown by the compositor. Note that
+ * a mapped surface is not guaranteed to be visible once it is mapped.
+ *
+ * For an xdg_surface to be mapped by the compositor, the following
+ * conditions must be met:
+ * (1) the client has assigned an xdg_surface-based role to the surface
+ * (2) the client has set and committed the xdg_surface state and the
+ * role-dependent state to the surface
+ * (3) the client has committed a buffer to the surface
+ *
+ * A newly-unmapped surface is considered to have met condition (1) out
+ * of the 3 required conditions for mapping a surface if its role surface
+ * has not been destroyed, i.e. the client must perform the initial commit
+ * again before attaching a buffer.
+ */
+extern const struct wl_interface xdg_surface_interface;
+#endif
+#ifndef XDG_TOPLEVEL_INTERFACE
+#define XDG_TOPLEVEL_INTERFACE
+/**
+ * @page page_iface_xdg_toplevel xdg_toplevel
+ * @section page_iface_xdg_toplevel_desc Description
+ *
+ * This interface defines an xdg_surface role which allows a surface to,
+ * among other things, set window-like properties such as maximize,
+ * fullscreen, and minimize, set application-specific metadata like title and
+ * id, and well as trigger user interactive operations such as interactive
+ * resize and move.
+ *
+ * A xdg_toplevel by default is responsible for providing the full intended
+ * visual representation of the toplevel, which depending on the window
+ * state, may mean things like a title bar, window controls and drop shadow.
+ *
+ * Unmapping an xdg_toplevel means that the surface cannot be shown
+ * by the compositor until it is explicitly mapped again.
+ * All active operations (e.g., move, resize) are canceled and all
+ * attributes (e.g. title, state, stacking, ...) are discarded for
+ * an xdg_toplevel surface when it is unmapped. The xdg_toplevel returns to
+ * the state it had right after xdg_surface.get_toplevel. The client
+ * can re-map the toplevel by performing a commit without any buffer
+ * attached, waiting for a configure event and handling it as usual (see
+ * xdg_surface description).
+ *
+ * Attaching a null buffer to a toplevel unmaps the surface.
+ * @section page_iface_xdg_toplevel_api API
+ * See @ref iface_xdg_toplevel.
+ */
+/**
+ * @defgroup iface_xdg_toplevel The xdg_toplevel interface
+ *
+ * This interface defines an xdg_surface role which allows a surface to,
+ * among other things, set window-like properties such as maximize,
+ * fullscreen, and minimize, set application-specific metadata like title and
+ * id, and well as trigger user interactive operations such as interactive
+ * resize and move.
+ *
+ * A xdg_toplevel by default is responsible for providing the full intended
+ * visual representation of the toplevel, which depending on the window
+ * state, may mean things like a title bar, window controls and drop shadow.
+ *
+ * Unmapping an xdg_toplevel means that the surface cannot be shown
+ * by the compositor until it is explicitly mapped again.
+ * All active operations (e.g., move, resize) are canceled and all
+ * attributes (e.g. title, state, stacking, ...) are discarded for
+ * an xdg_toplevel surface when it is unmapped. The xdg_toplevel returns to
+ * the state it had right after xdg_surface.get_toplevel. The client
+ * can re-map the toplevel by performing a commit without any buffer
+ * attached, waiting for a configure event and handling it as usual (see
+ * xdg_surface description).
+ *
+ * Attaching a null buffer to a toplevel unmaps the surface.
+ */
+extern const struct wl_interface xdg_toplevel_interface;
+#endif
+#ifndef XDG_POPUP_INTERFACE
+#define XDG_POPUP_INTERFACE
+/**
+ * @page page_iface_xdg_popup xdg_popup
+ * @section page_iface_xdg_popup_desc Description
+ *
+ * A popup surface is a short-lived, temporary surface. It can be used to
+ * implement for example menus, popovers, tooltips and other similar user
+ * interface concepts.
+ *
+ * A popup can be made to take an explicit grab. See xdg_popup.grab for
+ * details.
+ *
+ * When the popup is dismissed, a popup_done event will be sent out, and at
+ * the same time the surface will be unmapped. See the xdg_popup.popup_done
+ * event for details.
+ *
+ * Explicitly destroying the xdg_popup object will also dismiss the popup and
+ * unmap the surface. Clients that want to dismiss the popup when another
+ * surface of their own is clicked should dismiss the popup using the destroy
+ * request.
+ *
+ * A newly created xdg_popup will be stacked on top of all previously created
+ * xdg_popup surfaces associated with the same xdg_toplevel.
+ *
+ * The parent of an xdg_popup must be mapped (see the xdg_surface
+ * description) before the xdg_popup itself.
+ *
+ * The client must call wl_surface.commit on the corresponding wl_surface
+ * for the xdg_popup state to take effect.
+ * @section page_iface_xdg_popup_api API
+ * See @ref iface_xdg_popup.
+ */
+/**
+ * @defgroup iface_xdg_popup The xdg_popup interface
+ *
+ * A popup surface is a short-lived, temporary surface. It can be used to
+ * implement for example menus, popovers, tooltips and other similar user
+ * interface concepts.
+ *
+ * A popup can be made to take an explicit grab. See xdg_popup.grab for
+ * details.
+ *
+ * When the popup is dismissed, a popup_done event will be sent out, and at
+ * the same time the surface will be unmapped. See the xdg_popup.popup_done
+ * event for details.
+ *
+ * Explicitly destroying the xdg_popup object will also dismiss the popup and
+ * unmap the surface. Clients that want to dismiss the popup when another
+ * surface of their own is clicked should dismiss the popup using the destroy
+ * request.
+ *
+ * A newly created xdg_popup will be stacked on top of all previously created
+ * xdg_popup surfaces associated with the same xdg_toplevel.
+ *
+ * The parent of an xdg_popup must be mapped (see the xdg_surface
+ * description) before the xdg_popup itself.
+ *
+ * The client must call wl_surface.commit on the corresponding wl_surface
+ * for the xdg_popup state to take effect.
+ */
+extern const struct wl_interface xdg_popup_interface;
+#endif
+
+#ifndef XDG_WM_BASE_ERROR_ENUM
+#define XDG_WM_BASE_ERROR_ENUM
+enum xdg_wm_base_error {
+	/**
+	 * given wl_surface has another role
+	 */
+	XDG_WM_BASE_ERROR_ROLE = 0,
+	/**
+	 * xdg_wm_base was destroyed before children
+	 */
+	XDG_WM_BASE_ERROR_DEFUNCT_SURFACES = 1,
+	/**
+	 * the client tried to map or destroy a non-topmost popup
+	 */
+	XDG_WM_BASE_ERROR_NOT_THE_TOPMOST_POPUP = 2,
+	/**
+	 * the client specified an invalid popup parent surface
+	 */
+	XDG_WM_BASE_ERROR_INVALID_POPUP_PARENT = 3,
+	/**
+	 * the client provided an invalid surface state
+	 */
+	XDG_WM_BASE_ERROR_INVALID_SURFACE_STATE = 4,
+	/**
+	 * the client provided an invalid positioner
+	 */
+	XDG_WM_BASE_ERROR_INVALID_POSITIONER = 5,
+	/**
+	 * the client didnâ€™t respond to a ping event in time
+	 */
+	XDG_WM_BASE_ERROR_UNRESPONSIVE = 6,
+};
+/**
+ * @ingroup iface_xdg_wm_base
+ * Validate a xdg_wm_base error value.
+ *
+ * @return true on success, false on error.
+ * @ref xdg_wm_base_error
+ */
+static inline bool
+xdg_wm_base_error_is_valid(uint32_t value, uint32_t version) {
+	switch (value) {
+	case XDG_WM_BASE_ERROR_ROLE:
+		return version >= 1;
+	case XDG_WM_BASE_ERROR_DEFUNCT_SURFACES:
+		return version >= 1;
+	case XDG_WM_BASE_ERROR_NOT_THE_TOPMOST_POPUP:
+		return version >= 1;
+	case XDG_WM_BASE_ERROR_INVALID_POPUP_PARENT:
+		return version >= 1;
+	case XDG_WM_BASE_ERROR_INVALID_SURFACE_STATE:
+		return version >= 1;
+	case XDG_WM_BASE_ERROR_INVALID_POSITIONER:
+		return version >= 1;
+	case XDG_WM_BASE_ERROR_UNRESPONSIVE:
+		return version >= 1;
+	default:
+		return false;
+	}
+}
+#endif /* XDG_WM_BASE_ERROR_ENUM */
+
+/**
+ * @ingroup iface_xdg_wm_base
+ * @struct xdg_wm_base_interface
+ */
+struct xdg_wm_base_interface {
+	/**
+	 * destroy xdg_wm_base
+	 *
+	 * Destroy this xdg_wm_base object.
+	 *
+	 * Destroying a bound xdg_wm_base object while there are surfaces
+	 * still alive created by this xdg_wm_base object instance is
+	 * illegal and will result in a defunct_surfaces error.
+	 */
+	void (*destroy)(struct wl_client *client,
+			struct wl_resource *resource);
+	/**
+	 * create a positioner object
+	 *
+	 * Create a positioner object. A positioner object is used to
+	 * position surfaces relative to some parent surface. See the
+	 * interface description and xdg_surface.get_popup for details.
+	 */
+	void (*create_positioner)(struct wl_client *client,
+				  struct wl_resource *resource,
+				  uint32_t id);
+	/**
+	 * create a shell surface from a surface
+	 *
+	 * This creates an xdg_surface for the given surface. While
+	 * xdg_surface itself is not a role, the corresponding surface may
+	 * only be assigned a role extending xdg_surface, such as
+	 * xdg_toplevel or xdg_popup. It is illegal to create an
+	 * xdg_surface for a wl_surface which already has an assigned role
+	 * and this will result in a role error.
+	 *
+	 * This creates an xdg_surface for the given surface. An
+	 * xdg_surface is used as basis to define a role to a given
+	 * surface, such as xdg_toplevel or xdg_popup. It also manages
+	 * functionality shared between xdg_surface based surface roles.
+	 *
+	 * See the documentation of xdg_surface for more details about what
+	 * an xdg_surface is and how it is used.
+	 */
+	void (*get_xdg_surface)(struct wl_client *client,
+				struct wl_resource *resource,
+				uint32_t id,
+				struct wl_resource *surface);
+	/**
+	 * respond to a ping event
+	 *
+	 * A client must respond to a ping event with a pong request or
+	 * the client may be deemed unresponsive. See xdg_wm_base.ping and
+	 * xdg_wm_base.error.unresponsive.
+	 * @param serial serial of the ping event
+	 */
+	void (*pong)(struct wl_client *client,
+		     struct wl_resource *resource,
+		     uint32_t serial);
+};
+
+#define XDG_WM_BASE_PING 0
+
+/**
+ * @ingroup iface_xdg_wm_base
+ */
+#define XDG_WM_BASE_PING_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_xdg_wm_base
+ */
+#define XDG_WM_BASE_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_wm_base
+ */
+#define XDG_WM_BASE_CREATE_POSITIONER_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_wm_base
+ */
+#define XDG_WM_BASE_GET_XDG_SURFACE_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_wm_base
+ */
+#define XDG_WM_BASE_PONG_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_xdg_wm_base
+ * Sends an ping event to the client owning the resource.
+ * @param resource_ The client's resource
+ * @param serial pass this to the pong request
+ */
+static inline void
+xdg_wm_base_send_ping(struct wl_resource *resource_, uint32_t serial)
+{
+	wl_resource_post_event(resource_, XDG_WM_BASE_PING, serial);
+}
+
+#ifndef XDG_POSITIONER_ERROR_ENUM
+#define XDG_POSITIONER_ERROR_ENUM
+enum xdg_positioner_error {
+	/**
+	 * invalid input provided
+	 */
+	XDG_POSITIONER_ERROR_INVALID_INPUT = 0,
+};
+/**
+ * @ingroup iface_xdg_positioner
+ * Validate a xdg_positioner error value.
+ *
+ * @return true on success, false on error.
+ * @ref xdg_positioner_error
+ */
+static inline bool
+xdg_positioner_error_is_valid(uint32_t value, uint32_t version) {
+	switch (value) {
+	case XDG_POSITIONER_ERROR_INVALID_INPUT:
+		return version >= 1;
+	default:
+		return false;
+	}
+}
+#endif /* XDG_POSITIONER_ERROR_ENUM */
+
+#ifndef XDG_POSITIONER_ANCHOR_ENUM
+#define XDG_POSITIONER_ANCHOR_ENUM
+enum xdg_positioner_anchor {
+	XDG_POSITIONER_ANCHOR_NONE = 0,
+	XDG_POSITIONER_ANCHOR_TOP = 1,
+	XDG_POSITIONER_ANCHOR_BOTTOM = 2,
+	XDG_POSITIONER_ANCHOR_LEFT = 3,
+	XDG_POSITIONER_ANCHOR_RIGHT = 4,
+	XDG_POSITIONER_ANCHOR_TOP_LEFT = 5,
+	XDG_POSITIONER_ANCHOR_BOTTOM_LEFT = 6,
+	XDG_POSITIONER_ANCHOR_TOP_RIGHT = 7,
+	XDG_POSITIONER_ANCHOR_BOTTOM_RIGHT = 8,
+};
+/**
+ * @ingroup iface_xdg_positioner
+ * Validate a xdg_positioner anchor value.
+ *
+ * @return true on success, false on error.
+ * @ref xdg_positioner_anchor
+ */
+static inline bool
+xdg_positioner_anchor_is_valid(uint32_t value, uint32_t version) {
+	switch (value) {
+	case XDG_POSITIONER_ANCHOR_NONE:
+		return version >= 1;
+	case XDG_POSITIONER_ANCHOR_TOP:
+		return version >= 1;
+	case XDG_POSITIONER_ANCHOR_BOTTOM:
+		return version >= 1;
+	case XDG_POSITIONER_ANCHOR_LEFT:
+		return version >= 1;
+	case XDG_POSITIONER_ANCHOR_RIGHT:
+		return version >= 1;
+	case XDG_POSITIONER_ANCHOR_TOP_LEFT:
+		return version >= 1;
+	case XDG_POSITIONER_ANCHOR_BOTTOM_LEFT:
+		return version >= 1;
+	case XDG_POSITIONER_ANCHOR_TOP_RIGHT:
+		return version >= 1;
+	case XDG_POSITIONER_ANCHOR_BOTTOM_RIGHT:
+		return version >= 1;
+	default:
+		return false;
+	}
+}
+#endif /* XDG_POSITIONER_ANCHOR_ENUM */
+
+#ifndef XDG_POSITIONER_GRAVITY_ENUM
+#define XDG_POSITIONER_GRAVITY_ENUM
+enum xdg_positioner_gravity {
+	XDG_POSITIONER_GRAVITY_NONE = 0,
+	XDG_POSITIONER_GRAVITY_TOP = 1,
+	XDG_POSITIONER_GRAVITY_BOTTOM = 2,
+	XDG_POSITIONER_GRAVITY_LEFT = 3,
+	XDG_POSITIONER_GRAVITY_RIGHT = 4,
+	XDG_POSITIONER_GRAVITY_TOP_LEFT = 5,
+	XDG_POSITIONER_GRAVITY_BOTTOM_LEFT = 6,
+	XDG_POSITIONER_GRAVITY_TOP_RIGHT = 7,
+	XDG_POSITIONER_GRAVITY_BOTTOM_RIGHT = 8,
+};
+/**
+ * @ingroup iface_xdg_positioner
+ * Validate a xdg_positioner gravity value.
+ *
+ * @return true on success, false on error.
+ * @ref xdg_positioner_gravity
+ */
+static inline bool
+xdg_positioner_gravity_is_valid(uint32_t value, uint32_t version) {
+	switch (value) {
+	case XDG_POSITIONER_GRAVITY_NONE:
+		return version >= 1;
+	case XDG_POSITIONER_GRAVITY_TOP:
+		return version >= 1;
+	case XDG_POSITIONER_GRAVITY_BOTTOM:
+		return version >= 1;
+	case XDG_POSITIONER_GRAVITY_LEFT:
+		return version >= 1;
+	case XDG_POSITIONER_GRAVITY_RIGHT:
+		return version >= 1;
+	case XDG_POSITIONER_GRAVITY_TOP_LEFT:
+		return version >= 1;
+	case XDG_POSITIONER_GRAVITY_BOTTOM_LEFT:
+		return version >= 1;
+	case XDG_POSITIONER_GRAVITY_TOP_RIGHT:
+		return version >= 1;
+	case XDG_POSITIONER_GRAVITY_BOTTOM_RIGHT:
+		return version >= 1;
+	default:
+		return false;
+	}
+}
+#endif /* XDG_POSITIONER_GRAVITY_ENUM */
+
+#ifndef XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_ENUM
+#define XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_ENUM
+/**
+ * @ingroup iface_xdg_positioner
+ * constraint adjustments
+ *
+ * The constraint adjustment value define ways the compositor will adjust
+ * the position of the surface, if the unadjusted position would result
+ * in the surface being partly constrained.
+ *
+ * Whether a surface is considered 'constrained' is left to the compositor
+ * to determine. For example, the surface may be partly outside the
+ * compositor's defined 'work area', thus necessitating the child surface's
+ * position be adjusted until it is entirely inside the work area.
+ *
+ * The adjustments can be combined, according to a defined precedence: 1)
+ * Flip, 2) Slide, 3) Resize.
+ */
+enum xdg_positioner_constraint_adjustment {
+	/**
+	 * don't move the child surface when constrained
+	 *
+	 * Don't alter the surface position even if it is constrained on
+	 * some axis, for example partially outside the edge of an output.
+	 */
+	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_NONE = 0,
+	/**
+	 * move along the x axis until unconstrained
+	 *
+	 * Slide the surface along the x axis until it is no longer
+	 * constrained.
+	 *
+	 * First try to slide towards the direction of the gravity on the x
+	 * axis until either the edge in the opposite direction of the
+	 * gravity is unconstrained or the edge in the direction of the
+	 * gravity is constrained.
+	 *
+	 * Then try to slide towards the opposite direction of the gravity
+	 * on the x axis until either the edge in the direction of the
+	 * gravity is unconstrained or the edge in the opposite direction
+	 * of the gravity is constrained.
+	 */
+	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_SLIDE_X = 1,
+	/**
+	 * move along the y axis until unconstrained
+	 *
+	 * Slide the surface along the y axis until it is no longer
+	 * constrained.
+	 *
+	 * First try to slide towards the direction of the gravity on the y
+	 * axis until either the edge in the opposite direction of the
+	 * gravity is unconstrained or the edge in the direction of the
+	 * gravity is constrained.
+	 *
+	 * Then try to slide towards the opposite direction of the gravity
+	 * on the y axis until either the edge in the direction of the
+	 * gravity is unconstrained or the edge in the opposite direction
+	 * of the gravity is constrained.
+	 */
+	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_SLIDE_Y = 2,
+	/**
+	 * invert the anchor and gravity on the x axis
+	 *
+	 * Invert the anchor and gravity on the x axis if the surface is
+	 * constrained on the x axis. For example, if the left edge of the
+	 * surface is constrained, the gravity is 'left' and the anchor is
+	 * 'left', change the gravity to 'right' and the anchor to 'right'.
+	 *
+	 * If the adjusted position also ends up being constrained, the
+	 * resulting position of the flip_x adjustment will be the one
+	 * before the adjustment.
+	 */
+	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_FLIP_X = 4,
+	/**
+	 * invert the anchor and gravity on the y axis
+	 *
+	 * Invert the anchor and gravity on the y axis if the surface is
+	 * constrained on the y axis. For example, if the bottom edge of
+	 * the surface is constrained, the gravity is 'bottom' and the
+	 * anchor is 'bottom', change the gravity to 'top' and the anchor
+	 * to 'top'.
+	 *
+	 * The adjusted position is calculated given the original anchor
+	 * rectangle and offset, but with the new flipped anchor and
+	 * gravity values.
+	 *
+	 * If the adjusted position also ends up being constrained, the
+	 * resulting position of the flip_y adjustment will be the one
+	 * before the adjustment.
+	 */
+	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_FLIP_Y = 8,
+	/**
+	 * horizontally resize the surface
+	 *
+	 * Resize the surface horizontally so that it is completely
+	 * unconstrained.
+	 */
+	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_RESIZE_X = 16,
+	/**
+	 * vertically resize the surface
+	 *
+	 * Resize the surface vertically so that it is completely
+	 * unconstrained.
+	 */
+	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_RESIZE_Y = 32,
+};
+/**
+ * @ingroup iface_xdg_positioner
+ * Validate a xdg_positioner constraint_adjustment value.
+ *
+ * @return true on success, false on error.
+ * @ref xdg_positioner_constraint_adjustment
+ */
+static inline bool
+xdg_positioner_constraint_adjustment_is_valid(uint32_t value, uint32_t version) {
+	uint32_t valid = 0;
+	if (version >= 1)
+		valid |= XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_NONE;
+	if (version >= 1)
+		valid |= XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_SLIDE_X;
+	if (version >= 1)
+		valid |= XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_SLIDE_Y;
+	if (version >= 1)
+		valid |= XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_FLIP_X;
+	if (version >= 1)
+		valid |= XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_FLIP_Y;
+	if (version >= 1)
+		valid |= XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_RESIZE_X;
+	if (version >= 1)
+		valid |= XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_RESIZE_Y;
+	return (value & ~valid) == 0;
+}
+#endif /* XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_ENUM */
+
+/**
+ * @ingroup iface_xdg_positioner
+ * @struct xdg_positioner_interface
+ */
+struct xdg_positioner_interface {
+	/**
+	 * destroy the xdg_positioner object
+	 *
+	 * Notify the compositor that the xdg_positioner will no longer
+	 * be used.
+	 */
+	void (*destroy)(struct wl_client *client,
+			struct wl_resource *resource);
+	/**
+	 * set the size of the to-be positioned rectangle
+	 *
+	 * Set the size of the surface that is to be positioned with the
+	 * positioner object. The size is in surface-local coordinates and
+	 * corresponds to the window geometry. See
+	 * xdg_surface.set_window_geometry.
+	 *
+	 * If a zero or negative size is set the invalid_input error is
+	 * raised.
+	 * @param width width of positioned rectangle
+	 * @param height height of positioned rectangle
+	 */
+	void (*set_size)(struct wl_client *client,
+			 struct wl_resource *resource,
+			 int32_t width,
+			 int32_t height);
+	/**
+	 * set the anchor rectangle within the parent surface
+	 *
+	 * Specify the anchor rectangle within the parent surface that
+	 * the child surface will be placed relative to. The rectangle is
+	 * relative to the window geometry as defined by
+	 * xdg_surface.set_window_geometry of the parent surface.
+	 *
+	 * When the xdg_positioner object is used to position a child
+	 * surface, the anchor rectangle may not extend outside the window
+	 * geometry of the positioned child's parent surface.
+	 *
+	 * If a negative size is set the invalid_input error is raised.
+	 * @param x x position of anchor rectangle
+	 * @param y y position of anchor rectangle
+	 * @param width width of anchor rectangle
+	 * @param height height of anchor rectangle
+	 */
+	void (*set_anchor_rect)(struct wl_client *client,
+				struct wl_resource *resource,
+				int32_t x,
+				int32_t y,
+				int32_t width,
+				int32_t height);
+	/**
+	 * set anchor rectangle anchor
+	 *
+	 * Defines the anchor point for the anchor rectangle. The
+	 * specified anchor is used derive an anchor point that the child
+	 * surface will be positioned relative to. If a corner anchor is
+	 * set (e.g. 'top_left' or 'bottom_right'), the anchor point will
+	 * be at the specified corner; otherwise, the derived anchor point
+	 * will be centered on the specified edge, or in the center of the
+	 * anchor rectangle if no edge is specified.
+	 * @param anchor anchor
+	 */
+	void (*set_anchor)(struct wl_client *client,
+			   struct wl_resource *resource,
+			   uint32_t anchor);
+	/**
+	 * set child surface gravity
+	 *
+	 * Defines in what direction a surface should be positioned,
+	 * relative to the anchor point of the parent surface. If a corner
+	 * gravity is specified (e.g. 'bottom_right' or 'top_left'), then
+	 * the child surface will be placed towards the specified gravity;
+	 * otherwise, the child surface will be centered over the anchor
+	 * point on any axis that had no gravity specified. If the gravity
+	 * is not in the â€˜gravityâ€™ enum, an invalid_input error is
+	 * raised.
+	 * @param gravity gravity direction
+	 */
+	void (*set_gravity)(struct wl_client *client,
+			    struct wl_resource *resource,
+			    uint32_t gravity);
+	/**
+	 * set the adjustment to be done when constrained
+	 *
+	 * Specify how the window should be positioned if the originally
+	 * intended position caused the surface to be constrained, meaning
+	 * at least partially outside positioning boundaries set by the
+	 * compositor. The adjustment is set by constructing a bitmask
+	 * describing the adjustment to be made when the surface is
+	 * constrained on that axis.
+	 *
+	 * If no bit for one axis is set, the compositor will assume that
+	 * the child surface should not change its position on that axis
+	 * when constrained.
+	 *
+	 * If more than one bit for one axis is set, the order of how
+	 * adjustments are applied is specified in the corresponding
+	 * adjustment descriptions.
+	 *
+	 * The default adjustment is none.
+	 * @param constraint_adjustment bit mask of constraint adjustments
+	 */
+	void (*set_constraint_adjustment)(struct wl_client *client,
+					  struct wl_resource *resource,
+					  uint32_t constraint_adjustment);
+	/**
+	 * set surface position offset
+	 *
+	 * Specify the surface position offset relative to the position
+	 * of the anchor on the anchor rectangle and the anchor on the
+	 * surface. For example if the anchor of the anchor rectangle is at
+	 * (x, y), the surface has the gravity bottom|right, and the offset
+	 * is (ox, oy), the calculated surface position will be (x + ox, y
+	 * + oy). The offset position of the surface is the one used for
+	 * constraint testing. See set_constraint_adjustment.
+	 *
+	 * An example use case is placing a popup menu on top of a user
+	 * interface element, while aligning the user interface element of
+	 * the parent surface with some user interface element placed
+	 * somewhere in the popup surface.
+	 * @param x surface position x offset
+	 * @param y surface position y offset
+	 */
+	void (*set_offset)(struct wl_client *client,
+			   struct wl_resource *resource,
+			   int32_t x,
+			   int32_t y);
+	/**
+	 * continuously reconstrain the surface
+	 *
+	 * When set reactive, the surface is reconstrained if the
+	 * conditions used for constraining changed, e.g. the parent window
+	 * moved.
+	 *
+	 * If the conditions changed and the popup was reconstrained, an
+	 * xdg_popup.configure event is sent with updated geometry,
+	 * followed by an xdg_surface.configure event.
+	 * @since 3
+	 */
+	void (*set_reactive)(struct wl_client *client,
+			     struct wl_resource *resource);
+	/**
+	 * 
+	 *
+	 * Set the parent window geometry the compositor should use when
+	 * positioning the popup. The compositor may use this information
+	 * to determine the future state the popup should be constrained
+	 * using. If this doesn't match the dimension of the parent the
+	 * popup is eventually positioned against, the behavior is
+	 * undefined.
+	 *
+	 * The arguments are given in the surface-local coordinate space.
+	 * @param parent_width future window geometry width of parent
+	 * @param parent_height future window geometry height of parent
+	 * @since 3
+	 */
+	void (*set_parent_size)(struct wl_client *client,
+				struct wl_resource *resource,
+				int32_t parent_width,
+				int32_t parent_height);
+	/**
+	 * set parent configure this is a response to
+	 *
+	 * Set the serial of an xdg_surface.configure event this
+	 * positioner will be used in response to. The compositor may use
+	 * this information together with set_parent_size to determine what
+	 * future state the popup should be constrained using.
+	 * @param serial serial of parent configure event
+	 * @since 3
+	 */
+	void (*set_parent_configure)(struct wl_client *client,
+				     struct wl_resource *resource,
+				     uint32_t serial);
+};
+
+
+/**
+ * @ingroup iface_xdg_positioner
+ */
+#define XDG_POSITIONER_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_positioner
+ */
+#define XDG_POSITIONER_SET_SIZE_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_positioner
+ */
+#define XDG_POSITIONER_SET_ANCHOR_RECT_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_positioner
+ */
+#define XDG_POSITIONER_SET_ANCHOR_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_positioner
+ */
+#define XDG_POSITIONER_SET_GRAVITY_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_positioner
+ */
+#define XDG_POSITIONER_SET_CONSTRAINT_ADJUSTMENT_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_positioner
+ */
+#define XDG_POSITIONER_SET_OFFSET_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_positioner
+ */
+#define XDG_POSITIONER_SET_REACTIVE_SINCE_VERSION 3
+/**
+ * @ingroup iface_xdg_positioner
+ */
+#define XDG_POSITIONER_SET_PARENT_SIZE_SINCE_VERSION 3
+/**
+ * @ingroup iface_xdg_positioner
+ */
+#define XDG_POSITIONER_SET_PARENT_CONFIGURE_SINCE_VERSION 3
+
+#ifndef XDG_SURFACE_ERROR_ENUM
+#define XDG_SURFACE_ERROR_ENUM
+enum xdg_surface_error {
+	/**
+	 * Surface was not fully constructed
+	 */
+	XDG_SURFACE_ERROR_NOT_CONSTRUCTED = 1,
+	/**
+	 * Surface was already constructed
+	 */
+	XDG_SURFACE_ERROR_ALREADY_CONSTRUCTED = 2,
+	/**
+	 * Attaching a buffer to an unconfigured surface
+	 */
+	XDG_SURFACE_ERROR_UNCONFIGURED_BUFFER = 3,
+	/**
+	 * Invalid serial number when acking a configure event
+	 */
+	XDG_SURFACE_ERROR_INVALID_SERIAL = 4,
+	/**
+	 * Width or height was zero or negative
+	 */
+	XDG_SURFACE_ERROR_INVALID_SIZE = 5,
+	/**
+	 * Surface was destroyed before its role object
+	 */
+	XDG_SURFACE_ERROR_DEFUNCT_ROLE_OBJECT = 6,
+};
+/**
+ * @ingroup iface_xdg_surface
+ * Validate a xdg_surface error value.
+ *
+ * @return true on success, false on error.
+ * @ref xdg_surface_error
+ */
+static inline bool
+xdg_surface_error_is_valid(uint32_t value, uint32_t version) {
+	switch (value) {
+	case XDG_SURFACE_ERROR_NOT_CONSTRUCTED:
+		return version >= 1;
+	case XDG_SURFACE_ERROR_ALREADY_CONSTRUCTED:
+		return version >= 1;
+	case XDG_SURFACE_ERROR_UNCONFIGURED_BUFFER:
+		return version >= 1;
+	case XDG_SURFACE_ERROR_INVALID_SERIAL:
+		return version >= 1;
+	case XDG_SURFACE_ERROR_INVALID_SIZE:
+		return version >= 1;
+	case XDG_SURFACE_ERROR_DEFUNCT_ROLE_OBJECT:
+		return version >= 1;
+	default:
+		return false;
+	}
+}
+#endif /* XDG_SURFACE_ERROR_ENUM */
+
+/**
+ * @ingroup iface_xdg_surface
+ * @struct xdg_surface_interface
+ */
+struct xdg_surface_interface {
+	/**
+	 * destroy the xdg_surface
+	 *
+	 * Destroy the xdg_surface object. An xdg_surface must only be
+	 * destroyed after its role object has been destroyed, otherwise a
+	 * defunct_role_object error is raised.
+	 */
+	void (*destroy)(struct wl_client *client,
+			struct wl_resource *resource);
+	/**
+	 * assign the xdg_toplevel surface role
+	 *
+	 * This creates an xdg_toplevel object for the given xdg_surface
+	 * and gives the associated wl_surface the xdg_toplevel role.
+	 *
+	 * See the documentation of xdg_toplevel for more details about
+	 * what an xdg_toplevel is and how it is used.
+	 */
+	void (*get_toplevel)(struct wl_client *client,
+			     struct wl_resource *resource,
+			     uint32_t id);
+	/**
+	 * assign the xdg_popup surface role
+	 *
+	 * This creates an xdg_popup object for the given xdg_surface and
+	 * gives the associated wl_surface the xdg_popup role.
+	 *
+	 * If null is passed as a parent, a parent surface must be
+	 * specified using some other protocol, before committing the
+	 * initial state.
+	 *
+	 * See the documentation of xdg_popup for more details about what
+	 * an xdg_popup is and how it is used.
+	 */
+	void (*get_popup)(struct wl_client *client,
+			  struct wl_resource *resource,
+			  uint32_t id,
+			  struct wl_resource *parent,
+			  struct wl_resource *positioner);
+	/**
+	 * set the new window geometry
+	 *
+	 * The window geometry of a surface is its "visible bounds" from
+	 * the user's perspective. Client-side decorations often have
+	 * invisible portions like drop-shadows which should be ignored for
+	 * the purposes of aligning, placing and constraining windows.
+	 *
+	 * The window geometry is double-buffered state, see
+	 * wl_surface.commit.
+	 *
+	 * When maintaining a position, the compositor should treat the (x,
+	 * y) coordinate of the window geometry as the top left corner of
+	 * the window. A client changing the (x, y) window geometry
+	 * coordinate should in general not alter the position of the
+	 * window.
+	 *
+	 * Once the window geometry of the surface is set, it is not
+	 * possible to unset it, and it will remain the same until
+	 * set_window_geometry is called again, even if a new subsurface or
+	 * buffer is attached.
+	 *
+	 * If never set, the value is the full bounds of the surface,
+	 * including any subsurfaces. This updates dynamically on every
+	 * commit. This unset is meant for extremely simple clients.
+	 *
+	 * The arguments are given in the surface-local coordinate space of
+	 * the wl_surface associated with this xdg_surface, and may extend
+	 * outside of the wl_surface itself to mark parts of the subsurface
+	 * tree as part of the window geometry.
+	 *
+	 * When applied, the effective window geometry will be the set
+	 * window geometry clamped to the bounding rectangle of the
+	 * combined geometry of the surface of the xdg_surface and the
+	 * associated subsurfaces.
+	 *
+	 * The effective geometry will not be recalculated unless a new
+	 * call to set_window_geometry is done and the new pending surface
+	 * state is subsequently applied.
+	 *
+	 * The width and height of the effective window geometry must be
+	 * greater than zero. Setting an invalid size will raise an
+	 * invalid_size error.
+	 */
+	void (*set_window_geometry)(struct wl_client *client,
+				    struct wl_resource *resource,
+				    int32_t x,
+				    int32_t y,
+				    int32_t width,
+				    int32_t height);
+	/**
+	 * ack a configure event
+	 *
+	 * When a configure event is received, if a client commits the
+	 * surface in response to the configure event, then the client must
+	 * make an ack_configure request sometime before the commit
+	 * request, passing along the serial of the configure event.
+	 *
+	 * For instance, for toplevel surfaces the compositor might use
+	 * this information to move a surface to the top left only when the
+	 * client has drawn itself for the maximized or fullscreen state.
+	 *
+	 * If the client receives multiple configure events before it can
+	 * respond to one, it only has to ack the last configure event.
+	 * Acking a configure event that was never sent raises an
+	 * invalid_serial error.
+	 *
+	 * A client is not required to commit immediately after sending an
+	 * ack_configure request - it may even ack_configure several times
+	 * before its next surface commit.
+	 *
+	 * A client may send multiple ack_configure requests before
+	 * committing, but only the last request sent before a commit
+	 * indicates which configure event the client really is responding
+	 * to.
+	 *
+	 * Sending an ack_configure request consumes the serial number sent
+	 * with the request, as well as serial numbers sent by all
+	 * configure events sent on this xdg_surface prior to the configure
+	 * event referenced by the committed serial.
+	 *
+	 * It is an error to issue multiple ack_configure requests
+	 * referencing a serial from the same configure event, or to issue
+	 * an ack_configure request referencing a serial from a configure
+	 * event issued before the event identified by the last
+	 * ack_configure request for the same xdg_surface. Doing so will
+	 * raise an invalid_serial error.
+	 * @param serial the serial from the configure event
+	 */
+	void (*ack_configure)(struct wl_client *client,
+			      struct wl_resource *resource,
+			      uint32_t serial);
+};
+
+#define XDG_SURFACE_CONFIGURE 0
+
+/**
+ * @ingroup iface_xdg_surface
+ */
+#define XDG_SURFACE_CONFIGURE_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_xdg_surface
+ */
+#define XDG_SURFACE_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_surface
+ */
+#define XDG_SURFACE_GET_TOPLEVEL_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_surface
+ */
+#define XDG_SURFACE_GET_POPUP_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_surface
+ */
+#define XDG_SURFACE_SET_WINDOW_GEOMETRY_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_surface
+ */
+#define XDG_SURFACE_ACK_CONFIGURE_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_xdg_surface
+ * Sends an configure event to the client owning the resource.
+ * @param resource_ The client's resource
+ * @param serial serial of the configure event
+ */
+static inline void
+xdg_surface_send_configure(struct wl_resource *resource_, uint32_t serial)
+{
+	wl_resource_post_event(resource_, XDG_SURFACE_CONFIGURE, serial);
+}
+
+#ifndef XDG_TOPLEVEL_ERROR_ENUM
+#define XDG_TOPLEVEL_ERROR_ENUM
+enum xdg_toplevel_error {
+	/**
+	 * provided value is         not a valid variant of the resize_edge enum
+	 */
+	XDG_TOPLEVEL_ERROR_INVALID_RESIZE_EDGE = 0,
+	/**
+	 * invalid parent toplevel
+	 */
+	XDG_TOPLEVEL_ERROR_INVALID_PARENT = 1,
+	/**
+	 * client provided an invalid min or max size
+	 */
+	XDG_TOPLEVEL_ERROR_INVALID_SIZE = 2,
+};
+/**
+ * @ingroup iface_xdg_toplevel
+ * Validate a xdg_toplevel error value.
+ *
+ * @return true on success, false on error.
+ * @ref xdg_toplevel_error
+ */
+static inline bool
+xdg_toplevel_error_is_valid(uint32_t value, uint32_t version) {
+	switch (value) {
+	case XDG_TOPLEVEL_ERROR_INVALID_RESIZE_EDGE:
+		return version >= 1;
+	case XDG_TOPLEVEL_ERROR_INVALID_PARENT:
+		return version >= 1;
+	case XDG_TOPLEVEL_ERROR_INVALID_SIZE:
+		return version >= 1;
+	default:
+		return false;
+	}
+}
+#endif /* XDG_TOPLEVEL_ERROR_ENUM */
+
+#ifndef XDG_TOPLEVEL_RESIZE_EDGE_ENUM
+#define XDG_TOPLEVEL_RESIZE_EDGE_ENUM
+/**
+ * @ingroup iface_xdg_toplevel
+ * edge values for resizing
+ *
+ * These values are used to indicate which edge of a surface
+ * is being dragged in a resize operation.
+ */
+enum xdg_toplevel_resize_edge {
+	XDG_TOPLEVEL_RESIZE_EDGE_NONE = 0,
+	XDG_TOPLEVEL_RESIZE_EDGE_TOP = 1,
+	XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM = 2,
+	XDG_TOPLEVEL_RESIZE_EDGE_LEFT = 4,
+	XDG_TOPLEVEL_RESIZE_EDGE_TOP_LEFT = 5,
+	XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_LEFT = 6,
+	XDG_TOPLEVEL_RESIZE_EDGE_RIGHT = 8,
+	XDG_TOPLEVEL_RESIZE_EDGE_TOP_RIGHT = 9,
+	XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_RIGHT = 10,
+};
+/**
+ * @ingroup iface_xdg_toplevel
+ * Validate a xdg_toplevel resize_edge value.
+ *
+ * @return true on success, false on error.
+ * @ref xdg_toplevel_resize_edge
+ */
+static inline bool
+xdg_toplevel_resize_edge_is_valid(uint32_t value, uint32_t version) {
+	switch (value) {
+	case XDG_TOPLEVEL_RESIZE_EDGE_NONE:
+		return version >= 1;
+	case XDG_TOPLEVEL_RESIZE_EDGE_TOP:
+		return version >= 1;
+	case XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM:
+		return version >= 1;
+	case XDG_TOPLEVEL_RESIZE_EDGE_LEFT:
+		return version >= 1;
+	case XDG_TOPLEVEL_RESIZE_EDGE_TOP_LEFT:
+		return version >= 1;
+	case XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_LEFT:
+		return version >= 1;
+	case XDG_TOPLEVEL_RESIZE_EDGE_RIGHT:
+		return version >= 1;
+	case XDG_TOPLEVEL_RESIZE_EDGE_TOP_RIGHT:
+		return version >= 1;
+	case XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_RIGHT:
+		return version >= 1;
+	default:
+		return false;
+	}
+}
+#endif /* XDG_TOPLEVEL_RESIZE_EDGE_ENUM */
+
+#ifndef XDG_TOPLEVEL_STATE_ENUM
+#define XDG_TOPLEVEL_STATE_ENUM
+/**
+ * @ingroup iface_xdg_toplevel
+ * types of state on the surface
+ *
+ * The different state values used on the surface. This is designed for
+ * state values like maximized, fullscreen. It is paired with the
+ * configure event to ensure that both the client and the compositor
+ * setting the state can be synchronized.
+ *
+ * States set in this way are double-buffered, see wl_surface.commit.
+ */
+enum xdg_toplevel_state {
+	/**
+	 * the surface is maximized
+	 * the surface is maximized
+	 *
+	 * The surface is maximized. The window geometry specified in the
+	 * configure event must be obeyed by the client, or the
+	 * xdg_wm_base.invalid_surface_state error is raised.
+	 *
+	 * The client should draw without shadow or other decoration
+	 * outside of the window geometry.
+	 */
+	XDG_TOPLEVEL_STATE_MAXIMIZED = 1,
+	/**
+	 * the surface is fullscreen
+	 * the surface is fullscreen
+	 *
+	 * The surface is fullscreen. The window geometry specified in
+	 * the configure event is a maximum; the client cannot resize
+	 * beyond it. For a surface to cover the whole fullscreened area,
+	 * the geometry dimensions must be obeyed by the client. For more
+	 * details, see xdg_toplevel.set_fullscreen.
+	 */
+	XDG_TOPLEVEL_STATE_FULLSCREEN = 2,
+	/**
+	 * the surface is being resized
+	 * the surface is being resized
+	 *
+	 * The surface is being resized. The window geometry specified in
+	 * the configure event is a maximum; the client cannot resize
+	 * beyond it. Clients that have aspect ratio or cell sizing
+	 * configuration can use a smaller size, however.
+	 */
+	XDG_TOPLEVEL_STATE_RESIZING = 3,
+	/**
+	 * the surface is now activated
+	 * the surface is now activated
+	 *
+	 * Client window decorations should be painted as if the window
+	 * is active. Do not assume this means that the window actually has
+	 * keyboard or pointer focus.
+	 */
+	XDG_TOPLEVEL_STATE_ACTIVATED = 4,
+	/**
+	 * the surfaceâ€™s left edge is tiled
+	 *
+	 * The window is currently in a tiled layout and the left edge is
+	 * considered to be adjacent to another part of the tiling grid.
+	 *
+	 * The client should draw without shadow or other decoration
+	 * outside of the window geometry on the left edge.
+	 * @since 2
+	 */
+	XDG_TOPLEVEL_STATE_TILED_LEFT = 5,
+	/**
+	 * the surfaceâ€™s right edge is tiled
+	 *
+	 * The window is currently in a tiled layout and the right edge
+	 * is considered to be adjacent to another part of the tiling grid.
+	 *
+	 * The client should draw without shadow or other decoration
+	 * outside of the window geometry on the right edge.
+	 * @since 2
+	 */
+	XDG_TOPLEVEL_STATE_TILED_RIGHT = 6,
+	/**
+	 * the surfaceâ€™s top edge is tiled
+	 *
+	 * The window is currently in a tiled layout and the top edge is
+	 * considered to be adjacent to another part of the tiling grid.
+	 *
+	 * The client should draw without shadow or other decoration
+	 * outside of the window geometry on the top edge.
+	 * @since 2
+	 */
+	XDG_TOPLEVEL_STATE_TILED_TOP = 7,
+	/**
+	 * the surfaceâ€™s bottom edge is tiled
+	 *
+	 * The window is currently in a tiled layout and the bottom edge
+	 * is considered to be adjacent to another part of the tiling grid.
+	 *
+	 * The client should draw without shadow or other decoration
+	 * outside of the window geometry on the bottom edge.
+	 * @since 2
+	 */
+	XDG_TOPLEVEL_STATE_TILED_BOTTOM = 8,
+	/**
+	 * surface repaint is suspended
+	 *
+	 * The surface is currently not ordinarily being repainted; for
+	 * example because its content is occluded by another window, or
+	 * its outputs are switched off due to screen locking.
+	 * @since 6
+	 */
+	XDG_TOPLEVEL_STATE_SUSPENDED = 9,
+};
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_STATE_TILED_LEFT_SINCE_VERSION 2
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_STATE_TILED_RIGHT_SINCE_VERSION 2
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_STATE_TILED_TOP_SINCE_VERSION 2
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_STATE_TILED_BOTTOM_SINCE_VERSION 2
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_STATE_SUSPENDED_SINCE_VERSION 6
+/**
+ * @ingroup iface_xdg_toplevel
+ * Validate a xdg_toplevel state value.
+ *
+ * @return true on success, false on error.
+ * @ref xdg_toplevel_state
+ */
+static inline bool
+xdg_toplevel_state_is_valid(uint32_t value, uint32_t version) {
+	switch (value) {
+	case XDG_TOPLEVEL_STATE_MAXIMIZED:
+		return version >= 1;
+	case XDG_TOPLEVEL_STATE_FULLSCREEN:
+		return version >= 1;
+	case XDG_TOPLEVEL_STATE_RESIZING:
+		return version >= 1;
+	case XDG_TOPLEVEL_STATE_ACTIVATED:
+		return version >= 1;
+	case XDG_TOPLEVEL_STATE_TILED_LEFT:
+		return version >= 2;
+	case XDG_TOPLEVEL_STATE_TILED_RIGHT:
+		return version >= 2;
+	case XDG_TOPLEVEL_STATE_TILED_TOP:
+		return version >= 2;
+	case XDG_TOPLEVEL_STATE_TILED_BOTTOM:
+		return version >= 2;
+	case XDG_TOPLEVEL_STATE_SUSPENDED:
+		return version >= 6;
+	default:
+		return false;
+	}
+}
+#endif /* XDG_TOPLEVEL_STATE_ENUM */
+
+#ifndef XDG_TOPLEVEL_WM_CAPABILITIES_ENUM
+#define XDG_TOPLEVEL_WM_CAPABILITIES_ENUM
+enum xdg_toplevel_wm_capabilities {
+	/**
+	 * show_window_menu is available
+	 */
+	XDG_TOPLEVEL_WM_CAPABILITIES_WINDOW_MENU = 1,
+	/**
+	 * set_maximized and unset_maximized are available
+	 */
+	XDG_TOPLEVEL_WM_CAPABILITIES_MAXIMIZE = 2,
+	/**
+	 * set_fullscreen and unset_fullscreen are available
+	 */
+	XDG_TOPLEVEL_WM_CAPABILITIES_FULLSCREEN = 3,
+	/**
+	 * set_minimized is available
+	 */
+	XDG_TOPLEVEL_WM_CAPABILITIES_MINIMIZE = 4,
+};
+/**
+ * @ingroup iface_xdg_toplevel
+ * Validate a xdg_toplevel wm_capabilities value.
+ *
+ * @return true on success, false on error.
+ * @ref xdg_toplevel_wm_capabilities
+ */
+static inline bool
+xdg_toplevel_wm_capabilities_is_valid(uint32_t value, uint32_t version) {
+	switch (value) {
+	case XDG_TOPLEVEL_WM_CAPABILITIES_WINDOW_MENU:
+		return version >= 1;
+	case XDG_TOPLEVEL_WM_CAPABILITIES_MAXIMIZE:
+		return version >= 1;
+	case XDG_TOPLEVEL_WM_CAPABILITIES_FULLSCREEN:
+		return version >= 1;
+	case XDG_TOPLEVEL_WM_CAPABILITIES_MINIMIZE:
+		return version >= 1;
+	default:
+		return false;
+	}
+}
+#endif /* XDG_TOPLEVEL_WM_CAPABILITIES_ENUM */
+
+/**
+ * @ingroup iface_xdg_toplevel
+ * @struct xdg_toplevel_interface
+ */
+struct xdg_toplevel_interface {
+	/**
+	 * destroy the xdg_toplevel
+	 *
+	 * This request destroys the role surface and unmaps the surface;
+	 * see "Unmapping" behavior in interface section for details.
+	 */
+	void (*destroy)(struct wl_client *client,
+			struct wl_resource *resource);
+	/**
+	 * set the parent of this surface
+	 *
+	 * Set the "parent" of this surface. This surface should be
+	 * stacked above the parent surface and all other ancestor
+	 * surfaces.
+	 *
+	 * Parent surfaces should be set on dialogs, toolboxes, or other
+	 * "auxiliary" surfaces, so that the parent is raised when the
+	 * dialog is raised.
+	 *
+	 * Setting a null parent for a child surface unsets its parent.
+	 * Setting a null parent for a surface which currently has no
+	 * parent is a no-op.
+	 *
+	 * Only mapped surfaces can have child surfaces. Setting a parent
+	 * which is not mapped is equivalent to setting a null parent. If a
+	 * surface becomes unmapped, its children's parent is set to the
+	 * parent of the now-unmapped surface. If the now-unmapped surface
+	 * has no parent, its children's parent is unset. If the
+	 * now-unmapped surface becomes mapped again, its parent-child
+	 * relationship is not restored.
+	 *
+	 * The parent toplevel must not be one of the child toplevel's
+	 * descendants, and the parent must be different from the child
+	 * toplevel, otherwise the invalid_parent protocol error is raised.
+	 */
+	void (*set_parent)(struct wl_client *client,
+			   struct wl_resource *resource,
+			   struct wl_resource *parent);
+	/**
+	 * set surface title
+	 *
+	 * Set a short title for the surface.
+	 *
+	 * This string may be used to identify the surface in a task bar,
+	 * window list, or other user interface elements provided by the
+	 * compositor.
+	 *
+	 * The string must be encoded in UTF-8.
+	 */
+	void (*set_title)(struct wl_client *client,
+			  struct wl_resource *resource,
+			  const char *title);
+	/**
+	 * set application ID
+	 *
+	 * Set an application identifier for the surface.
+	 *
+	 * The app ID identifies the general class of applications to which
+	 * the surface belongs. The compositor can use this to group
+	 * multiple surfaces together, or to determine how to launch a new
+	 * application.
+	 *
+	 * For D-Bus activatable applications, the app ID is used as the
+	 * D-Bus service name.
+	 *
+	 * The compositor shell will try to group application surfaces
+	 * together by their app ID. As a best practice, it is suggested to
+	 * select app ID's that match the basename of the application's
+	 * .desktop file. For example, "org.freedesktop.FooViewer" where
+	 * the .desktop file is "org.freedesktop.FooViewer.desktop".
+	 *
+	 * Like other properties, a set_app_id request can be sent after
+	 * the xdg_toplevel has been mapped to update the property.
+	 *
+	 * See the desktop-entry specification [0] for more details on
+	 * application identifiers and how they relate to well-known D-Bus
+	 * names and .desktop files.
+	 *
+	 * [0] https://standards.freedesktop.org/desktop-entry-spec/
+	 */
+	void (*set_app_id)(struct wl_client *client,
+			   struct wl_resource *resource,
+			   const char *app_id);
+	/**
+	 * show the window menu
+	 *
+	 * Clients implementing client-side decorations might want to
+	 * show a context menu when right-clicking on the decorations,
+	 * giving the user a menu that they can use to maximize or minimize
+	 * the window.
+	 *
+	 * This request asks the compositor to pop up such a window menu at
+	 * the given position, relative to the local surface coordinates of
+	 * the parent surface. There are no guarantees as to what menu
+	 * items the window menu contains, or even if a window menu will be
+	 * drawn at all.
+	 *
+	 * This request must be used in response to some sort of user
+	 * action like a button press, key press, or touch down event.
+	 * @param seat the wl_seat of the user event
+	 * @param serial the serial of the user event
+	 * @param x the x position to pop up the window menu at
+	 * @param y the y position to pop up the window menu at
+	 */
+	void (*show_window_menu)(struct wl_client *client,
+				 struct wl_resource *resource,
+				 struct wl_resource *seat,
+				 uint32_t serial,
+				 int32_t x,
+				 int32_t y);
+	/**
+	 * start an interactive move
+	 *
+	 * Start an interactive, user-driven move of the surface.
+	 *
+	 * This request must be used in response to some sort of user
+	 * action like a button press, key press, or touch down event. The
+	 * passed serial is used to determine the type of interactive move
+	 * (touch, pointer, etc).
+	 *
+	 * The server may ignore move requests depending on the state of
+	 * the surface (e.g. fullscreen or maximized), or if the passed
+	 * serial is no longer valid.
+	 *
+	 * If triggered, the surface will lose the focus of the device
+	 * (wl_pointer, wl_touch, etc) used for the move. It is up to the
+	 * compositor to visually indicate that the move is taking place,
+	 * such as updating a pointer cursor, during the move. There is no
+	 * guarantee that the device focus will return when the move is
+	 * completed.
+	 * @param seat the wl_seat of the user event
+	 * @param serial the serial of the user event
+	 */
+	void (*move)(struct wl_client *client,
+		     struct wl_resource *resource,
+		     struct wl_resource *seat,
+		     uint32_t serial);
+	/**
+	 * start an interactive resize
+	 *
+	 * Start a user-driven, interactive resize of the surface.
+	 *
+	 * This request must be used in response to some sort of user
+	 * action like a button press, key press, or touch down event. The
+	 * passed serial is used to determine the type of interactive
+	 * resize (touch, pointer, etc).
+	 *
+	 * The server may ignore resize requests depending on the state of
+	 * the surface (e.g. fullscreen or maximized).
+	 *
+	 * If triggered, the client will receive configure events with the
+	 * "resize" state enum value and the expected sizes. See the
+	 * "resize" enum value for more details about what is required. The
+	 * client must also acknowledge configure events using
+	 * "ack_configure". After the resize is completed, the client will
+	 * receive another "configure" event without the resize state.
+	 *
+	 * If triggered, the surface also will lose the focus of the device
+	 * (wl_pointer, wl_touch, etc) used for the resize. It is up to the
+	 * compositor to visually indicate that the resize is taking place,
+	 * such as updating a pointer cursor, during the resize. There is
+	 * no guarantee that the device focus will return when the resize
+	 * is completed.
+	 *
+	 * The edges parameter specifies how the surface should be resized,
+	 * and is one of the values of the resize_edge enum. Values not
+	 * matching a variant of the enum will cause the
+	 * invalid_resize_edge protocol error. The compositor may use this
+	 * information to update the surface position for example when
+	 * dragging the top left corner. The compositor may also use this
+	 * information to adapt its behavior, e.g. choose an appropriate
+	 * cursor image.
+	 * @param seat the wl_seat of the user event
+	 * @param serial the serial of the user event
+	 * @param edges which edge or corner is being dragged
+	 */
+	void (*resize)(struct wl_client *client,
+		       struct wl_resource *resource,
+		       struct wl_resource *seat,
+		       uint32_t serial,
+		       uint32_t edges);
+	/**
+	 * set the maximum size
+	 *
+	 * Set a maximum size for the window.
+	 *
+	 * The client can specify a maximum size so that the compositor
+	 * does not try to configure the window beyond this size.
+	 *
+	 * The width and height arguments are in window geometry
+	 * coordinates. See xdg_surface.set_window_geometry.
+	 *
+	 * Values set in this way are double-buffered, see
+	 * wl_surface.commit.
+	 *
+	 * The compositor can use this information to allow or disallow
+	 * different states like maximize or fullscreen and draw accurate
+	 * animations.
+	 *
+	 * Similarly, a tiling window manager may use this information to
+	 * place and resize client windows in a more effective way.
+	 *
+	 * The client should not rely on the compositor to obey the maximum
+	 * size. The compositor may decide to ignore the values set by the
+	 * client and request a larger size.
+	 *
+	 * If never set, or a value of zero in the request, means that the
+	 * client has no expected maximum size in the given dimension. As a
+	 * result, a client wishing to reset the maximum size to an
+	 * unspecified state can use zero for width and height in the
+	 * request.
+	 *
+	 * Requesting a maximum size to be smaller than the minimum size of
+	 * a surface is illegal and will result in an invalid_size error.
+	 *
+	 * The width and height must be greater than or equal to zero.
+	 * Using strictly negative values for width or height will result
+	 * in a invalid_size error.
+	 */
+	void (*set_max_size)(struct wl_client *client,
+			     struct wl_resource *resource,
+			     int32_t width,
+			     int32_t height);
+	/**
+	 * set the minimum size
+	 *
+	 * Set a minimum size for the window.
+	 *
+	 * The client can specify a minimum size so that the compositor
+	 * does not try to configure the window below this size.
+	 *
+	 * The width and height arguments are in window geometry
+	 * coordinates. See xdg_surface.set_window_geometry.
+	 *
+	 * Values set in this way are double-buffered, see
+	 * wl_surface.commit.
+	 *
+	 * The compositor can use this information to allow or disallow
+	 * different states like maximize or fullscreen and draw accurate
+	 * animations.
+	 *
+	 * Similarly, a tiling window manager may use this information to
+	 * place and resize client windows in a more effective way.
+	 *
+	 * The client should not rely on the compositor to obey the minimum
+	 * size. The compositor may decide to ignore the values set by the
+	 * client and request a smaller size.
+	 *
+	 * If never set, or a value of zero in the request, means that the
+	 * client has no expected minimum size in the given dimension. As a
+	 * result, a client wishing to reset the minimum size to an
+	 * unspecified state can use zero for width and height in the
+	 * request.
+	 *
+	 * Requesting a minimum size to be larger than the maximum size of
+	 * a surface is illegal and will result in an invalid_size error.
+	 *
+	 * The width and height must be greater than or equal to zero.
+	 * Using strictly negative values for width and height will result
+	 * in a invalid_size error.
+	 */
+	void (*set_min_size)(struct wl_client *client,
+			     struct wl_resource *resource,
+			     int32_t width,
+			     int32_t height);
+	/**
+	 * maximize the window
+	 *
+	 * Maximize the surface.
+	 *
+	 * After requesting that the surface should be maximized, the
+	 * compositor will respond by emitting a configure event. Whether
+	 * this configure actually sets the window maximized is subject to
+	 * compositor policies. The client must then update its content,
+	 * drawing in the configured state. The client must also
+	 * acknowledge the configure when committing the new content (see
+	 * ack_configure).
+	 *
+	 * It is up to the compositor to decide how and where to maximize
+	 * the surface, for example which output and what region of the
+	 * screen should be used.
+	 *
+	 * If the surface was already maximized, the compositor will still
+	 * emit a configure event with the "maximized" state.
+	 *
+	 * If the surface is in a fullscreen state, this request has no
+	 * direct effect. It may alter the state the surface is returned to
+	 * when unmaximized unless overridden by the compositor.
+	 */
+	void (*set_maximized)(struct wl_client *client,
+			      struct wl_resource *resource);
+	/**
+	 * unmaximize the window
+	 *
+	 * Unmaximize the surface.
+	 *
+	 * After requesting that the surface should be unmaximized, the
+	 * compositor will respond by emitting a configure event. Whether
+	 * this actually un-maximizes the window is subject to compositor
+	 * policies. If available and applicable, the compositor will
+	 * include the window geometry dimensions the window had prior to
+	 * being maximized in the configure event. The client must then
+	 * update its content, drawing it in the configured state. The
+	 * client must also acknowledge the configure when committing the
+	 * new content (see ack_configure).
+	 *
+	 * It is up to the compositor to position the surface after it was
+	 * unmaximized; usually the position the surface had before
+	 * maximizing, if applicable.
+	 *
+	 * If the surface was already not maximized, the compositor will
+	 * still emit a configure event without the "maximized" state.
+	 *
+	 * If the surface is in a fullscreen state, this request has no
+	 * direct effect. It may alter the state the surface is returned to
+	 * when unmaximized unless overridden by the compositor.
+	 */
+	void (*unset_maximized)(struct wl_client *client,
+				struct wl_resource *resource);
+	/**
+	 * set the window as fullscreen on an output
+	 *
+	 * Make the surface fullscreen.
+	 *
+	 * After requesting that the surface should be fullscreened, the
+	 * compositor will respond by emitting a configure event. Whether
+	 * the client is actually put into a fullscreen state is subject to
+	 * compositor policies. The client must also acknowledge the
+	 * configure when committing the new content (see ack_configure).
+	 *
+	 * The output passed by the request indicates the client's
+	 * preference as to which display it should be set fullscreen on.
+	 * If this value is NULL, it's up to the compositor to choose which
+	 * display will be used to map this surface.
+	 *
+	 * If the surface doesn't cover the whole output, the compositor
+	 * will position the surface in the center of the output and
+	 * compensate with with border fill covering the rest of the
+	 * output. The content of the border fill is undefined, but should
+	 * be assumed to be in some way that attempts to blend into the
+	 * surrounding area (e.g. solid black).
+	 *
+	 * If the fullscreened surface is not opaque, the compositor must
+	 * make sure that other screen content not part of the same surface
+	 * tree (made up of subsurfaces, popups or similarly coupled
+	 * surfaces) are not visible below the fullscreened surface.
+	 */
+	void (*set_fullscreen)(struct wl_client *client,
+			       struct wl_resource *resource,
+			       struct wl_resource *output);
+	/**
+	 * unset the window as fullscreen
+	 *
+	 * Make the surface no longer fullscreen.
+	 *
+	 * After requesting that the surface should be unfullscreened, the
+	 * compositor will respond by emitting a configure event. Whether
+	 * this actually removes the fullscreen state of the client is
+	 * subject to compositor policies.
+	 *
+	 * Making a surface unfullscreen sets states for the surface based
+	 * on the following: * the state(s) it may have had before becoming
+	 * fullscreen * any state(s) decided by the compositor * any
+	 * state(s) requested by the client while the surface was
+	 * fullscreen
+	 *
+	 * The compositor may include the previous window geometry
+	 * dimensions in the configure event, if applicable.
+	 *
+	 * The client must also acknowledge the configure when committing
+	 * the new content (see ack_configure).
+	 */
+	void (*unset_fullscreen)(struct wl_client *client,
+				 struct wl_resource *resource);
+	/**
+	 * set the window as minimized
+	 *
+	 * Request that the compositor minimize your surface. There is no
+	 * way to know if the surface is currently minimized, nor is there
+	 * any way to unset minimization on this surface.
+	 *
+	 * If you are looking to throttle redrawing when minimized, please
+	 * instead use the wl_surface.frame event for this, as this will
+	 * also work with live previews on windows in Alt-Tab, Expose or
+	 * similar compositor features.
+	 */
+	void (*set_minimized)(struct wl_client *client,
+			      struct wl_resource *resource);
+};
+
+#define XDG_TOPLEVEL_CONFIGURE 0
+#define XDG_TOPLEVEL_CLOSE 1
+#define XDG_TOPLEVEL_CONFIGURE_BOUNDS 2
+#define XDG_TOPLEVEL_WM_CAPABILITIES 3
+
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_CONFIGURE_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_CLOSE_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_CONFIGURE_BOUNDS_SINCE_VERSION 4
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_WM_CAPABILITIES_SINCE_VERSION 5
+
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_SET_PARENT_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_SET_TITLE_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_SET_APP_ID_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_SHOW_WINDOW_MENU_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_MOVE_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_RESIZE_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_SET_MAX_SIZE_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_SET_MIN_SIZE_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_SET_MAXIMIZED_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_UNSET_MAXIMIZED_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_SET_FULLSCREEN_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_UNSET_FULLSCREEN_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_SET_MINIMIZED_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_xdg_toplevel
+ * Sends an configure event to the client owning the resource.
+ * @param resource_ The client's resource
+ */
+static inline void
+xdg_toplevel_send_configure(struct wl_resource *resource_, int32_t width, int32_t height, struct wl_array *states)
+{
+	wl_resource_post_event(resource_, XDG_TOPLEVEL_CONFIGURE, width, height, states);
+}
+
+/**
+ * @ingroup iface_xdg_toplevel
+ * Sends an close event to the client owning the resource.
+ * @param resource_ The client's resource
+ */
+static inline void
+xdg_toplevel_send_close(struct wl_resource *resource_)
+{
+	wl_resource_post_event(resource_, XDG_TOPLEVEL_CLOSE);
+}
+
+/**
+ * @ingroup iface_xdg_toplevel
+ * Sends an configure_bounds event to the client owning the resource.
+ * @param resource_ The client's resource
+ */
+static inline void
+xdg_toplevel_send_configure_bounds(struct wl_resource *resource_, int32_t width, int32_t height)
+{
+	wl_resource_post_event(resource_, XDG_TOPLEVEL_CONFIGURE_BOUNDS, width, height);
+}
+
+/**
+ * @ingroup iface_xdg_toplevel
+ * Sends an wm_capabilities event to the client owning the resource.
+ * @param resource_ The client's resource
+ * @param capabilities array of 32-bit capabilities
+ */
+static inline void
+xdg_toplevel_send_wm_capabilities(struct wl_resource *resource_, struct wl_array *capabilities)
+{
+	wl_resource_post_event(resource_, XDG_TOPLEVEL_WM_CAPABILITIES, capabilities);
+}
+
+#ifndef XDG_POPUP_ERROR_ENUM
+#define XDG_POPUP_ERROR_ENUM
+enum xdg_popup_error {
+	/**
+	 * tried to grab after being mapped
+	 */
+	XDG_POPUP_ERROR_INVALID_GRAB = 0,
+};
+/**
+ * @ingroup iface_xdg_popup
+ * Validate a xdg_popup error value.
+ *
+ * @return true on success, false on error.
+ * @ref xdg_popup_error
+ */
+static inline bool
+xdg_popup_error_is_valid(uint32_t value, uint32_t version) {
+	switch (value) {
+	case XDG_POPUP_ERROR_INVALID_GRAB:
+		return version >= 1;
+	default:
+		return false;
+	}
+}
+#endif /* XDG_POPUP_ERROR_ENUM */
+
+/**
+ * @ingroup iface_xdg_popup
+ * @struct xdg_popup_interface
+ */
+struct xdg_popup_interface {
+	/**
+	 * remove xdg_popup interface
+	 *
+	 * This destroys the popup. Explicitly destroying the xdg_popup
+	 * object will also dismiss the popup, and unmap the surface.
+	 *
+	 * If this xdg_popup is not the "topmost" popup, the
+	 * xdg_wm_base.not_the_topmost_popup protocol error will be sent.
+	 */
+	void (*destroy)(struct wl_client *client,
+			struct wl_resource *resource);
+	/**
+	 * make the popup take an explicit grab
+	 *
+	 * This request makes the created popup take an explicit grab. An
+	 * explicit grab will be dismissed when the user dismisses the
+	 * popup, or when the client destroys the xdg_popup. This can be
+	 * done by the user clicking outside the surface, using the
+	 * keyboard, or even locking the screen through closing the lid or
+	 * a timeout.
+	 *
+	 * If the compositor denies the grab, the popup will be immediately
+	 * dismissed.
+	 *
+	 * This request must be used in response to some sort of user
+	 * action like a button press, key press, or touch down event. The
+	 * serial number of the event should be passed as 'serial'.
+	 *
+	 * The parent of a grabbing popup must either be an xdg_toplevel
+	 * surface or another xdg_popup with an explicit grab. If the
+	 * parent is another xdg_popup it means that the popups are nested,
+	 * with this popup now being the topmost popup.
+	 *
+	 * Nested popups must be destroyed in the reverse order they were
+	 * created in, e.g. the only popup you are allowed to destroy at
+	 * all times is the topmost one.
+	 *
+	 * When compositors choose to dismiss a popup, they may dismiss
+	 * every nested grabbing popup as well. When a compositor dismisses
+	 * popups, it will follow the same dismissing order as required
+	 * from the client.
+	 *
+	 * If the topmost grabbing popup is destroyed, the grab will be
+	 * returned to the parent of the popup, if that parent previously
+	 * had an explicit grab.
+	 *
+	 * If the parent is a grabbing popup which has already been
+	 * dismissed, this popup will be immediately dismissed. If the
+	 * parent is a popup that did not take an explicit grab, an error
+	 * will be raised.
+	 *
+	 * During a popup grab, the client owning the grab will receive
+	 * pointer and touch events for all their surfaces as normal
+	 * (similar to an "owner-events" grab in X11 parlance), while the
+	 * top most grabbing popup will always have keyboard focus.
+	 * @param seat the wl_seat of the user event
+	 * @param serial the serial of the user event
+	 */
+	void (*grab)(struct wl_client *client,
+		     struct wl_resource *resource,
+		     struct wl_resource *seat,
+		     uint32_t serial);
+	/**
+	 * recalculate the popup's location
+	 *
+	 * Reposition an already-mapped popup. The popup will be placed
+	 * given the details in the passed xdg_positioner object, and a
+	 * xdg_popup.repositioned followed by xdg_popup.configure and
+	 * xdg_surface.configure will be emitted in response. Any
+	 * parameters set by the previous positioner will be discarded.
+	 *
+	 * The passed token will be sent in the corresponding
+	 * xdg_popup.repositioned event. The new popup position will not
+	 * take effect until the corresponding configure event is
+	 * acknowledged by the client. See xdg_popup.repositioned for
+	 * details. The token itself is opaque, and has no other special
+	 * meaning.
+	 *
+	 * If multiple reposition requests are sent, the compositor may
+	 * skip all but the last one.
+	 *
+	 * If the popup is repositioned in response to a configure event
+	 * for its parent, the client should send an
+	 * xdg_positioner.set_parent_configure and possibly an
+	 * xdg_positioner.set_parent_size request to allow the compositor
+	 * to properly constrain the popup.
+	 *
+	 * If the popup is repositioned together with a parent that is
+	 * being resized, but not in response to a configure event, the
+	 * client should send an xdg_positioner.set_parent_size request.
+	 * @param token reposition request token
+	 * @since 3
+	 */
+	void (*reposition)(struct wl_client *client,
+			   struct wl_resource *resource,
+			   struct wl_resource *positioner,
+			   uint32_t token);
+};
+
+#define XDG_POPUP_CONFIGURE 0
+#define XDG_POPUP_POPUP_DONE 1
+#define XDG_POPUP_REPOSITIONED 2
+
+/**
+ * @ingroup iface_xdg_popup
+ */
+#define XDG_POPUP_CONFIGURE_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_popup
+ */
+#define XDG_POPUP_POPUP_DONE_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_popup
+ */
+#define XDG_POPUP_REPOSITIONED_SINCE_VERSION 3
+
+/**
+ * @ingroup iface_xdg_popup
+ */
+#define XDG_POPUP_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_popup
+ */
+#define XDG_POPUP_GRAB_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_popup
+ */
+#define XDG_POPUP_REPOSITION_SINCE_VERSION 3
+
+/**
+ * @ingroup iface_xdg_popup
+ * Sends an configure event to the client owning the resource.
+ * @param resource_ The client's resource
+ * @param x x position relative to parent surface window geometry
+ * @param y y position relative to parent surface window geometry
+ * @param width window geometry width
+ * @param height window geometry height
+ */
+static inline void
+xdg_popup_send_configure(struct wl_resource *resource_, int32_t x, int32_t y, int32_t width, int32_t height)
+{
+	wl_resource_post_event(resource_, XDG_POPUP_CONFIGURE, x, y, width, height);
+}
+
+/**
+ * @ingroup iface_xdg_popup
+ * Sends an popup_done event to the client owning the resource.
+ * @param resource_ The client's resource
+ */
+static inline void
+xdg_popup_send_popup_done(struct wl_resource *resource_)
+{
+	wl_resource_post_event(resource_, XDG_POPUP_POPUP_DONE);
+}
+
+/**
+ * @ingroup iface_xdg_popup
+ * Sends an repositioned event to the client owning the resource.
+ * @param resource_ The client's resource
+ * @param token reposition request token
+ */
+static inline void
+xdg_popup_send_repositioned(struct wl_resource *resource_, uint32_t token)
+{
+	wl_resource_post_event(resource_, XDG_POPUP_REPOSITIONED, token);
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
